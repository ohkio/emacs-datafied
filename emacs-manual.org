* Manual
** Distribution
** Introduction
** The Organization of the Screen
   Goes through an overview of
   - Frame :: The Graphical window or entire terminal running Emacs.
   - Menu Bar :: Organization of various commands and instructions in
                 Emacs's.
   - Tool Bar :: Only appears when running Emacs in a graphical
                 display. List of shortcuts to common commands.
   - Echo Area :: Where informative messages are displayed and where
                  you enter information when Emacs asks for it.
   - Window :: Area of editing below the tool bar (if one exists) and
               above the echo area.
   - Buffer :: the text or other graphics you are editing or viewing.
   - Mode Line :: This displays various information about what is
                  going on in the buffer.
*** Point
    Basically the cursor. Comes from ~.~ which was the original
    command for accessing the editing position way back when.
*** The Echo Area
    Detailed explanation of stuff.
    - Minibuffer :: a special window where you can input arguments to
                    commands within the [[Echo Area]]
*** The Mode Line
    #+BEGIN_SRC
    cs:ch-fr  buf     pos line   (major minor)
    #+END_SRC
    Explanation:
    - ~cs~ :: Character Set. Depends on the encoding of the document
    - ~:~ :: Changes depending on the newline convention.
      - ~:~ or ~Unix~ :: Lines end in newline character
      - ~\~ or ~DOS~ :: Lines end in carriage return, linefeed
      - ~/~ or ~Mac~ :: Lines end in carriage return
      - ~@~ :: When the frame was created for ~emacsclient~
    - ~ch~ :: Status of buffer
      - ~--~ :: Buffer is unchanged from file
      - ~**~ :: Buffer is modified from file
      - ~%%~ :: Unmodified read only buffer
      - ~%*~ :: Modified read only buffer
    - ~-~ :: Location of file for current buffer
      - ~-~ :: Local file
      - ~@~ :: Remote file
    - ~fr~ :: Name of selected frame. Only relevant for text terminals
      - ~F1~ :: Name of initial frame
    - ~buf~ :: Name of buffer. Normally the file name.
    - ~pos~ :: Indicates whether there is additional text above the
      top of the window or below the bottom.
      - ~All~ :: The entire buffer is visible in the window
      - ~Top~ :: You are looking at the beginning of the buffer
      - ~Bot~ :: You are looking at the end of the buffer
      - ~nn%~ :: This means /nn/ is the percentage of the buffer above
        the top of the window.
    - ~line~ :: the character ~L~ followed by the line number at
      point.
    - ~major~ :: Name of the major mode used in the buffer.
    - ~minor~ :: A list of some of the enabled minor modes, or
      relevant features.
      - ~Narrow~ :: Buffer being displayed has editing restricted to
        only a portion of it's text.
      - ~Def~ :: A keyboard macro is currently being defined.
    - ~(...)~ :: If Emacs is inside a recursive editing level, square
      brackets ~[...]~ appear around the parentheses that surround
      the modes

    Extra Functionality:
    - Hovering around the mode line shows tool tips.
    - Clicking on different parts of the mode line performs various
      commands

    Words and concepts defined or mentioned:
    - Major Mode :: the principal editing mode for a given buffer.
    - Minor Mode :: Optional editing modes that provide additional
      features on top of the major mode.
    - Narrowing :: When you restrict editing to only a portion of
      buffer.
    - Keyboard Macro :: Mentioned not defined
    - Recursive Edit :: Mentioned not defined
    - Tooltips :: Mentioned not defined
*** The Menu Bar
    Some interesting details about the menu bar.

    Mentions the concept:
    - Variable
** Kinds of User Input
   Some Syntax
   - <SPC> :: The space-bar
   - <RET> :: The Return or Enter key
   - <TAB> :: The Tab key
   - <DEL> :: The Delete key
   - <ESC> :: The Esc or Escape key
   - <F1> :: The F1 or first function key
   - <Home> :: The Home key
   - <LEFT> :: The Left Arrow key
   - <Control> or <Ctrl> :: The Control or Ctrl key (not different
                            keys)
   - <Meta> :: The Meta or Alt key
   - ~Control-a~ or ~C-a~ :: Holding down the <Ctrl> key while
     pressing ~a~
   - ~<Meta>-a~ or ~M-a~ :: Holding down the <Alt> key while pressing
     ~a~
   - ~C-M-a~ :: Holding down <Ctrl> and <Alt> while pressing ~a~

   These commands might be blocked by the OS
   - ~M-<TAB>~
   - ~M-<SPC>~
   - ~C-M-d~
   - ~C-M-l~
** Keys
   Definitions:
   - Key Sequence or Key :: A sequence of one or more input events
     that is meaningful as a unit.
     - Complete Key :: A Key Sequence that invokes a command
     - Prefix Key :: A Key Sequence that isn't long enough to invoke a
       command

   All Key Sequences are either Complete Keys or Prefix Keys.

   These are the default Prefix Keys
   - ~C-c~
   - ~C-h~ or ~<F1>~
   - ~C-x~
   - ~C-x <RET>~
   - ~C-x @~
   - ~C-x a~
   - ~C-x n~
   - ~C-x r~
   - ~C-x v~
   - ~C-x 4~
   - ~C-x 5~
   - ~C-x 6~ or ~<F2>~
   - ~<ESC>~
   - ~M-g~
   - ~M-o~
** Keys and Commands
   Definitions
   - Command :: a name used to store an action to perform in Emacs
   - Function :: Not defined, but mentioned
   - Keymaps :: Not defined, but mentioned
   - Variable :: a name used to store a value
** Entering Emacs
   Start Emacs from the shell.
   #+BEGIN_SRC sh
   emacs
   #+END_SRC

   Run Emacs in the background of a terminal to continue to use the
   terminal.
   #+BEGIN_SRC sh
   emacs &
   #+END_SRC

   Open ~foo.txt~ in Emacs
   #+BEGIN_SRC sh
   emacs foo.txt
   #+END_SRC

   Vocabulary mentioned or defined
   - Kill Ring :: Not defined but mentioned
   - Registers :: Not defined but mentioned
   - Undo History :: Not defined but mentioned
   - Mark Ring :: Not defined but mentioned
** Exiting Emacs
** Basic Editing Commands
*** Inserting Text
*** Changing the Location of Point
*** Erasing Text
*** Undoing Changes
*** Files
*** Help
*** Blank Lines
*** Continuation Lines
*** Cursor Position Information
*** Numeric Arguments
    Examples
    #+BEGIN_SRC
    M-5 C-n
    #+END_SRC
    Move down five (5) lines.

    #+BEGIN_SRC
    M-- C-n
    #+END_SRC
    Move up one (1) line.

    #+BEGIN_SRC
    M-- 3 C-n
    #+END_SRC
    Move up three (3) lines

    #+BEGIN_SRC
    M-5 0 C-n
    #+END_SRC
    Move down fifty (50) lines.

    #+BEGIN_SRC
    M-5 C-u 0
    #+END_SRC
    Insert five (5) copies of ~0~.

    #+BEGIN_SRC
    C-u 2 5 C-n
    #+END_SRC
    Move down twenty-five (25) lines

    #+BEGIN_SRC
    C-u - 1 2 C-n
    #+END_SRC
    Move up twelve (12) lines

    #+BEGIN_SRC
    C-u - C-n
    #+END_SRC
    Move up one (1) line

    #+BEGIN_SRC
    C-u C-n
    #+END_SRC
    Move down four (4) lines

    #+BEGIN_SRC
    C-u C-u C-n
    #+END_SRC
    Move down sixteen (16) lines

    #+BEGIN_SRC
    C-u 6 4 a
    #+END_SRC
    Insert sixty-four (64) copies of the character ~a~.

    #+BEGIN_SRC
    C-u 6 4 C-u 1
    #+END_SRC
    Insert sixty-four (64) copies of the character ~1~.
*** Repeating a Command
    Example
    #+BEGIN_SRC
    C-u 2 0 C-d
    C-x z z z
    #+END_SRC
    Delete 80 characters.
** The Minibuffer
*** Using the Minibuffer
    Can exit the minibuffer using ~C-g~
*** Minibuffers for File Names
    Options to change file/directory
    - ~M-n~ :: Next default for file name
    - ~M-<DEL>~ :: Kill directory name backwards
    - ~C-a C-k~ :: Clear entire minibuffer

    When file is a remote file:
    - a double slash ignores the file-name but keeps the method, host
      and username.
    - three slashes in a row ignores everything, both file-name and
      the method, host and username.

    #+BEGIN_SRC
    ~/
    #+END_SRC
    home directory

    #+BEGIN_SRC
    ~user-id/
    #+END_SRC
    The home directory of a user whose login name is /user-id/
*** Editing in the Minibuffer
    The following commands behave differently in the minibuffer
    compared with standard buffers:
    - ~<RET>~
    - ~<TAB>~
    - ~<SPC>~
    - ~?~

    You can use ~C-q~ to insert these into the minibuffer as you would
    expect them to be inserted.

    The minibuffer is displayed in the Echo Area. When the minibuffer
    is active, it can be thought of as it's own window. You can
    navigate windows how you normally would and return to the
    minibuffer as if it is it's own window. However standard windows
    can be split, and the Echo Area cannot be split into multiple
    windows.

    Clicking ~mouse-1~ in the Echo Area when the minibuffer is not
    active shows the ~*Messages*~ buffer in a new window.
*** Completion
    - Completion :: A helpful feature of Emacs to help enter
      arguments. This means that after you type part of the argument,
      Emacs can fill in the rest, or some of it, based on what was
      typed so far.
**** Completion Example
     #+BEGIN_SRC
     M-x c u s <TAB> i <TAB> - v <TAB>
     #+END_SRC
     Enter ~customize-variable~ into the minibuffer as a command to
     run.
**** Completion Commands
**** Completion Exit
     There are Four types of behavior for the command
     ~minibuffer-complete-and-exit~.

     - Strict Completion
       - If minibuffer is exact match :: Exits the minibuffer.
       - If minibuffer completes to exact match :: Complete match and
         exit the minibuffer.
       - Else :: Attempts to complete, refuses to exit, displays "[No
         match]"
     - Cautious Completion
       - If minibuffer is exact match :: Exits the minibuffer.
       - If minibuffer completes to exact match :: Complete match,
         does not exit the minibuffer.
       - Else :: (unsure of exact behavior)
     - Permissive Completion
       - Any context :: Exits the minibuffer.
     - Permissive Completion with Confirmation
       - After typing <TAB> to partial completion :: does not exit
         minibuffer, displays "[Confirm]".
       - Else :: Exits the minibuffer.
**** How Completion Alternatives Are Chosen
     Completion tries each style and then moves onto the next in the
     list if unsuccessful. Here is the list in order:
     - ~basic~ :: A matching completion alternative must have the same
       beginning as the text in the minibuffer before
       point. Furthermore, if there is any text in the minibuffer
       after point, the rest of the completion alternative must
       contain that text as a sub-string.
     - ~partial-completion~ :: This aggressive completion style
       divides the minibuffer text into words separated by hyphens or
       spaces, and completes each word separately. (for example, when
       completing command names, 'em-l-m' completes to
       'emacs-lisp-mode'.) Furthermore a '*' in the minibuffer text is
       treated as a wildcard - it matches any string of characters at
       the corresponding position in the completion alternative.
     - ~emacs22~ :: This completion style is similar to ~basic~,
       except that it ignores the text in the minibuffer after
       point. It is so-named because it corresponds to the completion
       behavior in Emacs 22.

     Additional list options
     - ~substring~ :: A matching completion alternative must contain
       the text in the minibuffer before point, and the text in the
       minibuffer after point, as sub-strings (in that same
       order). Thus if the text in the minibuffer is 'foobar', with
       point between 'foo' and 'bar', that matches 'dfooebarf', where
       d, e, and f can be any string including the empty string.
     - ~initials~ :: This very aggressive completion style attempts to
       complete acronyms and initialisms. For example, when completing
       command names, it matches 'lch' to 'list-command-history'.
     - ~emacs21~ :: Only matches that start with the text in the
       minibuffer are considered, regardless of point location.
**** Completion Options
*** Minibuffer History
*** Repeating Minibuffer Commands
    Vocabulary
    - Command History :: Special history list that records complex
      commands that required an argument from the minibuffer.
*** Entering passwords
    Entering passwords is a slightly different context than the
    minibuffer is normally.

    Most features and commands associated with the minibuffer /cannot/
    be used when entering a password. No completion, no changing
    windows.

    - ~<DEL>~ :: removes last character entered.
    - ~C-u~ :: deletes everything you have typed so far.
    - ~C-g~ :: quits the password prompt.
    - ~C-y~ :: inserts the current kill into the password.
    - ~<RET>~ OR ~<ESC>~ :: submit password.
*** Yes or No Prompts
    There are two types of yes or no prompts.

    The first kind ends an Echo Area prompt with ~(y or n)~.
    - ~C-l~ :: recenter the selected window
    - ~C-v~ OR ~<PageDown>~ OR ~<next>~ :: scroll forward.
    - ~M-v~ OR ~<PageUp>~ OR ~<prior>~ :: scroll backward.
    - ~C-M-v~ :: scrolls forward in the next window.
    - ~C-M-S-v~ :: scrolls backward in the next window.
    - ~C-g~ :: dismisses query and quits the command.

    The second kind ends an Echo Area prompt with ~(yes or no)~. This
    behaves the exact same as standard minibuffer context
** Running Commands by Name
** Help
   When looking for a feature but don't know what it's called, here is
   the suggested method of how to find it in the following order:
   - ~C-h a /topics/ <RET>~ :: This is an apropos command, literally
     runs ~apropos-command~. Searches for commands whose names match
     the argument /topics/
   - ~C-h r i /topic/ <RET>~ :: This navigates to the
     Emacs manual and then searches for /topic/ in the indices.
   - ~C-h r s /topic/ <RET>~ :: Similar as above, but
     searches the text of the manual rather than the indices
   - ~C-h C-f~ :: Displays the Emacs FAQ, using Info.
   - ~C-h p~ :: Displays the available Emacs packages based on
     keywords.

   Additionally, typing one of the following commands after a prefix
   command can mean seeing a list of possible complete keys:
   - ~C-h~
   - ~<F1>~
   - ~?~
*** Help Summary
*** Documentation for a Key
*** Help by Command or Variable Name
*** Apropos
    When searching apropos, entering one word will look for that word
    anywhere in the name. Entering more than one word will look for
    two of the provided words anywhere in the name.

    If text contains regex characters: ~^$*+?.\[~ the text to search
    is interpreted as a regular expression

    Helpful apropos words
    - char
    - line
    - word
    - sentence
    - paragraph
    - region
    - page
    - sexp
    - list
    - defun
    - rect
    - buffer
    - frame
    - window
    - face
    - file
    - dir
    - register
    - mode
    - beginning
    - end
    - forward
    - backward
    - next
    - previous
    - up
    - down
    - search
    - goto
    - kill
    - delete
    - mark
    - insert
    - yank
    - fill
    - indent
    - case
    - change
    - set
    - what
    - list
    - find
    - view
    - describe
    - default

    By default, all apropos commands except ~apropos-documentation~
    list their results in alphabetical order.

    The ~apropos-documentation~ command lists its results in order of
    relevance by default.
*** Help Mode Commands
    Vocabulary mentioned:
    - Faces
*** Keyword Search for Packages
*** Help for International Language Support
*** Other Help Commands
*** Help Files
*** Help on Active Text and Tooltips
** The Mark and the Region
   Vocabulary
   - Mark :: An arbitrary point you define that stays in place while
     you move the point around. Deactivates after editing or
     quitting.
   - Region :: The portion of the buffer that is contained between the
     Mark and the Point. Only active when Mark is active.

   Setting the mark in one buffer has no effect on the marks in other
   buffers. When you return to a buffer with an active mark, the mark
   is at the same place as before. When multiple windows show the same
   buffer, they can have different values of point, and thus different
   regions, but they all share one common mark position.
*** Setting the Mark
    Vocabulary:
    - Shift Selection :: You can set the mark by holding down the
      shift key while typing certain cursor motion commands (such as
      ~S-<RIGHT>~, ~S-C-f~, ~S-C-n~, etc.).
    - Primary Selection :: Mentioned not well defined.

    Whenever the mark is active, you can deactivate it by typing
    ~C-g~. Most commands that operate on the region also automatically
    deactivate the mark.

    Many commands that insert text, such as ~C-y~ (~yank~), set the
    mark at the other end of the inserted text, without activating
    it. You can tell that a command does this when it shows '~Mark
    set~' in the echo area.
*** Commands to Mark Textual Objects
    Repeated invocations of ~M-@~ extend the region by advancing the
    mark one word at a time. As an exception, if the mark is active
    and located before point, ~M-@~ moves the mark backwards from its
    current position one word at a time.

    Similarly repeated invocations of ~C-M-<SPC>~ extend the region to
    subsequent expressions.

    In fact for all ~mark~-COMMAND commands the following is
    true. Repeated invocations play the same role as above, extending
    the region to consecutive objects.
*** Operating on the Region
    Example commands on region:
    - ~C-w~ :: Kill Region
    - ~M-w~ :: Copy Region to kill ring
    - ~C-x C-l~ :: Entire region to lower case
    - ~C-x C-u~ :: Entire region to upper case
    - ~C-u C-/~ :: Undo changes within region
    - ~M-%~ :: Find and replace within region
    - ~C-x <TAB>~ OR ~C-M-\~ :: Indent region
    - ~M-x fill-region~ :: Fill it as text
    - ~M-$~ :: Check spelling of words within region
    - ~M-x eval-region~ :: Evaluate region as Lisp code
    - ~C-x r s~ :: Save region in a register
    - Save region in a buffer or a file.
    - ~<DEL>~ OR ~<Delete>~ :: Delete the text in the region
*** The Mark Ring
    Each buffer remembers the previous locations of the mark, in the
    mark ring. Commands that set the mark also push the old mark onto
    this ring. One of the uses of the mark ring is to remember spots
    that you may want to go back to.

    ~C-<SPC> C-<SPC>~ is a way to set the mark, push it onto the mark
    ring, all without activating it.

    When Transient Mark mode is off, ~C-<SPC> C-<SPC>~ instead
    activates Transient Mark mode temporarily.

    To return to a marked position, use ~set-mark-command~ with a
    prefix argument: ~C-u C-<SPC>~. This moves point to where the mark
    was, and deactivates the mark if it was active. Each subsequent
    ~C-u C-<SPC>~ jumps to a prior position stored in the mark
    ring. The positions you move through in this way or not lost; they
    go to the end of the ring.
*** The Global Mark Ring
    In addition to the ordinary mark ring that belongs to each buffer,
    Emacs has a single global mark ring. Each time you set a mark,
    this is recorded in the global mark ring in addition to the
    current buffer's own mark ring, if you have switched buffers since
    the previous mark setting.
*** Shift Selection
    Definition:
    - Shift Selection :: If you hold down the shift key while typing a
      cursor motion command, this sets the mark before the moving
      point, so that the region extends from the original position of
      point to its new position.

    The mark set via shift-selection behaves a little differently from
    what we have described above. Firstly, in addition to the usual
    way of deactivating the mark (such as changing the buffer text or
    typing ~C-g~), the mark is deactivated by any /unshifted/ cursor
    motion command. Secondly, any subsequent /shifted/ cursor motion
    command avoids setting the mark anew. Therefore, a series of
    shifted cursor motion commands will continuously adjust the
    region.

    Shift-selection only works if the shifted cursor motion key is not
    already bound to a separate command. For example, if you bind
    ~S-C-f~ to another command, typing ~S-C-f~ runs that command
    instead of performing a shift-selected version of ~C-f~
    (~forward-char~).

    A mark set via mouse commands behaves the same as a mark set via
    shift-selection. For example, if you specify a region by dragging
    the mouse, you can continue to extend the region using shifted
    cursor motion commands. In either case, any unshifted cursor
    motion command deactivates the mark.
*** Disabling Transient Mark Mode
    Turning off Transient Mark mode switched Emacs to an alternative
    mode of operation:
    - Setting the mark, with commands like ~C-<SPC>~ or ~C-x C-x~,
      does not highlight the region. Therefore, you can't tell by
      looking where the mark is located; you have to remember. The
      usual solution to this problem is to set the mark and then use
      it soon, before you forget where it is. You can also check where
      the mark is by using ~C-x C-x~, which exchanges the position of
      the point and the mark.
    - Some commands, which ordinarily act on the region when the mark
      is active, no longer do so. For example, normally ~M-%~
      (~query-replace~) performs replace within the region, if the
      mark is active. When Transient Mark mode is off, it always
      operates from point to the end of the buffer. Commands that act
      this way are identified in their own documentation

    While Transient Mark mode is off, you can activate it temporarily
    using ~C-<SPC> C-<SPC>~ or ~C-u C-x C-x~.

    - ~C-<SPC> C-<SPC>~ :: Set the mark at point (like plain
      ~C-<SPC>~) and enable Transient Mark mode just once, until the
      mark is deactivated.
    - ~C-u C-x C-x~ :: Exchange point and mark, activate the mark and
      enable Transient Mark mode temporarily, until the mark is next
      deactivated.

    When you specify a region with the mouse, or with shift-selection,
    this likewise activates Transient Mark mode temporarily and
    highlights the region.
** Killing and Moving Text
   - Kill :: Erase text and copy text into the "kill ring".
   - Yank :: Bring text from the "kill ring" back into the buffer.
   - Kill Ring :: Can be visualized as a set of blocks of text
     arranged in a ring, which you can access in cyclic order.
*** Deletion and Killing
    Most commands which erase text from the buffer save it in the kill
    ring. These are known as kill commands, and their names normally
    contain the word '~kill~' (e.g., ~kill-line~). The kill ring
    stores several recent kills, not just the last one, so killing is
    a very safe operation: you don't have to worry much about losing
    text that you previously killed. The kill ring is shared by all
    buffers, so text that is killed in one buffer can be yanked into
    another buffer.

    When you use ~C-/~ (~undo~) to undo a kill command, that brings
    the killed text back into the buffer, but does not remove it from
    the kill ring.

    On graphical displays, killing text also copies it into the system
    clipboard.

    Commands that erase text but do not save it in the kill ring are
    known as delete commands; their names usually contain the word
    '~delete~'. These include ~C-d~ (~delete-char~) and ~<DEL>~
    (~delete-backward-char~), which delete only one character at a
    time, and those commands that delete only spaces or
    newlines. Commands that can erase significant amounts of
    nontrivial data generally do a kill operation instead.

    You can also use the mouse to kill and yank.
**** Deletion
**** Killing by Lines
**** Other Kill Commands
**** Options for Killing
     The kill commands work specially in a read-only buffer: they move
     over text and copy it to the kill ring, without actually deleting
     it from the buffer.
*** Yanking
    Vocabulary:
    - Yanking :: Reinserting text previously killed.

    On graphical displays, ~C-y~ first checks if another application
    has placed any text in the system clipboard more recently than the
    last Emacs kill. If so, it inserts the clipboard's text
    instead. Thus Emacs effectively treats "cut" or "copy" clipboard
    operations performed in other applications like Emacs kills,
    except that they are not recorded in the kill ring.
**** The Kill Ring
     Vocabulary
     - Kill Ring :: A list of blocks of text that were previously
       killed.

     There is only one Kill Ring, shared by all buffers, so you can
     kill text in one buffer and yank it in another buffer.

     If you make a new kill when the limit defined in ~kill-ring-max~
     has been reached, Emacs makes room by deleting the oldest entry
     in the kill ring.
**** Yanking Earlier Kills
     If the previous command was a yank command, ~M-y~ takes the text
     that was yanked and replaces it with the text from an earlier
     kill. So to recover the text of the next-to-the-last kill, first
     use ~C-y~ to yank the last kill, and then use ~M-y~ to replace it
     with the previous kill. ~M-y~ is allowed only after a ~C-y~ or
     another ~M-y~.

     You can understand ~M-y~ in terms of a last-yank pointer which
     points at an entry in the kill ring. Each time you kill, the
     last-yank pointer moves to the newly made entry at the front of
     the ring. ~C-y~ yanks the entry with the last-yank pointer points
     to. ~M-y~ moves the last-yank pointer to a different entry, and
     the text in the buffer changes to match. Enough ~M-y~ commands
     can move the pointer to any entry in the ring, so you can get any
     entry into the buffer. Eventually the pointer reaches the end of
     the ring; the next ~M-y~ loops back around to the first entry
     again.

     ~M-y~ moves the last-yank pointer around the ring, but it does
     not change the order of the entries in the ring, which always
     runs from the most recent kill at the front to the oldest one
     still remembered.

     As long as no new killing is done, the last-hank pointer remains
     at the same place in the kill ring, so repeating ~C-y~ will yank
     another copy of the same previous kill.
**** Appending Kills
     Normally, each kill command pushes a new entry onto the kill
     ring. However, two or more kill commands in a row combine their
     text into a single entry, so that a single ~C-y~ yanks all the
     text as a unit, just as it was before it was killed.

     Commands that kill forward from point add onto the end of the
     previous killed text. Commands that kill backward from point add
     text onto the beginning. This way, any sequence of mixed forward
     and backward kill commands puts all the killed text into one
     entry without rearrangement.

     If a kill command is separated from the last kill command by
     other commands (not just numeric arguments), it starts a new
     entry on the kill ring.

     A kill command following ~M-w~ (~kill-ring-save~) does not append
     to the text that ~M-w~ copied into the kill ring.
*** "Cut and Paste" Operations on Graphical Displays
    In most graphical desktop environments, you can transfer data
    (usually text) between different applications using a system
    facility called the /clipboard/. On X, two other similar
    facilities are available: the primary selection and the secondary
    selection. When Emacs is run on a graphical display, its kill and
    yank commands integrate with these facilities, so that you can
    easily transfer text between Emacs and other graphical
    applications.

    By default, Emacs uses UTF-8 as the coding system for
    inter-program text transfers. If you find that the pasted text is
    not what you expected, you can specify another coding system by
    typing ~C-x <RET> x~ or ~C-x <RET> X~.
**** Using the Clipboard
     The /clipboard/ is the facility that most graphical applications
     use for "cutting and pasting". When the clipboard exists, the
     kill and yank commands in Emacs make use of it.

     When you kill some text with a command such as ~C-w~
     (~kill-region~), or copy it to the kill ring with a command such
     as ~M-w~ (~kill-ring-save~), that text is also put in the
     clipboard.

     When an Emacs kill command puts text in the clipboard, the
     existing clipboard contents are normally lost.

     Yank commands, such as ~C-y~ (~yank~), also use the clipboard. If
     another application "owns" the clipboard - i.e., if you cut or
     copied text there more recently than your last kill command in
     Emacs - then Emacs yanks from the clipboard instead of the kill
     ring.

     Normally, rotating the kill ring with ~M-y~ (~yank-pop~) does not
     alter the clipboard.

     Many X desktop environments support a feature called the
     /clipboard manager/. If you exit Emacs while it is the current
     "owner" of the clipboard data, and there is a clipboard manager
     running, Emacs transfers the clipboard data to the clipboard
     manager so that it is not lost. In some circumstances, this may
     cause a delay when exiting Emacs.

     Since strings containing NUL bytes are usually truncated when
     passed through the clipboard, Emacs replaces such characters with
     "\0" before transferring them to the system's clipboard.

     Prior to Emacs 24, the kill and yank commands used the primary
     selection, not the clipboard. If you prefer this behavior, change
     ~select-enable-clipboard~ to ~nil~, ~select-enable-primary~ to
     ~t~, and ~mouse-drag-copy-region~ to ~t~. In this case, you can
     use the following commands to act explicitly on the clipboard:
     ~clipboard-kill-region~; ~clipboard-kill-ring-save~; and
     ~clipboard-yank~.
**** Cut and Paste with Other Window Applications
     Under the X Window System, there exists a /primary selection/
     containing the last stretch of text selected in an X application
     (usually by dragging the mouse). Typically, this text can be
     inserted into other X applications by ~mouse-2~ clicks. The
     primary selection is separate from the clipboard. Its contents
     are more fragile; they are overwritten each time you select text
     with the mouse, whereas the clipboard is only overwritten by
     explicit cut or copy commands.

     Under X, whenever the region is active, the text in the region is
     saved in the primary selection. This applies regardless of
     whether the region was made by dragging or clicking the mouse, or
     by keyboard commands.

     MS-Windows provides no primary selection, but Emacs emulates it
     within a single Emacs session by storing the selected text
     internally. Therefore, all the features and commands related to
     the primary selection work on Windows as they do on X, for
     cutting and pasting within the same session, but not across Emacs
     sessions or with other applications.
**** Secondary Selection
     In addition to the primary selection, the X Window System
     provides a second similar facility known as the /secondary
     selection/. Nowadays, few X applications make use of the
     secondary selection, but you can access it using the following
     Emacs commands:
     - ~mouse-set-secondary~
     - ~mouse-start-secondary~
     - ~mouse-secondary-save-then-kill~
     - ~mouse-yank-secondary~
*** Accumulating Text
*** Rectangles
    Rectangle commands operate on rectangular areas of the text: all
    the characters between a certain pair of columns, in a certain
    range of lines. Emacs has commands to kill rectangles, yank killed
    rectangles, clear them out, fill them with blanks or text, or
    delete them. Rectangle commands are useful with text in
    multi-column formats, and for changing text into or out of such
    formats.

    To specify a rectangle for a command to work on, set the mark at
    one corner and point at the opposite corner. The rectangle thus
    specified is called the /region-rectangle/. If point and the mark
    are in the same column, the region-rectangle is empty. If they are
    in the same line, the region-rectangle is one line high.

    The region-rectangle is controlled in much the same way as the
    region is controlled. But remember that a given combination of
    point and mark values can be interpreted either as a region or as
    a rectangle, depending on the command that uses them.

    Killing a rectangle is not killing in the usual sense; the
    rectangle is not stored in the kill ring, but in a special place
    that only records the most recent rectangle killed. This is
    because yanking a rectangle is so different from yanking linear
    text that different yank commands have to be used. Yank-popping is
    not defined for rectangles.

    When yanking a rectangle, the rectangle's first line is inserted
    at point, the rectangle's second line is inserted at the same
    horizontal position one line vertically below, and so on. The
    number of lines affected is determined by the height of the saved
    rectangle.
*** CUA Bindings
** Registers
   Vocabulary:
   - Register :: compartments were you can save test, rectangles,
     positions ans other things for later use.
   - Bookmark :: record files and positions in them

   Valid register names:
   - characters (case sensitive) :: a, b, A, C
   - digits :: 1, 2, 3
   - non-alphanumeric :: *, #, ?
   - single input event with multiple keystrokes :: C-d, M-v

   Invalid register names:
   - C-g
   - <ESC>

   Registers can store one thing at a time including but not limited
   to the following options:
   - position
   - piece of text
   - rectangle
   - number
   - window configuration
   - file name
*** Saving Positions in Registers
*** Saving Text in Registers
    When you want to insert a copy of the same piece of text several
    times, it may be inconvenient to yank it from the kill ring, since
    each subsequent kill moves that entry further down the ring. An
    alternative is to store the text in a register and later retrieve
    it.
*** Saving Rectangles in Registers
*** Saving Window Configurations in Registers
*** Keeping Numbers in Registers
    There are commands to store a number in a register, to insert the
    number in the buffer in decimal, and to increment it. These
    commands can be useful in keyboard macros.
*** Keeping File Names in Registers
*** Keyboard Macro Registers
    If you need to execute a keyboard macro frequently, it is more
    convenient to put it in a register or save it.
*** Bookmarks
    Vocabulary:
    - Bookmark :: Record a position you can jump to using long
      names. They persist automatically across Emacs
      sessions. Normally used to record where you left off reading in
      various files.

    When you kill Emacs, Emacs saves your bookmarks, if you have
    changed any bookmark values. Bookmarks are saved to the file
    '~/.emacs.d/bookmarks' (for compatibility with older versions of
    Emacs, if you have a file named '~/.emacs.bmk', that is used
    instead). The bookmark commands load your default bookmark file
    automatically. This saving and loading is how bookmarks persist
    from one Emacs session to the next.

    Bookmark position values are saved with surrounding context, so
    that ~bookmark-jump~ can find the proper position even if the file
    is modified slightly.
** Controlling the Display
*** Scrolling
    Scrolling forward or up advances the portion of the buffer
    displayed in the window; equivalently, it moves the buffer text
    upwards relative to the window. Scrolling backward or down
    displays an earlier portion of the buffer, and moves the text
    downwards relative to the window.

    In Emacs, scrolling up or down refers to the direction that the
    text moves in the window, /not/ the direction that the window
    moves relative to the text. This terminology was adopted by Emacs
    before the modern meaning of "scrolling up" and "scrolling down"
    became widespread. Hence the strange result that ~<PageDown>~
    scrolls up in the Emacs sense.

    The portion of a buffer displayed in a window always contains
    point. If you move point past the bottom or top of the window,
    scrolling occurs automatically to bring it back onscreen.
*** Recentering
    Some combinations of variables and commands can lead to clearing
    and redisplaying the screen. Redisplaying is useful in case the
    screen becomes garbled for any reason. Read the documentation for
    ~recenter-top-bottom~ and ~recenter-redisplay~ for more
    information.
*** Automatic Scrolling
    Emacs performs automatic scrolling when point moves out of the
    visible portion of the text. Normally, automatic scrolling centers
    point vertically in the window, but there are several ways to
    alter this behavior. Check out the documentation for the following
    variables:
    - ~scroll-conservatively~
    - ~scroll-step~
    - ~scroll-up-aggressively~ / ~scroll-down-aggressively~

    Note that these variables control automatic scrolling in
    contradictory ways. Therefore, you should pick no more than one of
    these methods to customize automatic scrolling. In case you
    customize multiple variables, the order of priority is in the same
    order listed above.
*** Horizontal Scrolling
    Horizontal scrolling means shifting all the lines sideways withing
    a window, so that some of the text near the left margin is not
    displayed.

    When the text in a window is scrolled horizontally, text lines are
    truncated rather than continued. If a window shows truncated
    lines, Emacs performs automatic horizontal scrolling whenever the
    point moves off the left or right edge of the screen.

    If you use the commands ~scroll-left~ and ~scroll-right~ to scroll
    a window horizontally, that sets a lower bound for automatic
    horizontal scrolling. Automatic scrolling will continue to scroll
    the window, but never farther to the right than the amount you
    previously set by ~scroll-left~. When ~auto-hscroll-mode~ is set
    to ~current-line~, all the lines other than the one showing the
    cursor will be scrolled by that minimal amount.
*** Narrowing
    *Narrowing* means focusing in on some portion of the buffer, making
    the rest temporarily inaccessible. The portion which you can still
    get to is called the accessible portion.

    Canceling the narrowing, which makes the entire buffer once again
    accessible, is called *widening*.

    The bounds of narrowing in effect in a buffer are called the
    buffer's *restriction*.

    When you have narrowed down to a part of the buffer, that part
    appears to be all there is. You can't see the rest, you can't move
    into it (motion commands won't go inside the accessible part), you
    can't change it in any way. However, it is not gone, and if you
    save the file all the inaccessible text will be saved. The word
    ~Narrow~ appears in the mode line whenever narrowing is in
    effect.

    You can get information on what part of the buffer you are
    narrowed down to using the command ~what-cursor-position~,
    normally: ~C-x =~.

    Because narrowing can easily confuse users who do not understand
    it, ~narrow-to-region~ is normally a disabled command. Attempting
    to use this command asks for confirmation and gives you the option
    of enabling it; if you enable the command, confirmation will no
    longer be required for it.
*** View Mode
*** Follow Mode
*** Text Faces
    Emacs can display text in several different styles, called
    faces. Each face can specify various face attributes, such as the
    font, height, weight, slant, foreground and background color, and
    underlining or overlining. Most major modes assign faces to the
    text automatically, via Font Lock mode.

    It's possible for a given face to look different in different
    frames. For instance, some text terminals do not support all face
    attributes, particularly font, height, and width, and some support
    a limited range of colors. In addition, most Emacs faces are
    defined so that their attributes are different on light and dark
    frame backgrounds, for reasons of legibility.

    You can customize a face to alter its attributes, and save those
    customizations for future Emacs sessions.

    The ~default~ face is the default for displaying text, and all of
    its attributes are specified. Its background color is also used as
    the frame's background color.

    Another special face is the ~cursor~ face. On graphical displays,
    the background color of this face is used to draw the the text
    color. None of the other attributes of this face have any effect;
    the foreground color for text under the cursor is taken from the
    background color of the underlying text. On text terminals, the
    appearance of the text cursor is determined by the terminal, not
    by the ~cursor~ face.

    You can also use X resources to specify attributes of any
    particular face.

    Emacs can display variable-width fonts, but some Emacs commands,
    particularly indentation commands, do not account for variable
    character display widths. Therefore, we recommend not using
    variable-width fonts for most faces, particularly those assigned
    by Font Lock mode.
*** Colors for Faces
    Faces can have various foreground and background colors. When you
    specify a color for a face you can use either a color name or an
    RGB triplet.

    A color name is a pre-defined name, such as ~dark orange~ or
    ~medium sea green~. These are standard X11 color names, defined in
    X's ~rgb.txt~ file. Emacs understands X11 color names even on text
    terminals; if a face is given a color specified by an X11 color
    name, it is displayed using the closest-matching terminal color.

    An RGB triplet is a string of the form ~#RRGGBB~. Each of the R,
    G, and B components is a hexadecimal number specifying the
    component's relative intensity, one to four digits long (usually
    two digits are used). The components must have the same number of
    digits. For hexadecimal values A to F, either upper or lower case
    are acceptable.
*** Standard Faces
*** Text Scale
*** Font Lock mode
    The easiest way to find all of the faces Font Lock mode uses to do
    it's job is to use ~M-x customize-group RET font-lock-faces
    RET~. You can then use that customization buffer to customize the
    appearance of these faces.

    Comment and string fontification (or "syntactic" fontification)
    relies on analysis of the syntactic structure of the buffer
    text. For the sake of speed, some modes, including Lisp mode, rely
    on a special convention: an open-parenthesis or open-brace in the
    leftmost column always defines the beginning of a defun, and is
    thus always outside any string or comment. Therefore, you should
    avoid placing an open-parenthesis or open-brace in the leftmost
    column, if it is inside a string or comment.

    Fontifying large buffers can take a long time. To avoid large
    delays when a file is visited, Emacs initially fontifies only the
    visible portion of a buffer. As you scroll through the buffer,
    each portion that becomes visible is fontified as soon as it is
    displayed; this type of Font Lock is called /Just-In-Time/ (or
    /JIT/) Lock. You can control how JIT Lock behaves, including
    telling it to perform fontification while idle, by customizing
    variables in the customization group '~jit-lock~'.
*** Interactive Highlighting
*** Window Fringes
    On graphical displays, each Emacs window normally has narrow
    /fringes/ on the left and right edges. The fringes are used to
    display symbols that provide information about the text in the
    window.

    Uses of fringes:
    - Continuation Lines (most common)
    - Line Truncation
    - Buffer boundaries
    - Unused lines near the end of the window
    - Where a program you are debugging is executing
    - Draw the cursor, if the current line is exactly as wide as the
      window and point is at the end of the line.

    If you customize the ~fringe-mode~ variable to remove the fringes
    on one or both sides of the window display, these are the only
    features still available:
    - Continuation Lines
    - Line Truncation

    This reduces the width available for displaying text on each line,
    because the character cells used for truncation and continuation
    indicators are reserved for that purpose. Since buffer text can
    include bidirectional text, and thus both left-to-right and
    right-to-left paragraphs, removing only one of the fringes still
    reserves two character cells, one on each side of the window, for
    truncation and continuation indicators, because these indicators
    are displayed on opposite sides of the window in right-to-left
    paragraphs.
*** Displaying Boundaries
    Emacs can add an indicator to display a fill column position. The
    fill column indicator is a useful functionality especially in
    ~prog-mode~ to indicate the position of a specific column.
*** Useless Whitespace
*** Selective Display
*** Optional Mode Line Features
    If you have narrowed the buffer, the displayed line number is
    relative to the accessible portion of the buffer. Thus, it isn't
    suitable as an argument to ~goto-line~. (Use ~what-line~ command
    to see the line number relative to the whole file.)

    On graphical displays, the mode line is drawn as a 3D box. If you
    don't like this effect, you can disable it by customizing the
    ~mode-line~ face and setting its ~box~ attribute to ~nil~.

    By default, the mode line of nonselected windows is displayed in a
    different face, called ~mode-line-inactive~. Only the selected
    window is displayed in the ~mode-line~ face. This helps show which
    window is selected. When the minibuffer is selected, since it has
    no mode line, the window from which you activated the minibuffer
    has its mode line displayed using ~mode-line~; as a result,
    ordinary entry to the minibuffer does not change any mode lines.

    You can customize the mode line display for each of the
    end-of-line formats by setting each of the variables
    ~eol-mnemonic-unix~, ~eol-mnemonic-mac~, and
    ~eol-mnemonic-undecided~ to the strings you prefer.
*** How Text Is Displayed
    There are two types of characters:
    - printing characters
    - control characters

    Most characters are /printing characters/: when they appear in a
    buffer, they are displayed literally on the screen. Printing
    characters include ASCII numbers, letters, and punctuation
    characters, as well as many non-ASCII characters.

    There are some printable characters that may be displayed in a
    special way. They are:
    - Characters that have the same appearance as an ASCII space
    - Characters that have the same appearance as an ASCII hyphen
    - English quotation marks and all variants
    - Characters with no glyphs in any available fonts

    Such characters can cause problems if they are entered into a
    buffer without your realization, e.g. by yanking; for instance,
    source code compilers typically do not treat non-ASCII spaces as
    whitespace characters. To deal with this problem, Emacs displays
    such characters specially: it displays ~U+00A0~ (no-break space)
    with the ~nobreak-space~ face, and it displays ~U+00AD~ (soft
    hyphen), ~U+2010~ (hyphen), and ~U+2011~ (non-breaking hyphen)
    with the ~nobreak-hyphen~ face.

    Emacs tries to determine if the curved quotes '~‘~' and '~’~' can
    be displayed on the current display. By default, if this seems to
    be so, then Emacs will translate the ASCII quotes ('~`~' and
    '~'~'), when they appear in messages and help texts, to these
    curved quotes.

    If the curved quotes ~‘~, ~’~, ~“~, and ~”~ are known to look just
    like ASCII characters, they are shown with the ~homoglyph~
    face. Curved quotes that are known not to be displayable are shown
    as their ASCII approximations ~`~ and ~'~ and ~"~ with the
    ~homoglyph~ face.

    On graphical displays, some characters may have no glyphs in any
    of the fonts available to Emacs. These /glyphless characters/ are
    normally displayed as boxes containing the hexadecimal character
    code. Similarly, on text terminals, characters that cannot be
    displayed using the terminal encoding are normally displayed as
    question signs.

    Control characters are displayed in many different ways. Here are
    some different types of control characters and how they are
    displayed.
    - newline character
    - tab character
    - Other ASCII low code (under ~U+0020~)
    - Bytes with codes ~U+0080~ through ~U+009F~

    The ASCII character set contains non-printing /control
    characters/. Two of these are displayed specially: the newline
    character (Unicode code point ~U+000A~) is displayed by starting a
    new line, while the tab character (~U+0009~) is displayed as a
    space that extends to the next tab stop column (normally every 8
    columns). Note that the way the tab character in the buffer is
    displayed has nothing to do with the definition of ~TAB~ as a
    command.

    Other ASCII control characters, whose codes are below ~U+0020~
    (octal 40, decimal 32), are displayed as a caret ('~^~') followed
    by the non-control version of the character, with the
    ~escape-glyph~ face. For instance, the '~control-A~' character,
    ~U+0001~, is displayed as '~^A~'.

    The raw bytes with codes ~U+0080~ (octal 200) through ~U+009F~
    (octal 237) are displayed as /octal escape sequences/, with the
    ~escape-glyph~ face. For instance, character code ~U+0098~
    (octal 230) is displayed as '~\230~'.

    You can customize the way any particular character code is
    displayed by means of a display table.
* Vocabulary
** Basics
*** Frame
    [[The Organization of the Screen][First Defined]]
*** Menu Bar
    [[The Organization of the Screen][First Defined]]
*** Tool Bar
    [[The Organization of the Screen][First Defined]]
*** Echo Area
    [[The Organization of the Screen][First Defined]]
    [[The Echo Area][Details]]
*** Window
    [[The Organization of the Screen][First Defined]]
*** Buffer
    [[The Organization of the Screen][First Defined]]
*** Mode Line
    [[The Organization of the Screen][First Defined]]
    [[The Mode Line][Details]]
*** Point
    [[Point][first Defined]]
*** Major Mode
    [[The Mode Line][First Defined]]
*** Minor Mode
    [[The Mode Line][First Defined]]
*** Variable
    [[The Menu Bar][first mentioned]]
    [[Keys and Commands][First Defined]]
** Keys
*** Key Sequence
    [[Keys][First Defined]]
*** Complete Key
    [[Keys][First Defined]]
*** Prefix Key
    [[Keys][First Defined]]
** Minibuffer
*** Minibuffer
    [[The Echo Area][First Defined]]
*** Completion
    [[Completion][First Defined]]
*** Command History
    [[Repeating Minibuffer Commands][First Defined]]
** The Mark and the Region
*** Mark
    [[The Mark and the Region][First Defined]]
*** Region
    [[The Mark and the Region][First Defined]]
*** Shift Selection
    [[Setting the Mark][First Defined]]
    [[Shift Selection][Fully Defined]]
*** Mark Ring
    [[Entering Emacs][first mentioned]]
    [[The Mark Ring][First Defined]]
** Killing and Moving Text
*** Kill
    [[Killing and Moving Text][First Defined]]
*** Yank
    [[Killing and Moving Text][First Defined]]
    [[Yanking][Fully Defined]]
*** Kill Ring
    [[Entering Emacs][first mentioned]]
    [[Killing and Moving Text][First Defined]]
*** Clipboard
    [["Cut and Paste" Operations on Graphical Displays][first mentioned]]
    [[Using the Clipboard][First Defined]]
*** Primary Selection
    [["Cut and Paste" Operations on Graphical Displays][first mentioned]]
    [[Cut and Paste with Other Window Applications][First Defined]]
** Registers
*** Register
    [[Entering Emacs][first mentioned]]
    [[Registers][First Defined]]
*** Bookmark
    [[Registers][first mentioned]]
    [[Bookmarks][First Defined]]
** Controlling the Display
*** Horizontal Scrolling
    [[Horizontal Scrolling][First Defined]]
*** Narrowing
    [[The Mode Line][First Defined]]
    [[Narrowing][Fully Defined]]
*** Widening
    [[Narrowing][First Defined]]
*** Buffer Restriction
    [[Narrowing][First Defined]]
*** Faces
    [[Help Mode Commands][first mentioned]]
    [[Text Faces][First Defined]]
*** Fringes
    [[Continuation Lines][first mentioned]]
    [[Window Fringes][First Defined]]
*** Printing Characters
    [[How Text Is Displayed][First Defined]]
*** Control Characters
    [[How Text Is Displayed][First Defined]]
*** Glyphless Characters
    [[How Text Is Displayed][First Defined]]
** Uncategorized
*** Keyboard Macro
    [[The Mode Line][first mentioned]]
*** Recursive Edit
    [[The Mode Line][first mentioned]]
*** Tooltips
    [[The Mode Line][first mentioned]]
*** Function
    [[Keys and Commands][first mentioned]]
*** Keymaps
    [[Keys and Commands][first mentioned]]
*** Undo History
    [[Entering Emacs][first mentioned]]
*** Primary Selection
    [[Setting the Mark][first mentioned]]
*** Defun
    [[Commands to Mark Textual Objects][first mentioned]]
*** Pages
    [[Commands to Mark Textual Objects][first mentioned]]
* Mode
** The Organization of the Screen
*** Size Indication mode
    you can display the size of the buffer in the Mode Line

    [[The Mode Line][first mention]]
*** Column Number mode
    You can display the current column in the Mode Line

    [[The Mode Line][first mention]]
** Basic Editing Commands
*** Auto Fill mode
    Splits lines automatically when they get too long

    [[Inserting Text][first mention]]
*** Overwrite mode
    Causes inserted characters to replace (overwrite) existing text,
    instead of shoving it to the right.

    [[Inserting Text][first mentioned]]
*** Visual Line mode
    Enables word wrapping: instead of wrapping long lines exactly at
    the right window edge, Emacs wraps them at the word boundaries
    (i.e., space or tab characters) nearest to the right window
    edge. Visual Line mode also redefines editing commands such as
    C-a, C-n, and C-k to operate on screen lines rather than logical
    lines.
*** Line Number mode
    The current line number of point appears in the mode line when
    this mode is enabled.
*** Column Number mode
    Display the current column number in the mode line.
*** HL Line mode
    Highlights the line containing point.
** The Minibuffer
*** Minibuffer Electric Default mode
    Emacs hides the default argument as soon as you modify the
    contents of the minibuffer.
*** File Name Shadow mode
    The ignored part of the file name is dimmed if the terminal allows
    it. And to disable this dimming disable this mode.
*** Minibuffer Inactive mode
    When the minibuffer is not active in the Echo Area, then that is a
    particular mode that has hooks etc.
** Help
*** Help Mode
    Help buffers provide the same commands as View mode (not yet
    defined). Help buffers normally provide a definition, a list of
    commands or symbols. Not as heavily formatted as documentation,
    but still provides very helpful insight.
** The Mark and the Region
*** Transient Mark mode
    When a region is active, Emacs indicates its extent by
    highlighting the text within it. After certain non-motion
    commands, including any command that changes the text in the
    buffer, Emacs automatically deactivates the mark; this turns off
    the highlighting.
*** Delete Selection mode
    By default, text insertion occurs normally even if the mark is
    active - for example, typing ~a~ inserts the character 'a', then
    deactivates the mark. Delete Selection mode, a minor mode,
    modifies this behavior: if you enable this mode, then inserting
    text while the mark is active causes the text in the region to be
    deleted first.
*** Shift Select mode
    Minor mode specifying that shift selection is allowed. Set
    corresponding variable to ~nil~ to turn off shift-selection
** Killing and Moving Text
*** Rectangle Mark mode
    When this mode is enabled, commands that resize the region do so
    in a rectangular fashion, and killing and yanking operate on the
    rectangle. The mode persists only as long as the region is
    active.
*** CUA mode
    Sets up key bindings that are compatible with the Common User
    Access (CUA) system used in many other applications.

    When CUA mode is enabled, they keys ~C-x~, ~C-c~, ~C-v~, and ~C-z~
    invoke commands that cut (kill), copy, paste (yank), and undo
    respectively. The ~C-x~ and ~C-c~ keys perform cut and copy only
    if the region is active. Otherwise, they still act as prefix keys,
    so that standard Emacs commands like ~C-x C-c~ still work.

    To enter an Emacs command like ~C-x C-f~ while the mark is active,
    use one of the following methods: either hold ~<Shift>~ together
    with the prefix key, e.g., ~S-C-x C-f~, or quickly type the prefix
    key twice, e.g., ~C-x C-x C-f~.

    this mode by default activates Delete-Selection mode so that typed
    text replaces the active region.

    This mode provides enhanced rectangle support with visible
    rectangle highlighting. Use ~C-<RET>~ to start a rectangle, extend
    it using the movement commands, and cut or copy it using ~C-x~ or
    ~C-c~. ~<RET>~ moves the cursor to the next (clockwise) corner of
    the rectangle, so you can easily expand it in any
    direction. Normal text you type is inserted to the left or right
    of each line in the rectangle (on the same side as the cursor).

    With CUA you can easily copy text and rectangles into and out of
    registers by providing a one-digit numeric prefix to the kill,
    copy, and yank commands, e.g., ~C-1 C-c~ copies the region into
    register 1, and ~C-2 C-v~ yanks the contents of register 2.

    This mode also has a global mark feature which allows easy moving
    and copying of text between buffers. Use ~C-S-<SPC>~ to toggle the
    global mark on and off. When the global mark is on, all text that
    you kill or copy is automatically inserted at the global mark, and
    text you type is inserted at the global mark rather than at the
    current position.
*** CUA Rectangle Mark mode
    Uses the same rectangle support as the CUA mode without needing to
    enable CUA mode.

    Use ~C-<RET>~ to start a rectangle, extend it using the movement
    commands. <RET> moves the cursor to the next (clockwise) corner of
    the rectangle, so you can easily expand it in any
    direction. Normal text you type is inserted to the left or right
    of each line in the rectangle (on the same side as the cursor).
** Controlling the Display
*** View mode
    View mode is a minor mode that lets you scan a buffer by
    sequential screenfuls. It provides commands for scrolling through
    the buffer conveniently but not for changing it. Apart from the
    usual Emacs cursor motion commands, you can type ~<SPC>~ to scroll
    forward one window, ~S-<SPC>~ or ~<DEL>~ to scroll backward, and
    ~s~ to start an incremental search.
*** Follow mode
    Follow mode is a minor mode that makes two windows, both showing
    the same buffer, scroll as a single tall virtual window. To use
    Follow mode, go to a frame with just one window, split it into two
    side-by-side windows using ~split-window-right~ usually ~C-x 3~,
    and then use the command ~follow-mode~. From then on, you can edit
    the buffer in either of the two windows, or scroll either one; the
    other window follows it.

    In Follow mode, if you move point outside the portion visible in
    one window and into the portion visible in the other window, that
    selects the other window - again, treating the two as if they were
    parts of one large window.
*** Text Scale mode
    Absolutely unclear what the heck this mode is
*** Font Lock mode
    Font Lock mode is a minor mode, always local to a particular
    buffer, which assigns faces to (or fontifies) the text in the
    buffer. Each buffer's major mode tells Font Lock mode which text
    to fontify; for instance, programming language modes fontify
    syntactically relevant constructs like comments, strings, and
    function names.

    Font Lock mode is enabled by default in major modes that support
    it.
*** Highlight Changes mode
    Highlight Changes mode is a minor mode that /highlights/ the parts
    of the buffer that were changed most recently, by giving that text
    a different face.
*** Hi Lock mode
    Hi Lock mode is a minor mode that highlights text that matches
    regular expressions you specify. For example, you can use it to
    highlight all the references to a certain variable in a program
    source file, highlight certain parts in a voluminous output of
    some program, or highlight certain names in an article.
*** Fringe mode
    Display fringes on left and right edges of each Emacs window.
*** Whitespace mode
    Whitespace mode is a buffer-local minor mode that lets you
    visualize many kinds of whitespace in the buffer, by either
    drawing the whitespace characters with a special face or
    displaying them as special glyphs.
*** Global Whitespace mode
    A global minor mode that lets you visualize whitespace in all
    buffers.
*** Size Indication mode
    The buffer percentage /pos/ indicates the percentage of the buffer
    above the top of the window. You can additionally display the size
    of the buffer by turning on this mode. The size will be displayed
    immediately following the buffer percentage like this:
    #+BEGIN_SRC emacs-lisp
    pos of size
    #+END_SRC

    Here /size/ is the human readable representation of the number of
    characters in the buffer, which means that '~k~' for 10^3, '~M~'
    for 10^6, '~G~' for 10^9, etc., are used to abbreviate.
*** Line Number mode
    The current line number of point appears in the mode line when
    this mode is enabled. The line number appears after the buffer
    percentage /pos/, with the letter '~L~' to indicate what it
    is. However, when both this mode and Column Number mode are
    enabled, the line and column numbers are displayed in parentheses,
    the line number first, rather than with '~L~' and '~C~'. For
    example '~(561, 2)~'.
*** Column Number mode
    You can display the current column number by turning on Column
    Number mode. The column number is indicated by the letter
    '~C~'. However, when both this mode and Line Number mode are
    enabled, the line and column numbers are displayed in parentheses,
    the line number first, rather than with '~L~' and '~C~'. For
    example '~(561, 2)~'.

    In this mode, the displayed column number counts from zero
    starting at the left margin of the window.
*** Display Time mode
    Emacs can optionally display the time and system load in all mode
    lines. This minor mode is the mode that accomplishes this. The
    information added to the mode line looks like this:

    #+BEGIN_SRC
    hh:mmPM l.ll
    #+END_SRC

    Here /hh/ and /mm/ are the hour and minute, followed always be
    '~AM~' or '~PM~'. /l.ll/ is the average number, collected for the
    last few minutes, of processes in the whole system that were
    either running or ready to run (i.e., were waiting for an
    available processor). (Some fields may be missing if your
    operating system cannot support them.)

    If you prefer time displays in 24-hour format, set the variable
    ~display-time-24hr-format~ to ~t~.

    The word '~Mail~' appears after the load level if there is mail
    for you that you have not read yet. On graphical displays, you can
    use an icon instead of '~Mail~' by customizing
    ~display-time-use-mail-icon~; this may save some space on the mode
    line. You can customize ~display-time-mail-face~ to make the mail
    indicator prominent. Use ~display-time-mail-file~ to specify the
    mail file to check, or set ~display-time-mail-directory~ to
    specify the directory to check for incoming mail (any nonempty
    regular file in the directory is considered to be newly arrived
    mail).
*** Display Battery mode
    When running Emacs on a laptop computer, you can display the
    battery charge on the mode-line using this mode.
* Command
** The Organization of the Screen
*** what-cursor-position                                   :inform:char:echo:
    :PROPERTIES:
    :Command:  C-x =
    :Description: Display char code, position, column of character after point
    :Context:  navigating
    :END:
*** keyboard-quit                                              :undo:command:
    :PROPERTIES:
    :Command:  C-g
    :Description: Quit: Cancel running or partially typed command
    :Context:  anywhere
    :END:
*** menu-bar-open                                                      :menu:
    :PROPERTIES:
    :Command:  <F10>
    :Description: Invoke first menu bar item.
    :Context:  anywhere
    :END:
*** tmm-menubar                                                        :menu:
    :PROPERTIES:
    :Command:  M-`
    :Description: Select a menu item with the keyboard
    :Context:  anywhere
    :END:
** Keys
*** Prefix Help Man                                :inform:helps:keys:window:
    :PROPERTIES:
    :Command:  <Prefix> C-h OR <Prefix> <F1>
    :Description: Displays a list of the commands starting with that prefix
    :Context:  anywhere
    :END:
    There is one exception. The key ~<ESC> C-h~ is equivalent to
    ~C-M-h~ which is a different command. To list the commands that
    start with <ESC> one should instead use the key ~<ESC> <F1>~.
** Entering Emacs
*** help-with-tutorial                                         :helps:buffer:
    :PROPERTIES:
    :Command:  C-h t
    :Description: Open the Emacs tutorial
    :Context:  anywhere
    :END:
** Exiting Emacs
*** save-buffers-kill-terminal                                   :kill:frame:
    :PROPERTIES:
    :Command:  C-x C-c
    :Description: Kill Emacs
    :Context:  anywhere
    :END:
*** suspend-frame                                                     :frame:
    :PROPERTIES:
    :Command:  C-z
    :Description: Minimize GUI, suspend terminal Emacs
    :Context:  anywhere
    :END:
*** kill-emacs                                                   :kill:frame:
    :PROPERTIES:
    :Description: Kill Emacs without being prompted about saving
    :Context:  anywhere
    :END:
** Basic Editing Commands
*** newline                                                       :edit:char:
    :PROPERTIES:
    :Command:  <RET>
    :Description: End a line and start a new one
    :Context:  editing
    :END:
    The binding of this and ~newline-and-indent~ may be swapped
*** newline-and-indent                                            :edit:char:
    :PROPERTIES:
    :Command:  C-j
    :Description: insert newline then indent according to mode
    :Context:  editing
    :END:
    The binding of this and ~newline~ may be swapped
*** quoted-insert                                                 :edit:char:
    :PROPERTIES:
    :Command:  C-q
    :Description: Insert a non-graphic character
    :Context:  editing
    :Argument: numeric
    :END:
    There are two ways to use ~quoted-insert~.
    - ~C-q~ followed by any non-graphic character inserts that
      character
    - ~C-q~ followed by a sequence of octal digits inserts the
      character with the specified octal character code.
    A numeric argument specifies how many copies of the character to
    insert.
*** Insert Char Help Man                      :inform:helps:edit:char:window:
    :PROPERTIES:
    :Command:  C-x 8 C-h
    :Description: Show list of possible characters to insert
    :Context:  navigating
    :END:
    There are a lot of helpful characters one can insert. Check this
    out.
*** insert-char                                                   :edit:char:
    :PROPERTIES:
    :Command:  C-x 8 <RET>
    :Description: Prompts for Unicode name or code-point and inserts
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument specifies how many copies of the character to
    insert.
*** forward-char                                                   :nav:char:
    :PROPERTIES:
    :Command:  C-f
    :Description: Move forward one character
    :Context:  navigating
    :END:
*** right-char                                                     :nav:char:
    :PROPERTIES:
    :Command:  <RIGHT>
    :Description: Move right one character
    :Context:  navigating
    :END:
*** backward-char                                                  :nav:char:
    :PROPERTIES:
    :Command:  C-b
    :Description: Move backward one character
    :Context:  navigating
    :END:
*** left-char                                                      :nav:char:
    :PROPERTIES:
    :Command:  <LEFT>
    :Description: Move left one character
    :Context:  navigating
    :END:
*** next-line                                                      :nav:line:
    :PROPERTIES:
    :Command:  C-n OR <DOWN>
    :Description: Move down one screen line
    :Context:  navigating
    :END:
*** previous-line                                                  :nav:line:
    :PROPERTIES:
    :Command:  C-p OR <UP>
    :Description: Move up one screen line
    :Context:  navigating
    :END:
*** move-beginning-of-line                                         :nav:line:
    :PROPERTIES:
    :Command:  C-a OR <Home>
    :Description: Move to the beginning of the line
    :Context:  navigating
    :END:
*** move-end-of-line                                               :nav:line:
    :PROPERTIES:
    :Command:  C-e OR <End>
    :Description: Move to the end of the line
    :Context:  navigating
    :END:
*** forward-word                                                   :nav:word:
    :PROPERTIES:
    :Command:  M-f
    :Description: Move forward one word
    :Context:  navigating
    :END:
*** right-word                                                     :nav:word:
    :PROPERTIES:
    :Command:  C-<RIGHT> OR M-<RIGHT>
    :Description: Move right one word
    :Context:  navigating
    :END:
*** backward-word                                                  :nav:word:
    :PROPERTIES:
    :Command:  M-b
    :Description: Move backward one word
    :Context:  navigating
    :END:
*** left-word                                                      :nav:word:
    :PROPERTIES:
    :Command:  C-<LEFT> OR M-<LEFT>
    :Description: Move left one word
    :Context:  navigating
    :END:
*** move-to-window-line-top-bottom                               :nav:window:
    :PROPERTIES:
    :Command:  M-r
    :Description: Move point to left margin center, top, bottom
    :Context:  navigating
    :Argument: numeric
    :END:
    A numeric argument says which screen line to place point on,
    counting downward from the top of the window (zero means the top
    line). A negative argument counts lines up from the bottom (-1
    means the bottom line).
*** beginning-of-buffer                                          :nav:buffer:
    :PROPERTIES:
    :Command:  M-< OR C-<HOME>
    :Description: Move to the top of the buffer
    :Context:  navigating
    :Argument: numeric
    :END:
    With numeric argument n, move to n/10 of the way from the top.
*** end-of-buffer                                                :nav:buffer:
    :PROPERTIES:
    :Command:  M-> OR C-<END>
    :Description: Move to the end of the buffer
    :Context:  navigating
    :END:
*** scroll-up-command                                            :nav:buffer:
    :PROPERTIES:
    :Command:  C-v OR <PageDown> OR <next>
    :Description: Scroll the display one screen forward
    :Context:  navigating
    :Argument: numeric
    :END:
    With a numeric argument, /n/, you scroll by /n/ lines; Emacs
    attempts to leave point unchanged, so that the text and point move
    up or down together. With a negative argument this behaves like
    ~scroll-down-command~.
*** scroll-down-command                                          :nav:buffer:
    :PROPERTIES:
    :Command:  M-v OR <PageUp> OR <prior>
    :Description: Scroll one screen backward
    :Context:  navigating
    :Argument: numeric
    :END:
    With a numeric argument, /n/, you scroll by /n/ lines; Emacs
    attempts to leave point unchanged, so that the text and point move
    up or down together. With a negative argument this behaves like
    ~scroll-down-command~.
*** goto-char                                                    :nav:buffer:
    :PROPERTIES:
    :Command:  M-g c
    :Description: Go to 1 indexed character in buffer
    :Context:  navigating
    :END:
*** goto-line                                                    :nav:buffer:
    :PROPERTIES:
    :Command:  M-g M-g OR M-g g
    :Description: Goto 1 indexed line number
    :Context:  navigating
    :Argument: numeric, plain
    :END:
    You can specify line number by giving command a numeric prefix
    argument. Plain prefix not yet defined.
*** move-to-column                                                 :nav:line:
    :PROPERTIES:
    :Command:  M-g <TAB>
    :Description: Move to 0 indexed column
    :Context:  navigating
    :Argument: numeric
    :END:
    If called with a prefix argument, move to the column number
    specified by the argument's numeric value.
*** set-goal-column                                              :nav:window:
    :PROPERTIES:
    :Command:  C-x C-n
    :Description: Use current column as semi-permanent goal column
    :Context:  navigating
    :Argument: plain
    :END:
    With a plain prefix argument cancels the goal column
*** delete-backward-char                            :delete:char:edit:region:
    :PROPERTIES:
    :Command:  <DEL> OR <BACKSPACE>
    :Description: Delete character before point, or region if active
    :Context:  editing
    :Argument: numeric
    :END:
    If you supply a numeric argument /n/, this commands delete /n/
    characters.
*** delete-forward-char                             :delete:char:edit:region:
    :PROPERTIES:
    :Command:  <Delete>
    :Description: Delete character after point, or region if active
    :Context:  editing
    :Argument: numeric
    :END:
    If you supply a numeric argument /n/, this commands delete /n/
    characters.
*** delete-char                                            :delete:char:edit:
    :PROPERTIES:
    :Command:  C-d
    :Description: Delete the character after point
    :Context:  editing
    :END:
*** kill-line                                         :kill:line:edit:delete:
    :PROPERTIES:
    :Command:  C-k
    :Description: Kill to the end of the line
    :Context:  editing
    :Argument: numeric
    :END:
    If used at the end of a line, it kills the line-ending newline
    character, merging the next line into the current one (thus, a
    blank line is entirely removed). Otherwise, this command kills all
    the text from the point up to the end of the line; if point was
    originally at the beginning of the line, this leaves the line
    blank.

    Spaces and tabs at the end of the line are ignored when deciding
    which case applies. As long as point is after the last
    non-whitespace character in the line, you can be sure that ~C-k~
    will kill the newline. To kill an entire non-blank line, go to the
    beginning and type ~C-k~ twice.

    When ~C-k~ is given a positive argument /n/, it kills /n/ lines
    and the newlines that follow them (text on the current line before
    point is not killed). With a negative /-n/, it kills /n/ lines
    preceding the current line, together with the text on the current
    line before point. C-k with an argument of zero kills the text
    before the point on the current line.
*** kill-word                                         :kill:word:edit:delete:
    :PROPERTIES:
    :Command:  M-d
    :Description: Kill forward to the end of the next word
    :Context:  editing
    :END:
*** backward-kill-word                                :kill:word:edit:delete:
    :PROPERTIES:
    :Command:  M-<DEL> OR M-<BACKSPACE>
    :Description: Kill back to the beginning of the previous word
    :Context:  editing
    :END:
*** undo                                                   :undo:edit:buffer:
    :PROPERTIES:
    :Command:  C-/ OR C-x u OR C-_
    :Description: Undo one entry of the undo records
    :Context:  editing
    :Argument: plain
    :END:
    When not in Transient Mark mode, using a plain argument limits
    undo to changes within the current region.
*** find-file                                                  :files:buffer:
    :PROPERTIES:
    :Command:  C-x C-f
    :Description: Copy file into buffer
    :Context:  anywhere
    :END:
*** save-buffer                                                :files:buffer:
    :PROPERTIES:
    :Command:  C-x C-s
    :Description: Save current buffer into associated file
    :Context:  editing
    :END:
*** describe-key                                        :helps:window:inform:
    :PROPERTIES:
    :Command:  C-h k
    :Description: find out what a key does
    :Context:  anywhere
    :END:
*** open-line                                                     :edit:line:
    :PROPERTIES:
    :Command:  C-o
    :Description: Insert a blank line after the cursor
    :Context:  editing
    :Argument: numeric
    :END:
    With a numeric argument you can make several blank lines.
*** delete-blank-lines                                   :edit:buffer:delete:
    :PROPERTIES:
    :Command:  C-x C-o
    :Description: Delete all but one of many consecutive blank lines
    :Context:  editing
    :END:
*** what-line                                                   :inform:echo:
    :PROPERTIES:
    :Description: Display the line number of point
    :Context:  navigating
    :END:
*** line-number-mode                                     :inform:buffer:mode:
    :PROPERTIES:
    :Description: Toggle automatic display of current line number
    :Context:  navigating
    :END:
*** column-number-mode                                     :inform:line:mode:
    :PROPERTIES:
    :Description: Toggle automatic display of current column number
    :Context:  navigating
    :END:
*** count-words-region                                   :inform:region:echo:
    :PROPERTIES:
    :Command:  M-=
    :Description: Display the number of lines, words, chars in region
    :Context:  navigating
    :END:
*** count-words                                          :inform:echo:region:
    :PROPERTIES:
    :Command:  C-u M-=
    :Description: Display number of lines, words, and chars in buffer or region
    :Context:  navigating
    :END:
*** what-cursor-position                              :inform:char:echo:line:
    :PROPERTIES:
    :Command:  C-x =
    :Description: Display code char, position, and column of point
    :Context:  navigating
    :END:
*** hl-line-mode                                          :mode:display:line:
    :PROPERTIES:
    :Description: Toggle highlighting of the current line
    :Context:  navigating
    :END:
*** size-indication-mode                                 :mode:inform:buffer:
    :PROPERTIES:
    :Description: Toggle automatic display of size of buffer
    :Context:  navigating
    :END:
*** display-line-numbers-mode                    :display:window:mode:inform:
    :PROPERTIES:
    :Description: Toggle displaying line numbers for every line in buffer
    :Context:  navigating
    :END:
*** digit-argument                                                     :keys:
    :PROPERTIES:
    :Command:  M-[0-9]
    :Description: Compile numeric argument for next command
    :Context:  anywhere
    :END:
*** negative-argument                                                  :keys:
    :PROPERTIES:
    :Command:  M--
    :Description: Compile negative numeric argument for next command
    :Context:  anywhere
    :END:
*** universal-argument                                                 :keys:
    :PROPERTIES:
    :Command:  C-u
    :Description: start numeric, plain, double argument
    :Context:  anywhere
    :END:
*** repeat                                                             :keys:
    :PROPERTIES:
    :Command:  C-x z
    :Description: repeat the previous Emacs command.
    :Context:  anywhere
    :END:
** The Minibuffer
*** minibuffer-electric-default-mode               :buffer:display:echo:mode:
    :PROPERTIES:
    :Description: Toggle Minibuffer Electric Default mode
    :Context:  anywhere
    :END:
*** file-name-shadow-mode                          :buffer:display:echo:mode:
    :PROPERTIES:
    :Description: Toggle File Name Shadow mode
    :Context:  anywhere
    :END:
*** minibuffer-complete                                 :buffer:command:echo:
    :PROPERTIES:
    :Command:  <TAB>
    :Description: Complete the text in the minibuffer as much as possible
    :Context:  minibuffer
    :END:
    If unable to complete, display a list of possible completions
*** minibuffer-complete-word                            :buffer:command:echo:
    :PROPERTIES:
    :Command:  <SPC>
    :Description: Complete up to one word from the minibuffer text before point
    :Context:  minibuffer
    :END:
    This command is not available for arguments that often include
    spaces, such as file names.
*** minibuffer-complete-and-exit                        :buffer:command:echo:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Submit minibuffer argument
    :Context:  minibuffer
    :END:
*** minibuffer-completion-help            :buffer:command:inform:window:echo:
    :PROPERTIES:
    :Command:  ?
    :Description: Display a list of completions
    :Context:  minibuffer
    :END:
*** switch-to-completions                    :buffer:command:window:nav:echo:
    :PROPERTIES:
    :Command:  M-v OR <PageUp> OR <prior>
    :Description: Selects the window showing the completion list
    :Context:  minibuffer
    :END:
*** choose-completion                            :window:command:buffer:echo:
    :PROPERTIES:
    :Command:  <RET> OR mouse-1 OR mouse-2
    :Description: Chooses the completion at point
    :Context:  completion-buffer
    :END:
*** next-completion                                      :buffer:command:nav:
    :PROPERTIES:
    :Command:  <RIGHT>
    :Description: This moves point to the following completion alternative
    :Context:  completion-buffer
    :END:
*** previous-completion                                  :buffer:command:nav:
    :PROPERTIES:
    :Command:  <LEFT>
    :Description: This moves point to the previous completion alternative
    :Context:  completion-buffer
    :END:
*** previous-history-element                          :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-p
    :Description: Move to the previous item in the minibuffer history
    :Context:  minibuffer
    :END:
*** next-history-element                              :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-n
    :Description: Move to the next item in the minibuffer history
    :Context:  minibuffer
    :END:
    If you use this command in the minibuffer when there are no later
    entries in the minibuffer history (e.g., if you haven't previously
    typed M-p), Emacs tries fetching from a list of default arguments:
    values that you are likely to enter. You can think of this as
    moving through the "future history".
*** previous-line-or-history-element              :buffer:line:nav:hist:echo:
    :PROPERTIES:
    :Command:  <UP>
    :Description: Move previous line if exists, else previous minibuffer item
    :Context:  minibuffer
    :END:
*** next-line-or-history-element                  :buffer:line:nav:hist:echo:
    :PROPERTIES:
    :Command:  <DOWN>
    :Description: Move next line if exists, else move next minibuffer item
    :Context:  minibuffer
    :END:
*** previous-matching-history-element                 :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-r
    :Description: Move earlier minibuffer item that matches regexp
    :Context:  minibuffer
    :Argument: numeric
    :END:
    A numeric prefix argument /n/ means to fetch the /n/-th matching
    entry.
*** next-matching-history-element                     :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-s
    :Description: Move later minibuffer item that matches regexp
    :Context:  minibuffer
    :Argument: numeric
    :END:
    A numeric prefix argument /n/ means to fetch the /n/-th matching
    entry.
*** repeat-complex-command                                     :command:hist:
    :PROPERTIES:
    :Command:  C-x <ESC> <ESC>
    :Description: Re-execute a recent minibuffer command from Command History
    :Context:  anywhere
    :Argument: numeric
    :END:
    With no argument, it repeats the last such command. A numeric
    argument specifies which command to repeat; 1 means the last one,
    2 the previous, and so on.
*** list-command-history                         :window:command:inform:hist:
    :PROPERTIES:
    :Description: Display command history
    :Context:  anywhere
    :END:
*** Password Delete Backwards Char                  :buffer:char:delete:echo:
    :PROPERTIES:
    :Command:  <DEL>
    :Description: Removes last character entered
    :Context:  password
    :END:
*** Password Delete All                             :buffer:delete:line:echo:
    :PROPERTIES:
    :Command:  C-u
    :Description: Deletes everything you have typed so far
    :Context:  password
    :END:
*** Password Quit                                          :undo:buffer:echo:
    :PROPERTIES:
    :Command:  C-g
    :Description: Quits the password prompt
    :Context:  password
    :END:
*** Password Yank                                          :buffer:edit:echo:
    :PROPERTIES:
    :Command:  C-y
    :Description: Inserts the current kill into the password
    :Context:  password
    :END:
*** Password Submit                                :buffer:command:line:echo:
    :PROPERTIES:
    :Command:  <RET> OR <ESC>
    :Description: Submits password
    :Context:  password
    :END:
*** Yes No Recenter Selected Window                      :window:display:nav:
    :PROPERTIES:
    :Command:  C-l
    :Description: Recenter the selected window
    :Context:  yes-no
    :END:
*** Yes No Scroll Up                                             :nav:buffer:
    :PROPERTIES:
    :Command:  C-v OR <PageDown> OR <next>
    :Description: Scroll forward
    :Context:  yes-no
    :END:
*** Yes No Scroll Down                                           :nav:buffer:
    :PROPERTIES:
    :Command:  M-v OR <PageUp> OR <previous>
    :Description: Scroll backward
    :Context:  yes-no
    :END:
*** Yes No Scroll Up Next Window                          :nav:buffer:window:
    :PROPERTIES:
    :Command:  C-M-v
    :Description: Scrolls forward in the next window
    :Context:  yes-no
    :END:
*** Yes No Scroll Down Next Window                        :nav:buffer:window:
    :PROPERTIES:
    :Command:  C-M-S-v
    :Description: Scrolls backward in the next window
    :Context:  yes-no
    :END:
*** Yes No Quit                                                :undo:command:
    :PROPERTIES:
    :Command:  C-g
    :Description: Dismisses query and quits the command
    :Context:  yes-no
    :END:
** Running Commands by Name
*** execute-extended-command                            :command:buffer:echo:
    :PROPERTIES:
    :Command:  M-x
    :Description: Run a command by name
    :Context:  anywhere
    :Argument: numeric
    :END:
    A numeric argument passes the same numeric argument along to the
    command you are trying to execute.
** Help
*** help-for-help                                       :helps:inform:window:
    :PROPERTIES:
    :Command:  C-h C-h
    :Description: View a list of help commands
    :Context:  anywhere
    :END:
*** scroll-up-command                                      :helps:nav:window:
    :PROPERTIES:
    :Command:  <SPC>
    :Description: Scroll contents of help window up
    :Context:  help
    :END:
*** scroll-down-command                                    :helps:nav:window:
    :PROPERTIES:
    :Command:  <DEL>
    :Description: Scroll contents of help window down.
    :Context:  help
    :END:
*** help-follow                                            :helps:nav:buffer:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Follow cross-reference at point
    :Context:  help
    :END:
*** push-button                                               :helps:command:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Perform action specified by a button at relevant location
    :Context:  help
    :END:
*** apropos-command                             :command:helps:window:search:
    :PROPERTIES:
    :Command:  C-h a
    :Description: Searches for commands whose names match provided input
    :Context:  navigating
    :END:
*** info                                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h i
    :Description: Enter Info, the documentation browser
    :Context:  navigating
    :END:
*** Info-directory                                        :buffer:inform:nav:
    :PROPERTIES:
    :Command:  d
    :Description: Go to the Info directory node.
    :Context:  info
    :END:
*** Info-menu                                      :buffer:inform:search:nav:
    :PROPERTIES:
    :Command:  m
    :Description: Go to the node pointed to by the menu item indicated
    :Context:  info
    :END:
*** Info-index                                     :buffer:inform:search:nav:
    :PROPERTIES:
    :Command:  i
    :Description: Look up given string in this manual's index and go there
    :Context:  info
    :END:
*** Info-search                                    :buffer:inform:search:nav:
    :PROPERTIES:
    :Command:  s
    :Description: Search for given REGEXP, starting from point, go to node
    :Context:  info
    :END:
*** view-emacs-FAQ                                            :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-f
    :Description: Display the Emacs Frequently Asked Questions (FAQ) file
    :Context:  navigating
    :END:
*** finder-by-keyword                                         :window:inform:
    :PROPERTIES:
    :Command:  C-h p
    :Description: Find packages matching a given keyword
    :Context:  navigating
    :END:
*** describe-bindings                                     :window:helps:keys:
    :PROPERTIES:
    :Command:  C-h b
    :Description: Display all active key bindings: minor, major, global
    :Context:  anywhere
    :END:
*** describe-key-briefly                                   :echo:keys:inform:
    :PROPERTIES:
    :Command:  C-h c
    :Description: Show name of command associated with key sequence
    :Context:  anywhere
    :END:
*** apropos-documentation                       :helps:command:window:search:
    :PROPERTIES:
    :Command:  C-h d
    :Description: Display commands and variables with matching documentation
    :Context:  navigating
    :END:
*** view-echo-area-messages                                :echo:buffer:hist:
    :PROPERTIES:
    :Command:  C-h e
    :Description: Display the *Messages* buffer
    :Context:  anywhere
    :END:
*** describe-function                                          :window:helps:
    :PROPERTIES:
    :Command:  C-h f
    :Description: Display documentation on function with provided name
    :Context:  anywhere
    :END:
*** view-hello-file                                      :buffer:inform:char:
    :PROPERTIES:
    :Command:  C-h h
    :Description: Display the ~HELLO~ file.
    :Context:  anywhere
    :END:
*** info                                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h i
    :Description: Run Info, the GNU documentation browser.
    :Context:  anywhere
    :Argument: numeric, plain
    :END:
    With a numeric argument /n/, ~C-h i~ selects the Info buffer
    '~*info*<n>'. This is useful if you want to browse multiple Info
    manuals simultaneously. With just a plain argument, ~C-h i~
    prompts for the name of a documentation file, so you can browse a
    file which doesn't have an entry in the top-level Info
    menu.
*** describe-key                                  :window:command:keys:helps:
    :PROPERTIES:
    :Command:  C-h k
    :Description: Display name and documentation for associated key
    :Context:  anywhere
    :END:
*** view-lossage                                          :window:helps:keys:
    :PROPERTIES:
    :Command:  C-h l
    :Description: Display a description of last 300 keystrokes
    :Context:  anywhere
    :END:
*** describe-mode                                         :window:mode:helps:
    :PROPERTIES:
    :Command:  C-h m
    :Description: Display documentation of current major and minor modes
    :Context:  anywhere
    :END:
*** view-emacs-news                                           :buffer:inform:
    :PROPERTIES:
    :Command:  C-h n
    :Description: Display news of recent Emacs changes
    :Context:  anywhere
    :END:
*** describe-symbol                                            :window:helps:
    :PROPERTIES:
    :Command:  C-h o
    :Description: Display documentation of Lisp symbol provided
    :Context:  anywhere
    :END:
*** finder-by-keyword                                   :window:inform:files:
    :PROPERTIES:
    :Command:  C-h p
    :Description: Find packages by topic keyword
    :Context:  anywhere
    :END:
*** describe-package                                     :window:helps:files:
    :PROPERTIES:
    :Command:  C-h P
    :Description: Display documentation about the specified package
    :Context:  navigating
    :END:
*** info-emacs-manual                                         :buffer:inform:
    :PROPERTIES:
    :Command:  C-h r
    :Description: Display the Emacs manual in Info
    :Context:  anywhere
    :END:
*** describe-syntax                                       :window:helps:char:
    :PROPERTIES:
    :Command:  C-h s
    :Description: Display the contents of the current syntax table
    :Context:  anywhere
    :END:
*** help-with-tutorial                          :buffer:startup:keys:command:
    :PROPERTIES:
    :Command:  C-h t
    :Description: Enter the Emacs interactive tutorial
    :Context:  anywhere
    :END:
*** describe-variable                                          :window:helps:
    :PROPERTIES:
    :Command:  C-h v
    :Description: Display the documentation of the Lisp variable provided
    :Context:  anywhere
    :END:
*** where-is                                              :echo:keys:command:
    :PROPERTIES:
    :Command:  C-h w
    :Description: Show which keys run the command provided
    :Context:  anywhere
    :END:
*** describe-coding-system                              :window:helps:coding:
    :PROPERTIES:
    :Command:  C-h C
    :Description: Describe the coding system provided
    :Context:  navigating
    :END:
*** Info-goto-emacs-command-node                      :buffer:inform:command:
    :PROPERTIES:
    :Command:  C-h F
    :Description: Enter Info at node that describes command provided
    :Context:  navigating
    :END:
*** describe-input-method                                      :window:helps:
    :PROPERTIES:
    :Command:  C-h I
    :Description: Describe the input method provided
    :Context:  anywhere
    :END:
*** Info-goto-emacs-key-command-node             :buffer:inform:command:keys:
    :PROPERTIES:
    :Command:  C-h K
    :Description: Enter Info at node that documents provided key sequence
    :Context:  anywhere
    :END:
*** describe-language-environment                              :window:helps:
    :PROPERTIES:
    :Command:  C-h L
    :Description: Display information of language environment provided
    :Context:  navigating
    :END:
*** info-lookup-symbol                                        :window:inform:
    :PROPERTIES:
    :Command:  C-h S
    :Description: Display the info documentation on provided symbol in context
    :Context:  navigating
    :END:
*** display-local-help                                          :echo:inform:
    :PROPERTIES:
    :Command:  C-h .
    :Description: Display the help message for selected special text area
    :Context:  special-text
    :END:
*** apropos                                            :window:inform:search:
    :PROPERTIES:
    :Description: Search for functions and variables
    :Context:  navigating
    :END:
*** apropos-user-option                                :window:inform:search:
    :PROPERTIES:
    :Description: Search for user-customizable variables
    :Context:  navigating
    :Argument: plain
    :END:
    With a prefix argument, search for non-customizable variables
    too.
*** apropos-variable                                   :window:inform:search:
    :PROPERTIES:
    :Description: Search for variables
    :Context:  navigating
    :Argument: plain
    :END:
    With a prefix argument, search for customizable variables only.
*** apropos-local-variable                             :window:inform:search:
    :PROPERTIES:
    :Description: Search for buffer-local variables
    :Context:  navigating
    :END:
*** apropos-value                                      :window:inform:search:
    :PROPERTIES:
    :Description: Search variables whose values match specified pattern
    :Context:  navigating
    :Argument: plain
    :END:
    With a prefix argument, search also for functions with definitions
    matching the pattern, and Lisp symbols with properties matching
    the pattern.
*** apropos-local-value                                :window:inform:search:
    :PROPERTIES:
    :Description: Search buffer-local variables that match specified pattern
    :Context:  navigating
    :END:
*** forward-button                                         :nav:helps:buffer:
    :PROPERTIES:
    :Command:  <TAB>
    :Description: Move point forward to the next hyperlink
    :Context:  help
    :END:
*** backward-button                                        :nav:helps:buffer:
    :PROPERTIES:
    :Command:  S-<TAB>
    :Description: Move point back to the previous hyperlink
    :Context:  help
    :END:
*** help-follow-symbol                                         :helps:buffer:
    :PROPERTIES:
    :Command:  C-c C-c
    :Description: Show all documentation about the symbol at point
    :Context:  help
    :END:
*** help-go-forward                                        :nav:buffer:helps:
    :PROPERTIES:
    :Command:  C-c C-f OR r
    :Description: Go forward to the next help topic
    :Context:  help
    :END:
*** help-go-back                                           :nav:buffer:helps:
    :PROPERTIES:
    :Command:  C-c C-b OR l
    :Description: Go back to the previous help topic
    :Context:  help
    :END:
*** describe-copying                                          :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-c
    :Description: Display the rules under which you can copy Emacs
    :Context:  anywhere
    :END:
*** view-emacs-debugging                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-d
    :Description: Display help for debugging Emacs
    :Context:  anywhere
    :END:
*** view-external-packages                                    :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-e
    :Description: Display information about where to get external packages
    :Context:  anywhere
    :END:
*** describe-gnu-project                                       :frame:inform:
    :PROPERTIES:
    :Command:  C-h g
    :Description: Visit the page with information about the GNU Project
    :Context:  anywhere
    :END:
*** view-order-manuals                                        :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-m
    :Description: Display info on printed copies of Emacs manuals
    :Context:  anywhere
    :END:
*** describe-distribution                                     :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-o
    :Description: Display how to download latest version of Emacs
    :Context:  anywhere
    :END:
*** view-emacs-problems                                       :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-p
    :Description: Display known Emacs problems, sometimes with workaround
    :Context:  anywhere
    :END:
*** view-emacs-todo                                           :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-t
    :Description: Display the Emacs to-do list
    :Context:  anywhere
    :END:
*** describe-no-warranty                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-w
    :Description: Display full details on no warranty for GNU Emacs
    :Context:  anywhere
    :END:
** The Mark and the Region
*** set-mark-command                                          :buffer:region:
    :PROPERTIES:
    :Command:  C-<SPC> OR C-@
    :Description: Set the mark at point, and activate it
    :Context:  anywhere
    :Argument: plain
    :END:
    With plain prefix argument, move point to where the previous mark
    was, and restore the mark from the ring of former marks.
*** exchange-point-and-mark                               :buffer:region:nav:
    :PROPERTIES:
    :Command:  C-x C-x
    :Description: Swap mark and point and activate mark
    :Context:  anywhere
    :Argument: plain
    :END:
    If you call this with a plain prefix argument, it leaves the mark
    inactive and the region unhighlighted; you can use this to jump to
    the mark in a manner similar to ~C-u C-<SPC>~.
*** mouse-set-region                                      :buffer:region:nav:
    :PROPERTIES:
    :Command:  <drag-mouse-1>
    :Description: Set point and the mark around the text you drag across.
    :Context:  anywhere
    :END:
*** mouse-save-then-kill                                  :buffer:region:nav:
    :PROPERTIES:
    :Command:  <mouse-3>
    :Description: Set the mark at point, then move point to click
    :Context:  anywhere
    :END:
*** upcase-region                                        :buffer:region:edit:
    :PROPERTIES:
    :Command:  C-x C-u
    :Description: Convert text in active region to upcase, deactivate mark
    :Context:  editing
    :END:
*** mark-word                                            :buffer:region:word:
    :PROPERTIES:
    :Command:  M-@
    :Description: Set mark at the end of the next word
    :Context:  anywhere
    :Argument: numeric
    :END:
    This command also accepts a numeric argument /n/, which tells it
    to advance the mark by /n/ words. A negative argument -/n/ moves
    the mark back by /n/ words.
*** mark-sexp                                            :buffer:region:word:
    :PROPERTIES:
    :Command:  C-M-<SPC> OR C-M-@
    :Description: Set mark after end of following balanced expression
    :Context:  anywhere
    :Argument: numeric
    :END:
    Positive or negative numeric arguments move the mark forward or
    backward by the specified number of expressions.
*** mark-paragraph                                   :buffer:region:line:nav:
    :PROPERTIES:
    :Command:  M-h
    :Description: Move point to start of paragraph, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    numeric arguments specify how many objects to move the mark by.
*** mark-defun                                       :buffer:region:line:nav:
    :PROPERTIES:
    :Command:  C-M-h
    :Description: Move point to start of current defun, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    Numeric arguments specify how many objects to move the mark by.
*** mark-page                                             :buffer:region:nav:
    :PROPERTIES:
    :Command:  C-x C-p
    :Description: Move point to start of page, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    Numeric arguments specify how many objects to move the mark by.
*** mark-whole-buffer                                     :buffer:region:nav:
    :PROPERTIES:
    :Command:  C-x h
    :Description: Move point to start of buffer, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    Numeric arguments specify how many objects to move the mark by.
*** kill-region                                     :kill:region:edit:delete:
    :PROPERTIES:
    :Command:  C-w
    :Description: Kill ("cut") text between point and mark
    :Context:  editing
    :END:
*** kill-ring-save                                              :kill:region:
    :PROPERTIES:
    :Command:  M-w
    :Description: Save the region as if killed, but don't kill it. ("Copy")
    :Context:  navigating
    :END:
*** downcase-region                                             :edit:region:
    :PROPERTIES:
    :Command:  C-x C-l
    :Description: Convert the region to lower case
    :Context:  editing
    :END:
*** upcase-region                                               :edit:region:
    :PROPERTIES:
    :Command:  C-x C-u
    :Description: Convert the region to upper case
    :Context:  editing
    :END:
*** query-replace                                               :edit:search:
    :PROPERTIES:
    :Command:  M-%
    :Description: Replace some occurrences of one string with another
    :Context:  editing
    :END:
*** indent-rigidly                                         :edit:line:region:
    :PROPERTIES:
    :Command:  C-x <TAB>
    :Description: Indent all lines starting in the region
    :Context:  editing
    :END:
*** indent-region                                          :edit:line:region:
    :PROPERTIES:
    :Command:  C-M-\
    :Description: Indent each nonblank line in the region
    :Context:  editing
    :END:
*** fill-region                                                 :edit:region:
    :PROPERTIES:
    :Description: Fill each of the paragraphs in the region
    :Context:  editing
    :END:
*** ispell-word                                                   :word:edit:
    :PROPERTIES:
    :Command:  M-$
    :Description: Check spelling of word under or before the cursor
    :Context:  editing
    :END:
*** eval-region                                                     :command:
    :PROPERTIES:
    :Description: Execute the region as Lisp code
    :Context:  anywhere
    :END:
*** copy-to-register                                                 :region:
    :PROPERTIES:
    :Command:  C-x r x OR C-x r s
    :Description: Copy region into given register
    :Context:  navigating
    :END:
*** delete-selection-mode                           :mode:delete:edit:region:
    :PROPERTIES:
    :Description: Toggle Delete Selection mode
    :Context:  editing
    :END:
*** pop-global-mark                                       :nav:region:buffer:
    :PROPERTIES:
    :Command:  C-x C-<SPC>
    :Description: Jumps to last buffer and position of global mark ring
    :Context:  navigating
    :END:
*** transient-mark-mode                             :display:region:nav:mode:
    :PROPERTIES:
    :Description: Toggle Transient Mark mode
    :Context:  navigating
    :END:
** Killing and Moving Text
*** delete-horizontal-space                                     :delete:char:
    :PROPERTIES:
    :Command:  M-\
    :Description: Delete spaces and tabs around point
    :Context:  editing
    :Argument: plain
    :END:
    With a prefix argument, this only deletes spaces and tab
    characters before point.
*** just-one-space                                              :delete:char:
    :PROPERTIES:
    :Command:  M-<SPC>
    :Description: Delete spaces and tabs around point, leaving one space
    :Context:  editing
    :Argument: numeric
    :END:
    With a numeric argument /n/, it leaves /n/ spaces before point if
    /n/ is positive; if /n/ is negative, it deletes newlines in
    addition to spaces and tabs, leaving /-n/ spaces before point.
*** delete-blank-lines                                          :delete:line:
    :PROPERTIES:
    :Command:  C-x C-o
    :Description: Delete blank lines around the current line
    :Context:  editing
    :END:
    ~C-x C-o~ (~delete-blank-lines~) deletes all blank lines after the
    current line. If the current line is blank, it deletes all blank
    lines preceding the current line as well (leaving one blank line,
    the current line). On a solitary blank line, it deletes that line.
*** delete-indentation                                          :delete:line:
    :PROPERTIES:
    :Command:  M-^
    :Description: Join two lines by deleting newline and indentation
    :Context:  editing
    :END:
*** cycle-spacing                                               :delete:char:
    :PROPERTIES:
    :Description: Manipulate whitespace around point in a smart way
    :Context:  editing
    :END:
    The command ~cycle-spacing~ acts like a more flexible version of
    ~just-one-space~. It does different things if you call it
    repeatedly in succession. The first call acts like
    ~just-one-space~, the next removes all whitespace, and a third
    call restores the original whitespace.
*** delete-duplicate-lines                                      :delete:line:
    :PROPERTIES:
    :Description: Delete all but one copy of any identical lines in the region
    :Context:  editing
    :Argument: plain, double, triple
    :END:
    - By default keeps first instance of each repeated line
    - With a plain prefix it keeps the last instance of each repeated
      line
    - With a double prefix argument, it only searches for adjacent
      identical lines.
    - With a triple prefix argument, it retains repeated blank lines
*** kill-whole-line                                        :kill:line:delete:
    :PROPERTIES:
    :Command:  C-S-<DEL>
    :Description: Kill an entire line at once
    :Context:  editing
    :END:
    Note that many text terminals will prevent you from typing the key
    sequence ~C-S-<DEL>~
*** backward-kill-sentence                                      :delete:kill:
    :PROPERTIES:
    :Command:  C-x <DEL>
    :Description: Kill back to the beginning of sentence
    :Context:  editing
    :END:
*** kill-sentence                                               :kill:delete:
    :PROPERTIES:
    :Command:  M-k
    :Description: Kill to the end of the sentence
    :Context:  editing
    :END:
*** kill-sexp                                                   :delete:kill:
    :PROPERTIES:
    :Command:  C-M-k
    :Description: Kill the following balanced expression
    :Context:  editing
    :END:
*** zap-to-char                                            :char:delete:kill:
    :PROPERTIES:
    :Command:  M-z <char>
    :Description: Kill through the next occurrence of <char>
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument acts as a repeat count; a negative argument
    means to search backward and kill text before point.
*** yank                                                               :edit:
    :PROPERTIES:
    :Command:  C-y
    :Description: Yank the last kill into the buffer, at point
    :Context:  editing
    :Argument: numeric, plain
    :END:
    Inserts the most recent kill, leaving the cursor at the end of the
    inserted text. It also sets the mark at the beginning of the
    inserted text, without activating the mark.

    With a plain prefix argument (~C-u C-y~), the command instead
    leaves the cursor in front of the inserted text, and sets the mark
    at the end.

    Using a numeric argument /n/ specifies reinserting the /n/-th
    earlier kill. And keeps the last-yank pointer at that kill.
*** yank-pop                                                      :edit:hist:
    :PROPERTIES:
    :Command:  M-y
    :Description: Replace recent yanked text with earlier batch of killed text
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument defines how many entries to advance the
    last-yank pointer by. A negative argument moves the pointer toward
    the front of the ring; from the front of the ring, it moves around
    to the last entry and continues forward from there.
*** append-next-kill                                              :kill:hist:
    :PROPERTIES:
    :Command:  C-M-w
    :Description: Cause following kill command to append to previous kill
    :Context:  editing
    :END:
*** set-selection-coding-system                                 :kill:coding:
    :PROPERTIES:
    :Command:  C-x <RET> x
    :Description: set coding system for killed text in clipboard
    :Context:  navigating
    :END:
*** set-next-selection-coding-system                            :kill:coding:
    :PROPERTIES:
    :Command:  C-x <RET> X
    :Description: Use coding-system for only next communication with other apps
    :Context:  navigating
    :END:
*** clipboard-kill-region                                       :kill:delete:
    :PROPERTIES:
    :Command:  <f20>
    :Description: kills the region and saves it to the clipboard
    :Context:  editing
    :END:
*** clipboard-kill-ring-save                                           :kill:
    :PROPERTIES:
    :Command:  <f16>
    :Description: copies region to kill ring and saves to clipboard
    :Context:  navigating
    :END:
*** clipboard-yank                                                     :edit:
    :PROPERTIES:
    :Command:  <f18>
    :Description: yanks the contents of the clipboard at point
    :Context:  editing
    :END:
*** mouse-yank-primary                                                 :edit:
    :PROPERTIES:
    :Command:  <mouse-2>
    :Description: Insert primary selection in Emacs buffer at point or click
    :Context:  editing
    :END:
*** mouse-set-secondary                                              :region:
    :PROPERTIES:
    :Command:  <M-Drag-mouse-1>
    :Description: Set secondary selection within dragged region
    :Context:  navigating
    :END:
    The selected text is highlighted, using the ~secondary-selection~
    face, as you drag. The window scrolls automatically if you drag
    the mouse off the top or bottom of the window, just like
    ~mouse-set-region~.

    This command does not alter the kill ring
*** mouse-start-secondary                                            :region:
    :PROPERTIES:
    :Command:  <M-mouse-1>
    :Description: Set one endpoint for the secondary selection
    :Context:  navigating
    :END:
    Use ~M-mouse-3~ to set the other end and complete the
    selection. This command cancels any existing secondary selection,
    when it starts a new one.

    Double or triple clicking of ~M-mouse-1~ operates on words and
    lines, much like ~mouse-1~.
*** mouse-secondary-save-then-kill                              :region:kill:
    :PROPERTIES:
    :Command:  <M-mouse-3>
    :Description: Set the secondary selection and copy to kill ring
    :Context:  navigating
    :END:
    A second ~M-mouse-3~ at the same place kills the text selected by
    the secondary selection just made.
*** mouse-yank-secondary                                               :edit:
    :PROPERTIES:
    :Command:  <M-mouse-2>
    :Description: Insert secondary selection at point or click
    :Context:  editing
    :END:
    Places point at the end of the yanked text
*** append-to-buffer                                          :region:buffer:
    :PROPERTIES:
    :Description: Append region to the contents of a specified buffer
    :Context:  navigating
    :END:
    This reads a buffer name, then inserts a copy of the region into
    the buffer specified. If you specify a nonexistent buffer, this
    command creates the buffer.

    Point in that buffer is left at the end of the copied text, so
    successive uses of this command accumulate the text in the
    specified buffer in the same order as they were copied. Strictly
    speaking, the command does not always append to the text already
    in the buffer - it appends only if point in that buffer is at the
    end. However, if the command is the only command you use to alter
    a buffer then point is always at the end.
*** prepend-to-buffer                                         :region:buffer:
    :PROPERTIES:
    :Description: Prepend region to the contents of a specified buffer
    :Context:  navigating
    :END:
    This command is just like ~append-to-buffer~ except that point in
    the other buffer is left before the copied text, so successive
    uses of this command add text in reverse order.
*** copy-to-buffer                                     :region:buffer:delete:
    :PROPERTIES:
    :Description: Copy region into specified buffer, deleting the contents
    :Context:  navigating
    :END:
*** insert-buffer                                               :edit:buffer:
    :PROPERTIES:
    :Description: Insert specified buffer into current buffer at point
    :Context:  editing
    :END:
    This prompts for the name of a buffer, and inserts a copy of all
    the text in that buffer into the current buffer at point, leaving
    point at the beginning of the inserted text. It also adds the
    position of the end of the inserted text to the mark ring, without
    activating the mark.
*** append-to-file                                             :region:files:
    :PROPERTIES:
    :Description: Append region to contents of specified file, at the end
    :Context:  navigating
    :END:
    This prompts for a filename, and adds the text of the region to
    the end of the specified file. The file is changed immediately on
    disk.

    You should only use this command with files that are /not/ being
    visited in Emacs. Using it on a file that you are editing in Emacs
    would change the file behind Emacs's back, which can lead to losing
    some of your editing.
*** kill-rectangle                                       :region:kill:delete:
    :PROPERTIES:
    :Command:  C-x r k
    :Description: Kill text of region-rectangle, save as last killed rectangle
    :Context:  editing
    :END:
*** copy-rectangle-as-kill                                      :region:kill:
    :PROPERTIES:
    :Command:  C-x r M-w
    :Description: Save the text of region-rectangle as last killed rectangle
    :Context:  navigating
    :END:
*** delete-rectangle                                          :region:delete:
    :PROPERTIES:
    :Command:  C-x r d
    :Description: Delete the text of region-rectangle
    :Context:  editing
    :END:
*** yank-rectangle                                              :region:edit:
    :PROPERTIES:
    :Command:  C-x r y
    :Description: Yank last killed rectangle with up left corner at point
    :Context:  editing
    :END:
*** open-rectangle                                              :region:edit:
    :PROPERTIES:
    :Command:  C-x r o
    :Description: Insert blank space to fill region-rectangle, push right
    :Context:  editing
    :END:
*** rectangle-number-lines                                      :region:edit:
    :PROPERTIES:
    :Command:  C-x r N
    :Description: Insert line numbers on left of region-rectangle, push right
    :Context:  editing
    :Argument: numeric
    :END:
    Normally, the numbering begins from 1 (for the first line of the
    rectangle). With a numeric argument, the command prompts for a
    number to begin from, and for a format string with which to print
    the numbers.
*** clear-rectangle                                             :region:edit:
    :PROPERTIES:
    :Command:  C-x r c
    :Description: Clear region-rectangle by replacing contents with spaces
    :Context:  editing
    :END:
*** delete-whitespace-rectangle                               :region:delete:
    :PROPERTIES:
    :Description: Delete whitespace in region-rectangle along left edge
    :Context:  editing
    :END:
    Deletes horizontal whitespace starting from a particular
    column. This applies to each of the lines in the rectangle, and
    the column is specified by the left edge of the rectangle. The
    right edge of the rectangle does not make any difference to this
    command.
*** string-rectangle                                            :region:edit:
    :PROPERTIES:
    :Command:  C-x r t
    :Description: Replace rectangle contents with given string on each line
    :Context:  editing
    :END:
    The string's width need not be the same width of the rectangle. If
    the string's width is less, the text after the rectangle shifts
    left; if the string is wider than the rectangle, the text after
    the rectangle shifts right.
*** string-insert-rectangle                                     :region:edit:
    :PROPERTIES:
    :Description: Insert given string on each line of rectangle
    :Context:  editing
    :END:
*** rectangle-mark-mode                                 :region:display:mode:
    :PROPERTIES:
    :Command:  C-x <SPC>
    :Description: Toggle Rectangle Mark mode
    :Context:  navigating
    :END:
*** rectangle-exchange-point-and-mark                        :region:display:
    :PROPERTIES:
    :Command:  C-x C-x
    :Description: Cycle between four corners of region-rectangle
    :Context:  rectangle
    :END:
*** cua-mode                               :command:keys:mode:edit:kill:undo:
    :PROPERTIES:
    :Description: Toggle CUA mode
    :Context:  navigating
    :END:
*** kill-region                                     :kill:region:edit:delete:
    :PROPERTIES:
    :Command:  C-x <timeout>
    :Description: Kill ("cut") text between point and mark
    :Context:  cua
    :Argument: numeric
    :END:
    With a one digit numeric prefix kill text into that numbered
    register.
*** copy-region-as-kill                                         :kill:region:
    :PROPERTIES:
    :Command:  C-c <timeout>
    :Description: Save the region as if killed, but don't kill it
    :Context:  cua
    :Argument: numeric
    :END:
    With a one digit numeric prefix copy text into that numbered
    register.
*** cua-paste                                                          :edit:
    :PROPERTIES:
    :Command:  C-v
    :Description: Paste last cut or copied region or rectangle
    :Context:  cua
    :Argument: numeric
    :END:
    With a one digit numeric prefix paste text from that numbered
    register.
*** undo                                                               :undo:
    :PROPERTIES:
    :Command:  C-z
    :Description: Undo some previous changes
    :Context:  cua
    :END:
*** cua-set-rectangle-mark                                      :region:mode:
    :PROPERTIES:
    :Command:  C-<RET>
    :Description: Set mark and start in CUA rectangle mode
    :Context:  cua
    :END:
*** cua-rotate-rectangle                                         :region:nav:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Move to next corner of rectangle selection (clockwise)
    :Context:  cua-rectangle
    :END:
*** cua-toggle-global-mark                                             :edit:
    :PROPERTIES:
    :Command:  C-S-<SPC>
    :Description: Set or cancel the global marker
    :Context:  cua
    :END:
** Registers
*** view-register                                     :window:register:helps:
    :PROPERTIES:
    :Description: Display a description of what given register contains
    :Context:  anywhere
    :END:
    test
*** Display Available Registers                  :window:register:char:helps:
    :PROPERTIES:
    :Command:  C-h OR <F1>
    :Description: Explicitly request to preview available registers
    :Context:  register
    :END:
*** point-to-register                                   :register:nav:buffer:
    :PROPERTIES:
    :Command:  C-x r <SPC>
    :Description: Record current buffer and position in given register
    :Context:  navigating
    :END:
*** jump-to-register                                    :register:nav:buffer:
    :PROPERTIES:
    :Command:  C-x r j
    :Description: Restore state saved in given register
    :Context:  anywhere
    :Argument: plain
    :END:
    If given register stored a position in a buffer then this command
    jumps to saved position and buffer in given register.
    
    If you use this command to go to a saved position, but the buffer
    it was saved from has been killed, the command tries to create the
    buffer again by visiting the same file. Of course, this works only
    for buffers that were visiting files.

    If given register stored a window configuration then using this
    command restores the window configuration. When you restore a
    frame configuration, any existing frames not included in the
    configuration become invisible.

    If given register stored a window configuration then with a plain
    argument this command will delete any frames that are not included
    in the configuration.

    If given register stored a complete filename with path then this
    command visits that file.

    If given register stored a keyboard macro this command executes
    the keyboard macro.
*** copy-to-register                                        :region:register:
    :PROPERTIES:
    :Command:  C-x r s
    :Description: Copy region into given register
    :Context:  navigating
    :Argument: plain
    :END:
    If the mark is inactive, Emacs first reactivates the mark where it
    was last set. The mark is deactivated at the end of this command.

    With a plain argument this command copies the text into given
    register and deletes the text from the buffer as well.
*** insert-register                                    :region:register:edit:
    :PROPERTIES:
    :Command:  C-x r i
    :Description: Insert contents from given register at point
    :Context:  editing
    :Argument: plain
    :END:
    Normally this leaves point after the text and sets the mark
    before, without activating it.

    With a prefix argument, it instead puts point before the text and
    the mark after.

    Will insert rectangle if given register contains a rectangle.

    When contents of register is a number, will insert number from
    given register at point.
*** append-to-register                                      :region:register:
    :PROPERTIES:
    :Description: Append region to text in given register
    :Context:  navigating
    :Argument: plain
    :END:
    If invoked with a plain argument, it deletes the region after
    appending it to the register.
*** increment-register                                             :register:
    :PROPERTIES:
    :Command:  C-x r +
    :Description: Behaves different depending on contents of register
    :Context:  anywhere
    :Argument: numeric
    :END:
    When given register contains text, this command appends text in
    region to that register.

    When given register contains a number, this command increases that
    number by 1.

    With a numeric argument, when the register contains a number, this
    adds the number in the register with the numeric argument and
    stores the sum in the register.
*** prepend-to-register                                     :region:register:
    :PROPERTIES:
    :Description: Prepend region to text in given register
    :Context:  navigating
    :Argument: plain
    :END:
    If invoked with a prefix argument, it deletes the region after
    prepending it to the given register.
*** copy-rectangle-to-register                              :region:register:
    :PROPERTIES:
    :Command:  C-x r r
    :Description: Copy region-rectangle into given register
    :Context:  navigating
    :Argument: plain
    :END:
    With a plain argument, delete the rectangle in addition to copying
    the rectangle to the given register.
*** window-configuration-to-register                  :window:frame:register:
    :PROPERTIES:
    :Command:  C-x r w
    :Description: Save state of selected frame's windows in given register
    :Context:  anywhere
    :END:
*** frameset-to-register                              :window:frame:register:
    :PROPERTIES:
    :Command:  C-x r f
    :Description: Save state of all frames, all windows, in given register
    :Context:  anywhere
    :END:
*** number-to-register                                             :register:
    :PROPERTIES:
    :Command:  C-x r n
    :Description: Store number 0 in given register
    :Context:  anywhere
    :Argument: numeric
    :END:
    With a numeric argument store that number into the given
    register.
*** kmacro-to-register                                       :macro:register:
    :PROPERTIES:
    :Command:  C-x C-k x
    :Description: Stores the last keyboard macro in given register
    :Context:  anywhere
    :END:
*** bookmark-set                                                 :buffer:nav:
    :PROPERTIES:
    :Command:  C-x r m
    :Description: Set the bookmark named with given name at point
    :Context:  navigating
    :END:
    Default name for bookmark is the file name.
*** bookmark-set-no-overwrite                                    :buffer:nav:
    :PROPERTIES:
    :Command:  C-x r M
    :Description: set bookmark without overwriting existing bookmark
    :Context:  navigating
    :END:
    Displays error if attempting to overwrite an existing bookmark
*** bookmark-jump                                                :buffer:nav:
    :PROPERTIES:
    :Command:  C-x r b
    :Description: Jump to bookmark with given name
    :Context:  anywhere
    :END:
*** list-bookmarks                                          :buffer:list:nav:
    :PROPERTIES:
    :Command:  C-x r l
    :Description: List all bookmarks
    :Context:  anywhere
    :END:
*** bookmark-save                                          :files:nav:buffer:
    :PROPERTIES:
    :Description: Save all current bookmark values in default bookmark file
    :Context:  anywhere
    :END:
*** bookmark-load                                          :buffer:nav:files:
    :PROPERTIES:
    :Description: Load file with given name containing bookmarks
    :Context:  anywhere
    :END:
    You can use this command to work with other files of bookmark
    values in addition to your default bookmark file.
*** bookmark-write                                         :buffer:nav:files:
    :PROPERTIES:
    :Description: Save all current bookmark values in given file
    :Context:  anywhere
    :END:
*** bookmark-delete                                       :buffer:nav:delete:
    :PROPERTIES:
    :Description: Delete bookmark with given name
    :Context:  anywhere
    :END:
*** bookmark-insert-location                          :buffer:nav:files:edit:
    :PROPERTIES:
    :Description: Insert in buffer the filename pointed to by given bookmark
    :Context:  editing
    :END:
*** bookmark-insert                                         :buffer:nav:edit:
    :PROPERTIES:
    :Description: Insert in buffer the content that given bookmark points to
    :Context:  editing
    :END:
** Controlling the Display
*** scroll-up                                                   :display:nav:
    :PROPERTIES:
    :Description: Like ~C-v~ but disobeys ~scroll-error-top-bottom~
    :Context:  navigating
    :END:
*** scroll-down                                                 :display:nav:
    :PROPERTIES:
    :Description: Like ~M-v~ but disobeys ~scroll-error-top-bottom~
    :END:
*** scroll-up-line                                              :display:nav:
    :PROPERTIES:
    :Description: Scroll the current window up by one line at a time
    :Context:  navigating
    :END:
*** scroll-down-line                                            :display:nav:
    :PROPERTIES:
    :Description: Scroll current window down by one line at a time
    :Context:  navigating
    :END:
*** recenter-top-bottom                                         :display:nav:
    :PROPERTIES:
    :Command:  C-l
    :Description: Scroll selected window so current line is center
    :Context:  navigating
    :Argument: numeric, plain
    :END:
    On subsequent consecutive invocations, make the current line the
    top line, the bottom line, and so on in cyclic order. Possibly
    redisplay the screen too.

    With a plain prefix argument, the command simply recenters the
    line showing point.

    A positive argument /n/ moves the line showing point /n/ lines
    down from the top of the window. An argument of zero moves point's
    line to the top of the window. A negative argument /-n/ moves
    point's line /n/ lines from the bottom of the window.

    When given an argument, the command does not clear the screen or
    cycle through different screen positions
*** recenter                                                    :display:nav:
    :PROPERTIES:
    :Description: Scroll selected window so current line is center
    :Context:  navigating
    :END:
    Possibly redisplay the screen too.
*** reposition-window                                           :display:nav:
    :PROPERTIES:
    :Command:  C-M-l
    :Description: Scroll heuristically to bring useful information on screen
    :Context:  navigating
    :END:
*** scroll-left                                                 :display:nav:
    :PROPERTIES:
    :Command:  C-x <
    :Description: Scroll text in current window to the left
    :Context:  navigating
    :Argument: numeric
    :END:
    scrolls text in the selected window to the left by the full width
    of the window, less two columns. (In other words, the text in the
    window moves left relative to the window.) with a numeric argument
    /n/, it scrolls by /n/ columns.

    If the text is scrolled to the left, and point moves off the left
    edge of the window, the cursor will freeze at the left edge of the
    window, the cursor will freeze at the left edge of the window,
    until point moves back to the displayed portion of the text. This
    is independent of the current setting of ~auto-hscroll-mode~,
    which for text scrolled to the left, only affects the behavior at
    the right edge of the window.
*** scroll-right                                                :display:nav:
    :PROPERTIES:
    :Command:  C-x >
    :Description: Scroll to the right
    :Context:  navigating
    :Argument: numeric
    :END:
    Scrolls similarly as ~scroll-left~ but to the right. The window
    cannot be scrolled any farther to the right once it is displayed
    normally, with each line starting at the window's left margin;
    attempting to do so has no effect. This means that you don't have
    to calculate the numeric argument precisely for this command; any
    sufficiently large argument will restore the normal display.
*** narrow-to-region                                  :buffer:display:region:
    :PROPERTIES:
    :Command:  C-x n n
    :Description: Narrow down to between point and mark
    :Context:  navigating
    :END:
    This sets the current buffer's restrictions so that the text in
    the current region remains accessible, but all the text before the
    region or after the region is inaccessible. Point and mark do not
    change.
*** widen                                                    :buffer:display:
    :PROPERTIES:
    :Command:  C-x n w
    :Description: Widen to make the entire buffer accessible again.
    :Context:  navigating
    :END:
*** narrow-to-page                                           :buffer:display:
    :PROPERTIES:
    :Command:  C-x n p
    :Description: Narrow down to the current page
    :Context:  navigating
    :END:
*** narrow-to-defun                                          :buffer:display:
    :PROPERTIES:
    :Command:  C-x n d
    :Description: Narrow down to the current defun
    :Context:  navigating
    :END:
*** View-quit                                               :nav:mode:buffer:
    :PROPERTIES:
    :Command:  q
    :Description: Disables View mode, restoring prev buffer and position
    :Context:  view
    :END:
*** View-exit                                               :nav:mode:buffer:
    :PROPERTIES:
    :Command:  e
    :Description: Disables View mode keeping buffer and position
    :Context:  view
    :END:
*** view-buffer                                     :display:buffer:nav:mode:
    :PROPERTIES:
    :Description: Enables View mode on provided buffer
    :Context:  anywhere
    :END:
*** view-file                                        :display:files:nav:mode:
    :PROPERTIES:
    :Description: Enables View mode on provided file
    :Context:  anywhere
    :END:
*** follow-mode                        :display:nav:window:frame:buffer:mode:
    :PROPERTIES:
    :Description: Enable/disable Follow mode
    :Context:  follow-ready
    :END:
*** list-faces-display                                 :window:helps:display:
    :PROPERTIES:
    :Description: See what faces are currently defined
    :Context:  navigating
    :Argument: plain
    :END:
    With a plain prefix argument, this prompts for a regular
    expression, and displays only faces with names matching that
    regular expression
*** list-colors-display                                :window:display:helps:
    :PROPERTIES:
    :Description: View list of color names
    :Context:  anywhere
    :END:
    If you run the command on a text terminal, it shows only a small
    subset of colors that can be safely displayed on such
    terminals.

    Also shows the equivalent RGB triplet for each named color. For
    instance, ~medium sea green~ is equivalent to ~#3CB371~.
*** set-face-foreground                                        :display:echo:
    :PROPERTIES:
    :Description: Change foreground color of a face
    :Context:  anywhere
    :END:
    Affects the face colors on all frames, but the effect does not
    persist for future Emacs sessions.
*** set-face-background                                        :display:echo:
    :PROPERTIES:
    :Description: Change background color of a face
    :Context:  anywhere
    :END:
    Affects the face colors on all frames, but the effect does not
    persist for future Emacs sessions.
*** text-scale-adjust                                               :display:
    :PROPERTIES:
    :Command:  C-x C-0 OR C-x C-= OR C-x C-- OR C-x C-+
    :Description: Adjust the height of the default face
    :Context:  anywhere
    :Argument: numeric
    :END:
    This command looks at the last key typed to determine which action
    to take.

    - ~+~, ~=~ :: Increase the default face height by one step
    - ~-~ :: Decrease the default face height by one step
    - ~0~ :: Reset the default face height to the global default

    The final key of these commands may be repeated without the
    leading ~C-x~. For instance, ~C-x C-= C-= C-=~ increases the face
    height by three steps. Each step scales the text height by a
    factor of 1.2.

    A numeric argument of 0 to this command restores the default
    height, the same as typing ~C-x C-0~.
*** text-scale-increase                                             :display:
    :PROPERTIES:
    :Description: Increase the height of the default face
    :Context:  anywhere
    :END:
    You may find it convenient to bind the key ~C-x C-+~ to this
    command, rather than ~text-scale-adjust~
*** text-scale-decrease                                             :display:
    :PROPERTIES:
    :Description: Decrease the height of the default face
    :Context:  anywhere
    :END:
    You may find it convenient to bind the key ~C-x C--~ to this
    command rather than ~text-scale-adjust~.
*** text-scale-set                                             :display:mode:
    :PROPERTIES:
    :Description: Scales height of default face to level of prefix argument
    :Context:  anywhere
    :Argument: numeric
    :END:
    This command automatically enables the minor mode
    ~text-scale-mode~ if the current font scaling is other than 1, and
    disable it otherwise.
*** font-lock-mode                                      :display:mode:buffer:
    :PROPERTIES:
    :Description: Toggle Font Lock mode in current buffer
    :Context:  anywhere
    :Argument: numeric
    :END:
    A positive numeric argument unconditionally enables Font Lock
    mode, and a negative or zero argument disables it.
*** global-font-lock-mode                               :display:mode:buffer:
    :PROPERTIES:
    :Description: Toggle Font Lock mode in all buffers
    :Context:  anywhere
    :END:
*** highlight-changes-mode                              :display:buffer:mode:
    :PROPERTIES:
    :Description: Toggle Highlight Changes mode
    :Context:  editing
    :END:
*** hi-lock-mode                                        :display:buffer:mode:
    :PROPERTIES:
    :Description: Toggle Hi Lock mode
    :Context:  navigating
    :END:
*** global-hi-lock-mode                                 :display:buffer:mode:
    :PROPERTIES:
    :Description: Toggle Hi Lock mode in all buffers
    :Context:  anywhere
    :END:
*** highlight-regexp                                  :display:buffer:search:
    :PROPERTIES:
    :Command:  M-s h r
    :Description: Highlight text that matches given regexp using given face
    :Context:  navigating
    :END:
    While being prompted for a face use ~M-n~ and ~M-p~ to cycle
    through them.
    
    You can use this command multiple times, specifying various
    regular expressions to highlight in different ways.
*** next-history-element                                  :echo:hist:display:
    :PROPERTIES:
    :Command:  M-n
    :Description: Select next available list option in minibuffer
    :Context:  mini-select-list
    :END:
*** previous-history-element                              :echo:hist:display:
    :PROPERTIES:
    :Command:  M-p
    :Description: Select previous available list option in minibuffer
    :Context:  mini-select-list
    :END:
*** unhighlight-regexp                                       :display:buffer:
    :PROPERTIES:
    :Command:  M-s h u
    :Description: Unhighlight given regexp
    :Context:  navigating
    :END:
    If you invoke this from the menu, you select the expression to
    unhighlight from a list. If you invoke this from the keyboard, you
    use the minibuffer. It will show the most recently added regular
    expression; use ~M-n~ to show the next older expression and ~M-p~
    to select the next newer expression. (You can also type the
    expression by hand, with completion.) When the expression you want
    to unhighlight appears in the minibuffer, press ~RET~ to exit the
    minibuffer and unhighlight it.
*** highlight-lines-matching-regexp              :display:buffer:line:search:
    :PROPERTIES:
    :Command:  M-s h l
    :Description: Hi-light lines with match for given regexp using given face
    :Context:  navigating
    :END:
*** highlight-phrase                                  :display:buffer:search:
    :PROPERTIES:
    :Command:  M-s h p
    :Description: Highlight matches of given phrase using given face
    :Context:  navigating
    :END:
    Given phrase can be any regexp, but spaces will be replaced by
    matches to whitespace and initial lower-case letters will become
    case insensitive.
*** highlight-symbol-at-point                           :display:buffer:word:
    :PROPERTIES:
    :Command:  M-s h .
    :Description: Highlight the symbol found near point, using next face
    :Context:  navigating
    :END:
*** hi-lock-write-interactive-patterns                  :display:buffer:edit:
    :PROPERTIES:
    :Command:  M-s h w
    :Description: Insert all highlight regexp/face pairs commented at point
    :Context:  editing
    :END:
*** hi-lock-find-patterns                             :display:buffer:search:
    :PROPERTIES:
    :Command:  M-s h f
    :Description: Extract regexp/face pairs from comments in buffer
    :Context:  navigating
    :END:
*** fringe-mode                                   :window:display:mode:frame:
    :PROPERTIES:
    :Description: Toggle Fringe mode in all frames
    :Context:  anywhere
    :END:
*** set-fringe-style                                   :window:display:frame:
    :PROPERTIES:
    :Description: Toggle Fringe mode in current frame
    :Context:  anywhere
    :END:
*** display-fill-column-indicator-mode                :display:window:buffer:
    :PROPERTIES:
    :Description: Toggle Display Fill Column Indicator mode in buffer
    :Context:  navigating
    :END:
    Can be used as a hook
*** global-display-fill-column-indicator-mode                :display:window:
    :PROPERTIES:
    :Description: Toggle Display Fill Column Indicator mode globally
    :Context:  anywhere
    :END:
*** delete-trailing-whitespace                                  :edit:buffer:
    :PROPERTIES:
    :Description: Delete all trailing whitespace
    :Context:  editing
    :END:
    This command deletes all extra spaces at the end of each line in
    the buffer, and all empty lines at the end of the buffer; If the
    region is active, the command instead deletes extra spaces at the
    end of each line in the region.
*** whitespace-mode                                          :display:buffer:
    :PROPERTIES:
    :Description: Toggle Whitespace mode for current buffer
    :Context:  navigating
    :END:
*** whitespace-toggle-options                                :display:buffer:
    :PROPERTIES:
    :Description: Toggle Individual whitespace (ws) elements for ws mode
    :Context:  navigating
    :END:
    Here is a partial list of possible elements (see the variable's
    documentation for the full list):
    - ~face~ :: Enable all visualizations which use special
      faces. This element has a special meaning: if it is absent from
      the list, none of the other visualizations take effect except
      ~space-mark~, ~tab-mark~, and ~newline-mark~.
    - ~trailing~ :: Highlight trailing whitespace.
    - ~tabs~ :: Highlight tab characters.
    - ~spaces~ :: Highlight space and non-breaking space characters.
    - ~lines~ :: Highlight lines longer than 80 columns. To change the
      column limit, customize the variable ~whitespace-line-column~.
    - ~newline~ :: Highlight newlines.
    - ~empty~ :: Highlight empty lines at the beginning and/or end of
      the buffer.
    - ~big-indent~ :: Highlight too-deep indentation. By default any
      sequence of at least 4 consecutive tab characters or 32
      consecutive space characters is highlighted. To change that,
      customize the regular expression
      ~whitespace-big-indent-regexp~.
    - ~space-mark~ :: Draw space and non-breaking characters with a
      special glyph.
    - ~tab-mark~ :: Draw tab characters with a special glyph.
    - ~newline-mark~ :: Draw newline characters with a special glyph.
*** global-whitespace-mode                                   :display:buffer:
    :PROPERTIES:
    :Description: Toggle Global Whitespace mode in all buffers
    :Context:  anywhere
    :END:
*** global-whitespace-toggle-options                         :display:buffer:
    :PROPERTIES:
    :Description: Toggle individual features of Global Whitespace mode
    :Context:  anywhere
    :END:
    See ~whitespace-toggle-options~ for some examples
*** set-selective-display                               :display:buffer:line:
    :PROPERTIES:
    :Command:  C-x $
    :Description: Hide lines with indent given by numeric argument
    :Context:  navigating
    :Argument: numeric
    :END:
    To hide lines in the current buffer, use this command with a
    numeric argument /n/. Then lines with at least /n/ columns of
    indentation disappear from the screen. The only indication of
    their presence is that three dots ('...') appear at the end of
    each visible line that is followed by one or more hidden ones.

    The hidden lines are still present in the buffer, and most editing
    commands see them as usual, so you may find point in the middle of
    the hidden text. When this happens, the cursor appears at the end
    of the previous line, after the three dots. If the point is at the
    end of the visible line, before the newline that ends it, the
    cursor appears before the three dots.

    To make all lines visible again, use the command with no
    argument.
*** size-indication-mode                                :display:mode:inform:
    :PROPERTIES:
    :Description: Toggle Size Indication mode
    :Context:  anywhere
    :END:
*** column-number-mode                                  :display:mode:inform:
    :PROPERTIES:
    :Description: Toggle Column Number mode
    :Context:  anywhere
    :END:
*** display-time                                        :display:mode:inform:
    :PROPERTIES:
    :Description: Enable Display Time mode
    :Context:  anywhere
    :END:
*** display-time-mode                                   :display:mode:inform:
    :PROPERTIES:
    :Description: Toggle Display Time mode
    :Context:  anywhere
    :END:
*** display-battery-mode                                :display:mode:inform:
    :PROPERTIES:
    :Description: Toggle Display Battery mode
    :Context:  anywhere
    :END:
* Variable
** The Organization of the Screen
*** tty-menu-open-use-ttm                                              :menu:
    when invoking ~menu-bar-open~ invoke ~tmm-menubar~ instead.
** Entering Emacs
*** inhibit-startup-screen                                   :startup:buffer:
    If one or more files were specified on the command line, Emacs
    simply displays those files; otherwise, it displays a buffer named
    ~*scratch*~, which can be used to evaluate Emacs Lisp expressions
    interactively.
*** initial-buffer-choice                                    :startup:buffer:
    Force Emacs to display a file or directory at startup, according
    to filename, directory, or zero (0) argument Lisp Function that
    returns a buffer.
** Exiting Emacs
*** confirm-kill-emacs                                           :kill:frame:
    function to run before killing Emacs. If result of function is
    non-nil, the session is killed, otherwise Emacs continues to run.
*** confirm-kill-processes                                             :kill:
    If nil, does not ask for confirmation before killing sub-processes
    started by Emacs. ~t~ by default.
** Basic Editing Commands
*** read-quoted-char-radix                                        :edit:char:
    To use decimal or hexadecimal when running ~quoted-insert~
    command.
*** line-move-visual                                             :nav:window:
    You can force navigating up and down by line to move according to
    logical lines (i.e., according to the text lines in the buffer) by
    setting this variable to ~nil~.
*** track-eol                                                    :nav:buffer:
    When ~line-move-visual~ is nil, you can set this variable to a
    non-nil value. Then ~C-n~ and ~C-p~, when starting at the end of
    the logical line, move to the end of the next logical
    line. Default is ~nil~.
*** next-line-add-newlines                                  :nav:edit:buffer:
    If you set this variable to a non-nil value, C-n on the last line
    of a buffer creates an additional line at the end and moves down
    into it.
** The Minibuffer
*** minibuffer-eldef-shorten-default                    :buffer:display:echo:
    with a non-nil value, the default argument is displayed as
    ~[default-arg]~ instead of ~(default /default-arg/)~, saving some
    screen space.
*** insert-default-directory                            :buffer:display:echo:
    To prevent Emacs from inserting the default directory when reading
    file names, change this variable to ~nil~. Relative file name
    arguments are still interpreted based on the same default
    directory.
*** resize-mini-windows                                 :buffer:display:echo:
    There are three possible values
    - nil :: Do not resize minibuffer in Echo Area.
    - grow-only :: Grow minibuffer when there is enough text to be
      displayed on a new line. Do not ever shrink minibuffer
    - t :: Grow minibuffer when there is enough text to be displayed
      on a new line. Shrink when text can be displayed on fewer lines
*** max-mini-window-height                              :buffer:display:echo:
    This variable controls the maximum height for resizing the
    minibuffer window. A floating-point number specifies a fraction of
    the frame's height; an integer specifies the maximum number of
    lines; ~nil~ means do not resize the minibuffer window
    automatically. The default value is ~0.25~.
*** enable-recursive-minibuffers                        :buffer:command:echo:
    Emacs normally disallows most commands that use the minibuffer
    while the minibuffer is active. To allow such commands in the
    minibuffer, set this variable to ~t~.
*** confirm-nonexistent-file-or-buffer                  :buffer:command:echo:
    Changes behavior of "Permissive Completion with Confirmation"
    described in [[Completion Exit]]. Three possible values.
    - ~after-completion~ :: Default value. Behaves exactly as
      described in linked section.
    - ~nil~ :: No longer asks for confirmation. Same behavior as
      "Permissive Completion"
    - [other] :: Always asks for confirmation.
*** completion-styles                                         :list:complete:
    See current list and list options defined in:
    [[How Completion Alternatives Are Chosen]]
*** read-file-name-completion-ignore-case        :files:complete:buffer:echo:
    When completing file names, case differences are ignored if this
    variable is non-nil. The default value is nil on systems that have
    case-sensitive file-names, such as GNU/Linux; it is non-nil on
    systems that have case-insensitive file-names, such as Microsoft
    Windows.
*** read-buffer-completion-ignore-case                 :buffer:complete:echo:
    When completing buffer names, case differences are ignored if this
    variable is non-nil; the default is nil.
*** completion-ignored-extensions           :files:complete:list:buffer:echo:
    When completing file names, Emacs usually omits certain
    alternatives that are considered unlikely to be chosen, as
    determined by the values on this list variable. If /all/ possible
    completions end in otherwise-ignored strings, they are not
    ignored. Emacs disregards this variable when showing completion
    alternatives in the completion list.
*** completion-auto-help                  :complete:inform:helps:buffer:echo:
    If this variable is set to ~nil~, the completion commands never
    display the completion list buffer; you must type ~?~ to display
    the list. If the value is ~lazy~, Emacs only shows the completion
    list buffer on the second attempt to complete. In other words, if
    there is nothing to complete, the first <TAB> echos 'Next char not
    unique'; the second <TAB> shows the completion list buffer.
*** completion-cycle-threshold            :complete:inform:helps:buffer:echo:
    If this variable is non-nil, completion commands can cycle through
    completion alternatives. Normally when the variable is ~nil~, if
    there is more than one completion alternative for the text in the
    minibuffer, a completion command completes up to the longest
    common sub-string. If you change this variable to ~t~, the
    completion command instead completes to the first of those
    completion alternatives; each subsequent invocation of the
    completion command replaces that with the next completion
    alternative, in a cyclic manner. If you give this variable a
    number value /n/, completion commands switch to this cycling
    behavior only when there are /n/ or fewer alternatives.
*** history-length                                         :buffer:hist:echo:
    This variable specifies the maximum length of a minibuffer history
    list; adding a new element deletes the oldest element if the list
    gets too long. If the value is ~t~, there is no maximum length.
*** history-delete-duplicates                                          :hist:
    This variable specifies whether to delete duplicates in
    history. If it is non-nil, adding a new element deletes from the
    list all other elements that are equal to it. The default is
    ~nil~.
*** isearch-resume-in-command-history                          :command:hist:
    You can make incremental search commands appear in the history by
    setting this variable to a non-nil value.
*** command-history                                       :command:hist:list:
    The list of previous minibuffer-using commands is stored as a Lisp
    list in this variable.
** Running Commands by Name
*** suggest-key-bindings                                :inform:command:keys:
    When the command you run with ~M-x~ has a key binding, Emacs
    mentions this in the echo area after running the command. You can
    turn off these messages by setting this variable to ~nil~. The
    value can also be a number, in which case Emacs will show the
    binding for that many seconds before removing it from display. The
    default value is ~2~.
*** extended-command-suggest-shorter                         :inform:command:
    Commands that don't have key bindings can still be invoked after
    typing less than their full name at the ~M-x~ prompt. Emacs
    mentions such shorthands in the echo area if they are
    significantly shorter than the full command name, and this
    variable is non-nil. These suggestions won't get shown at all if
    [[suggest-key-bindings]] is ~nil~.
** Help
*** apropos-do-all                                           :search:command:
    If this variable is non-nil, most apropos commands behave as if
    they had been given a prefix argument. There is one exception:
    ~apropos-variable~ without a prefix argument will always search
    for all variables, no matter what the value of this variable is.
*** apropos-sort-by-scores                                   :search:display:
    If this variable is non-nil, apropos commands try to guess the
    relevance of each result, and display the most relevant ones
    first. This variable does not affect how ~apropos-documentation~
    is sorted.
*** apropos-documentation-sort-by-scores                     :search:display:
    To list the results of ~apropos-documentation~ in alphabetical
    order, change this variable to nil.
*** help-at-pt-display-when-idle                   :word:inform:display:echo:
    To display help text automatically whenever it is available at
    point, set this variable to t.
** The Mark and the Region
*** highlight-nonselected-windows                     :display:region:window:
    Ordinarily, only the selected window highlights its region;
    however, if this variable is non-nil, each window highlights its
    own region.
*** use-empty-active-region                                  :region:command:
    If you want region specific commands to perate on the empty
    region, change this variable to ~t~.
*** delete-active-region                            :region:edit:delete:kill:
    If you change this variable to ~nil~, then ~<DEL>~ and ~<Delete>~
    don't act differently when the mark is active. If you change the
    value to ~kill~, these commands kill the region instead of
    deleting it.
*** mark-even-if-inactive                                    :region:command:
    By default, if the mark is inactive, region only commands operate
    on the inactive region - that is, on the text between point and
    the position at which the mark was last set. To disable this
    behavior, change this variable to ~nil~. Then these commands will
    instead signal an error if the mark is inactive.
*** set-mark-command-repeat-pop                        :nav:region:keys:hist:
    If you set this variable to non-nil, then immediately after you
    type ~C-u C-<SPC>~, you can type ~C-<SPC>~ instead of
    ~C-u C-<SPC>~ to cycle through the mark ring. By default,
    ~set-mark-command-repeat-pop~ is ~nil~.
*** mark-ring-max                                               :region:hist:
    This variable specifies the maximum number of entries to keep in
    the mark ring. This defaults to 16 entries. If that many entries
    exist and another one is pushed, the earliest one in the list is
    discarded. Repeating ~C-u C-<SPC>~ cycles through the positions
    currently in the ring.
*** global-mark-ring-max                                        :region:hist:
    The length of the global mark ring is controlled by this variable,
    and is 16 by default.
*** shift-select-mode                                       :nav:region:mode:
    Variable determining whether or not Shift Select mode is active/on
    or not. To turn off set this variable to ~nil~.
** Killing and Moving Text
*** kill-whole-line                                        :kill:delete:line:
    If this variable is non-nil, ~C-k~ at the very beginning of a line
    kills the entire line including the following newline. The
    variable is normally ~nil~.
*** kill-read-only-ok                                                  :kill:
    Normally, using a kill command in a read only buffer causes Emacs
    to beep and display an error message, but if you set this variable
    to a non-nil value, they just print a message in the echo area to
    explain why the text has not been erased.
*** kill-do-not-save-duplicates                                   :kill:hist:
    If you change this variable to a non-nil value, identical
    subsequent kills yield a single kill-ring entry, without
    duplication.
*** kill-ring-max                                                 :kill:hist:
    The maximum number of entries in the kill ring is controlled by
    this variable. The default is 60.
*** kill-ring                                                     :kill:hist:
    The actual contents of the kill ring are stored in this variable.
*** x-select-request-type                                       :kill:coding:
    You can request a different data type to copy to clipboard by
    customizing this variable
*** save-interprogram-paste-before-kill                           :kill:hist:
    Optionally, you can change this variable to ~t~. Then Emacs will
    first save the clipboard to its kill ring before using a kill
    command, preventing you from losing the old clipboard data - at
    the risk of high memory consumption if that data turns out to be
    large.
*** yank-pop-change-selection                                     :kill:hist:
    Normally rotating the kill ring with ~M-y~ (~yank-pop~) does not
    alter the clipboard. However, if you change this variable to ~t~,
    then ~M-y~ saves the new yank to the clipboard.
*** select-enable-clipboard                                            :kill:
    To prevent kill and yank commands from accessing the clipboard,
    change this variable to ~nil~.
*** x-select-enable-clipboard-manager                                  :kill:
    If you exit Emacs while it is the current "owner" of the clipboard
    data, and there is a clipboard manager running, Emacs transfers
    the clipboard data to the clipboard manager so that it is not
    lost. In some circumstances, this may cause a delay when exiting
    Emacs; if you wish to prevent Emacs from transferring data to the
    clipboard manager, change this variable to ~nil~.
*** select-enable-clipboard                                            :kill:
    Non-nil means cutting and pasting uses the clipboard. This can be
    in addition to, but in preference to, the primary selection, if
    applicable.
*** select-enable-primary                                              :kill:
    Non-nil means cutting and pasting uses the primary selection. The
    existence of a primary selection depends on the underlying GUI you
    use. E.g. it doesn't exist under MS-Windows.
*** mouse-drag-copy-region                                      :kill:region:
    If non-nil, copy to kill-ring upon mouse adjustments of the
    region.
*** select-active-regions                                            :region:
    If you change this variable to ~only~, Emacs saves only temporarily
    active regions to the primary selection, i.e., those made with the
    mouse or with shift selection. If you change this variable to
    ~nil~, Emacs avoids saving active regions to the primary selection
    entirely.
*** mouse-yank-at-point                                                :edit:
    If this variable is non-nil, ~M-mouse-2~ yanks at point. Then it
    does not matter precisely where you click, or even which of the
    frame's windows you click on.
*** cua-enable-cua-keys                          :region:display:edit:delete:
    To disable the overriding of standard Emacs binding by CUA mode,
    while retaining the other features of CUA mode described in the
    mode, set this variable to ~nil~.
*** cua-delete-selection                                      :delete:region:
    To use CUA mode without activating Delete-Selection mode set this
    variable to ~nil~.
** Registers
*** register-preview-delay                     :register:command:echo:window:
    All commands that prompt for a register will display a preview
    window that lists the existing registers (if there are any) after
    a short delay. To change the length of the delay, customize this
    variable. To prevent this display, set this variable to ~nil~.
*** register-separator                                             :register:
    This variable stores which register should be considered the
    ~register-separator~ register and then will use the contents of
    this register to put in between text inserted into any other
    register using the commands either ~append-to-register~ or
    ~prepend-to-register~. By default the register ~+~ is used.

    When this variable is set to ~nil~ no extra text will be put in
    between text when using the previously mentioned commands.
*** bookmark-save-flag                                     :files:nav:buffer:
    If you set this variable to ~1~, each command that sets a bookmark
    will also save your bookmarks; this way, you don't lose any
    bookmark values even if Emacs crashes. The value, if a number,
    says how many bookmark modifications should go by between
    saving. If you set this variable to ~nil~, Emacs only saves
    bookmarks if you explicitly use ~bookmark-save~. Default value is
    ~t~ which means bookmarks save when Emacs is killed.
*** bookmark-default-file                                  :files:nav:buffer:
    The value of this variable specifies the file in which to save
    bookmarks by default.
*** bookmark-search-size                                    :buffer:hist:nav:
    This variable says how many characters of context to record on
    each side of the bookmark's position.
** Controlling the Display
*** next-screen-context-lines                                   :display:nav:
    The number of lines of overlap left by the commands
    ~scroll-up-command~ and ~scroll-down-command~ is controlled by
    this variable, whose default value is 2.
*** scroll-error-top-bottom                                     :display:nav:
    By default, the commands ~scroll-up-command~ and
    ~scroll-down-command~ signal an error (by beeping or flashing the
    screen) if no more scrolling is possible, because the window has
    reached the beginning or end of the buffer. If you change this
    variable to ~t~, these commands move point to the farthest
    possible position. If point is already there, the commands signal
    an error.
*** scroll-preserve-screen-position                             :display:nav:
    If the value is ~t~, Emacs adjusts point to keep the cursor at the
    same screen position whenever a scroll command moves it
    off-window, rather than moving it to the topmost or bottom-most
    line. With any other non-nil value, emacs adjusts point this way
    even if the scroll command leaves point in the window. This
    variable affects all scroll commands in the section named
    [[Controlling the Display]], as well as scrolling with the mouse
    wheel; in general, it affects any command that has a non-nil
    ~scroll-command~ property.
*** recenter-positions                      :list:window:display:nav:command:
    You can change the cycling order of the command
    ~recenter-top-bottom~ by customizing this list variable. Each list
    element should be the symbol ~top~, ~middle~, or ~bottom~, or a
    number; an integer means to move the line to the specified screen
    line, while a floating point number between 0.0 and 1.0 specifies
    a percentage of the screen space from the top of the window. The
    default, ~(middle top bottom)~, is the cycling order described in
    the documentation of ~recenter-top-bottom~.
*** scroll-margin                                        :window:display:nav:
    If you change this variable to a non-zero value /n/, then
    ~recenter-top-bottom~ always leaves at least /n/ screen lines
    between point and the top or bottom of the window.
*** recenter-redisplay                                       :display:window:
    If this variable has a non-nil value, each invocation of
    ~recenter-top-bottom~ also clears and redisplays the screen; The
    special value ~tty~ (the default) says to do this on text-terminal
    frames only.
*** scroll-conservatively                                    :display:window:
    If you set this variable to a small number /n/, then moving point
    just a little off screen (no more than /n/ lines) causes Emacs to
    scroll just enough to bring point back on screen; If doing so
    fails to make point visible, Emacs scrolls just far enough to
    center point in the window. If you set this variable to a large
    number (larger than 100), automatic scrolling never centers point,
    no matter how far point moves; Emacs always scrolls text just
    enough to bring point into view, either at the top or bottom of
    the window depending on the scroll direction. By default, the
    variable is 0, which means to always center point in the window.
*** scroll-step                                              :display:window:
    The value of this valuable determines the number of lines by which
    to automatically scroll, when point moves off the screen. If
    scrolling by that number of lines fails to bring point back into
    view, point is centered instead. The default value is zero, which
    (by default) causes point to always be centered after scrolling.
*** scroll-up-aggressively                                   :display:window:
    This variable directly specifies the vertical position of point
    after scrolling. The value of this variable should be either ~nil~
    (the default), or a floating point number /f/ between 0 and 1. The
    latter means that when point goes below the bottom window edge
    (i.e., scrolling forward), Emacs scrolls the window so that point
    is /f/ parts of the window height from the bottom window
    edge. Thus, larger /f/ means more aggressive scrolling: more new
    text is brought into view. The default value, ~nil~, is equivalent
    to 0.5.
*** scroll-down-aggressively                                 :display:window:
    This variable directly specifies the vertical position of point
    after scrolling. The value of this variable should be either ~nil~
    (the default), or a floating point number /f/ between 0 and 1. The
    latter means that when point goes above the top window edge (i.e.,
    scrolling backward), Emacs scrolls the window so that point is /f/
    parts of the window height from the top window edge. This, larger
    /f/ means more aggressive scrolling: more new text is brought into
    view. The default value, ~nil~, is equivalent to 0.5.
*** scroll-margin                                            :display:window:
    This variable restricts how close point can come to the top of
    bottom of a window (even if aggressive scrolling specifies a
    fraction /f/ that is larger than the window portion between the
    top and bottom margins). It's value is a number of screen lines;
    If point comes within that many lines of the top or bottom of the
    window, Emacs performs automatic scrolling. By default, this
    variable is 0. The effective margin size is limited to a quarter
    of the window height by default.
*** maximum-scroll-margin                                    :display:window:
    The effective margin size is limited to a quarter of the window
    height by default, but this limit can be increased up to half (or
    decreased down to zero) by customizing this variable.
*** auto-hscroll-mode                                        :display:window:
    By default, all the lines in the window are scrolled horizontally
    together, but if you set this variable to the special value of
    ~current-line~, only the line showing the cursor will be
    scrolled. To disable automatic horizontal scrolling entirely, set
    this variable to ~nil~. Note that when the automatic horizontal
    scrolling is turned off, if point moves off the edge of the
    screen, the cursor disappears to indicate that. (On text
    terminals, the cursor is left at the edge instead.)
*** hscroll-margin                                           :display:window:
    This variable controlls how close point can get to the window's
    left and right edges before automatic scrolling occurs. It is
    measured in columns. For example, if the value is 5, then moving
    point within 5 columns of an edge causes horizontal scrolling away
    from that edge.
*** hscroll-step                                             :display:window:
    This variable determines how many columns to scroll the window
    when point gets too close to the edge. Zero, the default value,
    means to center point horizontally within the window. A positive
    integer value specifies the number of columns to scroll by. A
    floating-point number (whose value should be between 0 and 1)
    specifies the fraction of the window's width to scroll by.
*** frame-background-mode                                      :display:char:
    By default, Emacs automatically chooses which set of face
    attributes to display on each frame, based on the frame's current
    background color. However you can override this by giving this
    variable a non-nil value. A value of ~dark~ makes Emacs treat all
    frames as if they have a dark background, whereas a value of
    ~light~ makes it treat all frames as if they have a light
    background.
*** list-colors-sort                                   :display:helps:window:
    To control the order in which colors are shown with the command
    ~list-colors-display~, customize this variable.
*** text-scale-mode-step                                            :display:
    Each call to ~text-scale-adjust~ scales the text height by a
    factor of 1.2; to change this factor, customize this variable.
*** global-font-lock-mode                       :buffer:display:mode:startup:
    To impose the setting where Font Lock mode is either enabled or
    disabled in all buffers for future Emacs sessions, customize this
    variable.
*** font-lock-maximum-decoration                               :display:mode:
    You can customize this variable to alter the amount of
    fontification applied by Font Lock mode, for major modes that
    support this feature, the value should be a number (with 1
    representing a minimal amount of fontification; some modes support
    levels as high as 3); or ~t~, meaning "as high as possible" (the
    default). To be effective for a given file buffer, the
    customization of the variable ~font-lock-maximum-decoration~
    should be done /before/ the file is visited; if you already have a
    file visited in a buffer when you customize this variable, kill
    the buffer and visit the file again after the customization.

    You can also specify different numbers for particular major modes;
    for example, to use level 1 for C/C++ modes, and the default level
    otherwise, use the value ~'((c-mode . 1) (c++-mode . 1))~
*** hi-lock-auto-select-face                           :echo:command:display:
    Setting this variable to a non-nil value causes the command
    ~highlight-regexp~ (and other Hi Lock commands that read faces) to
    automatically choose the next face from the default list without
    prompting.
*** fringe-mode                                   :window:frame:mode:display:
    You can make your changes to the fringes permanent by customizing
    this variable. Such as setting the width of the fringes.
*** overflow-newline-into-fringe                             :display:window:
    By default set to a non nil value. This means if the current line
    is exactly as wide as the window and point is at the end of the
    line then the fringe will draw the cursor. To disable this, change
    this variable to ~nil~; this causes Emacs to continue or truncate
    lines that are exactly as wide as the window.
*** display-fill-column-indicator                     :display:window:buffer:
    This is a buffer-local variable used to activate the fill column
    indicator.
*** display-fill-column-indicator-character      :display:window:buffer:char:
    This is a buffer-local variable used to control how the fill
    column indicator looks.
*** display-fill-column-indicator-column              :display:window:buffer:
    Specifies the column number where the indicator should be set. It
    can take positive numerical values for the column or the special
    value ~t~ which means that the variable ~fill-column~ will be
    used.

    Any other value disables the indicator. The default value is ~t~.
*** indicate-buffer-boundaries                                :display:frame:
    This is a buffer-local variable that controls how the buffer
    boundaries and window scrolling is indicated in the fringes. If
    the value is ~left~ or ~right~, both angle and arrow bitmaps are
    displayed in the left or right fringe, respectively.

    If value is an alist, each element ~(/indicator/ . /position/)~
    specifies the position of one of the indicators. The /indicator/
    must be one of ~top~, ~bottom~, ~up~, ~down~, or ~t~ which
    specifies the default position for the indicators not present in
    the alist. The /position/ is one of ~left~, ~right~, or ~nil~
    which specifies not to show this indicator.

    For example, ~((top . left) (t . right))~ places the top angle
    bitmap in left fringe, the bottom angle bitmap in right fringe,
    and both arrow bitmaps in right fringe. To show just the angle
    bitmaps in the left fringe, but no arrow bitmaps, use ~((top
    . left) (bottom . left))~.
*** show-trailing-whitespace                                        :display:
    You can make trailing whitespace at the end of a line visible by
    setting this buffer-local variable to ~t~.

    This feature does not apply when point is at the end of the line
    containing the whitespace. Strictly speaking, that is trailing
    whitespace nonetheless, but displaying it specially in that case
    looks ugly while you are typing in new text. In this special case,
    the location of point is enough to show you that the spaces are
    present.
*** delete-trailing-lines                               :edit:command:buffer:
    Normally when using the command ~delete-trailing-whitespace~ the
    command deletes all extra space at the end of each line in the
    buffer, and all empty lines at the end of the buffer; to ignore
    the latter, change this variable to ~nil~.
*** indicate-empty-lines                              :display:window:buffer:
    On graphical displays, Emacs can indicate unused lines at the end
    of the window with a small image in the left fringe. The image
    appears for screen lines that do not correspond to any buffer
    text, so blank lines at the end of the buffer stand out because
    they lack this image. To enable this feature, set this
    buffer-local variable to a non-nil value.
*** whitespace-style                                    :display:buffer:list:
    When Whitespace mode is enabled, the kinds of whitespace
    visualized are determined by this list variable.
*** whitespace-line-column                                   :display:buffer:
    When highlighting ~lines~ in Whitespace mode, customize this
    variable to change the column limit that determines which lines to
    highlight.
*** whitespace-big-indent-regexp                             :display:buffer:
    When highlighting ~big-indent~ customize this regular expression
    to change when to highlight a big indent at the start of a line.
*** selective-display-ellipses                          :display:buffer:line:
    If you set this variable to ~nil~, when you have hidden lines
    using the command ~set-selective-display~, then the three dots do
    not appear at the end of a line that precedes hidden lines. There
    is no visible indication of the hidden lines. This variable
    becomes local automatically when set.
*** column-number-indicator-zero-based                       :display:inform:
    When Column Number mode is enabled, if you would prefer for the
    displayed column number to count from one, you may set this
    variable to ~nil~.
*** line-number-display-limit                           :line:display:inform:
    When the number of characters in a file is larger than the integer
    in this variable the mode line stops trying to compute the line
    number in a file. To remove this limit, set this variable to
    ~nil~.
*** line-number-display-limit-width                     :line:display:inform:
    Line-number computation can also be slow if the lines in the
    buffer are too long. For this reason, Emacs doesn't display line
    numbers if the average width, in characters, of lines near point
    is larger than the value of this variable. The default value is
    200 characters.
*** display-time-24hr-format                                 :display:inform:
    If you have Display Time mode enabled and what the time to appear
    in 24 hour mode, set this variable to ~t~.
*** display-time-use-mail-icon                               :display:inform:
    If you have Display Time mode enabled, and you want the mail
    indicator to be an icon instead of the word '~Mail~', then you can
    customize this variable
*** display-time-mail-file                             :display:inform:files:
    Use this variable to specify the mail file to check when Display
    Time mode is enabled.
*** display-time-mail-directory                        :display:inform:files:
    Use this variable to specify the directory to check for incoming
    mail (any nonempty regular file in the directory is considered to
    be newly arrived mail).
*** display-battery-mode                                :display:inform:mode:
    Set whether Display Battery mode is enabled or not using this
    mode.
*** battery-mode-line-format                                 :display:inform:
    This variable determines the way the battery charge is displayed;
    the exact mode-line message depends on the operating system, and
    it usually shows the current battery charge as a percentage of the
    total charge.
*** mode-line-in-non-selected-windows                               :display:
    You can disable use of the ~mode-line-inactive~ face by setting
    this variable to ~nil~; then all mode lines are displayed in the
    ~mode-line~ face.
*** eol-mnemonic-unix                                          :display:char:
    This variable determines what character is used to indicate in the
    mode line whether the current file uses a unix style end of line
    encoding.
*** eol-mnemonic-mac                                           :display:char:
    This variable determines what character is used to indicate in the
    mode line whether the current file uses a mac style end of line
    encoding.
*** eol-mnemonic-undecided                                     :display:char:
    This variable determines what character is used to indicate in the
    mode line whether the current file uses a undecided style end of
    line encoding.
*** tab-width                                                  :display:char:
    The number of spaces per tab is controlled by this buffer-local
    variable, which must have an integer value between 1 and 1000,
    inclusive.
*** ctl-arrow                                           :display:char:coding:
    If you change this buffer-local variable to ~nil~, the ASCII
    control characters are also displayed as octal escape sequences
    instead of caret escape sequences.
*** nobreak-char-display                                :display:char:coding:
    By default Emacs will make it so that any character that looks
    like an ordinary ASCII space or hyphen, but is not coded as such
    is assigned a special face (~nobreak-space~ and ~nobreak-hyphen~
    respectively). To disable this, change this variable to ~nil~. If
    you give this variable a non-nil, and non-t value, Emacs instead
    displays such characters as a highlighted backslash followed by a
    space or hyphen.
*** glyphless-char-display-control                      :display:char:coding:
    Glyphless characters are normally displayed as boxes containing
    the hexadecimal character code or, on text terminals as question
    signs. You can control the display method by customizing this
    variable.
*** text-quoting-style                                         :display:char:
    Normally, if Emacs can display the curved quotes '~‘~' and '~’~'
    then it will translate the ASCII quotes ('~`~' and '~'~'), when
    they appear in messages and help texts, to these curved
    quotes. You can influence or inhibit this translation by
    customizing this variable.
* Context
** anywhere
   literally anywhere
** editing
   when editing a buffer
** navigating
   When in a buffer that is possible to navigate with the standard
   ~C-f~, ~C-b~, ~C-n~, ~C-p~ commands
** minibuffer
   when in the minibuffer
** completion-buffer
   when in the window with current completion options
** password
   when typing in a password for minibuffer
   [[Entering passwords]]
** yes-no
   when echo prompt ends with ~(y or n)~
   [[Yes or No Prompts]]
** help
   Window that appears below buffer with some contents of a help
   buffer. One such help window is activated with [[help-for-help]]
** info
   The documentation browser. Able to read just every possible
   documentation imaginable.
** special-text
   When one location inside text might behave differently from the
   rest of the text. For example, links in *Help* buffers. Seems to
   mostly be for links or clickable locations in text.
** rectangle
   When Rectangle Mark mode is enabled and therefore an active region
   is highlighted as a rectangle.
** cua
   CUA mode which sets up key bindings that are compatible with the
   Common User Access (CUA) system used in many other applications.
** cua-rectangle
   The enhanced rectangle selection mode provided by cua. Check out
   CUA Rectangle Mark mode
** register
   When there is a prompt for a register in the minibuffer
** bookmark
   Bookmark Menu mode
** view
   View mode
** follow-ready
   A frame is ready for Follow mode when a frame contains two windows
   side by side with the same buffer in both windows.
** mini-select-list
   Some commands have an option for selecting something from a list
   including faces, previous commands, etc. to complete the
   command. This context is when you are at the point in the command
   where the minibuffer is asking you to provide one of these options
   from a particular list.
* Faces
** The Minibuffer
*** minibuffer-prompt
    When the minibuffer is in use, it appears in the echo area, with a
    cursor. The minibuffer starts with a /prompt/, usually ending with
    a colon. The prompt states what kind of input is expected, and how
    it will be used. The prompt is highlighting using this face.
** The Mark and the Region
*** region
    Setting the mark at a position in the text /activates/ it. When
    the mark is active, we say that the region is active; Emacs
    indicates its extent by highlighting the text within it, using
    this face.
** Killing and Moving Text
*** secondary-selection
    When using ~mouse-set-secondary~ the selected text is highlighted,
    using this face as you drag.
** Controlling the Display
*** standard faces
**** default
     This face is used for ordinary text that doesn't specify any
     face. Its background color is used as the frame's background
     color.
**** bold
     This face uses bold variant of the default font.
**** italic
     This face uses an italic variant of the default font.
**** bold-italic
     This face uses a bold italic variant of the default font.
**** underline
     This face underlines text.
**** fixed-pitch
     This face forces use of a fixed-width font. It's reasonable to
     customize this face to use a different fixed-width font, if you
     like, but you should not make it a variable-width font.
**** fixed-pitch-serif
     This face is like ~fixed-pitch~, except the font has serifs and
     looks more like traditional typewriting.
**** variable-pitch
     This face forces use of a variable-width font.
**** shadow
     This face is used for making the text less noticeable than the
     surrounding ordinary text. Usually this can be achieved by using
     shades of grey in contrast with either black or white default
     foreground color.
*** highlight faces
**** highlight
     This face is used for text highlighting in various contexts, such
     as when the mouse cursor is moved over a hyperlink.
**** isearch
     The face is used to highlight the current Isearch match
**** query-replace
     This face is used to highlight the current Query Replace match
**** lazy-highlight
     This face is used to highlight lazy matches for Isearch and Query
     Replace (matches other than the current one).
**** region
     This face is used for displaying an active region. When Emacs is
     built with GTK+ support, its colors are taken from the current
     GTK+ theme.
**** secondary-selection
     This face is used for displaying a secondary X selection.
**** trailing-whitespace
     The face for highlighting excess spaces and tabs at the end of a
     line when ~show-trailing-whitespace~ is non-nil.
**** escape-glyph
     The face for displaying control characters and escape sequences.
**** homoglyph
     The face for displaying lookalike characters, i.e., characters
     that look like but are not the characters being represented.
**** nobreak-space
     The face for displaying no-break space characters.
**** nobreak-hyphen
     The face for displaying no-break hyphen characters
*** frame faces
**** mode-line
     This faces is used for the mode line of the currently selected
     window, and for menu bars when toolkit menus are not used. By
     default, it's drawn with shadows for a raised effect on graphical
     displays, and drawn as the inverse of the default face on
     non-windowed terminals.
**** mode-line-inactive
     Like ~mode-line~, but used for mode lines of the windows other
     than the selected one (if ~mode-line-in-non-selected-windows~ is
     non-nil). This face inherits from ~mode-line~, so changes in that
     face affect mode lines in all windows.
**** mode-line-highlight
     Like ~highlight~, but used for mouse-sensitive portions of text
     on mode lines. Such portions of text typically pop up tooltips
     when the mouse pointer hovers above them.
**** mode-line-buffer-id
     This face is used for buffer identification parts in the mode
     line.
**** header-line
     Similar to ~mode-line~ for a window's header line, which appears
     at the top of a window just as the mode line appears at the
     bottom. Most windows do not have a header line - only some
     special modes, such as Info mode, create one.
**** header-line-highlight
     Similar to ~highlight~ and ~mode-line-highlight~, but used for
     mouse sensitive portions of text on header lines. This is a
     separate face because the ~header-line~ face might be customized
     in a way that does not interact well with ~highlight~.
**** vertical-border
     This face is used for the vertical divider between windows on
     text terminals.
**** minibuffer-prompt
     This face is used for the prompt strings displayed in the
     minibuffer. By default, Emacs automatically adds this face to the
     value of ~minibuffer-prompt-properties~, which is a list of text
     properties used to display the prompt text. (This variable takes
     effect when you enter the minibuffer.)
**** fringe
     The face for the fringes to the left and right of windows on
     graphic displays. (The fringes are the narrow portions of the
     Emacs frame between the text area and the window's right and left
     borders.)
**** cursor
     The ~:background~ attribute of this face specifies the color of
     the text cursor.
**** tooltip
     This face is used for tooltip text. By default, if Emacs is built
     with GTK+ support, tooltips are drawn via GTK+ and this face has
     no effect.
**** mouse
     This face determines the color of the mouse pointer.
*** text frame faces
**** scroll-bar
     This face determines the visual appearance of the scroll bar.
**** tool-bar
     This face determines the color of tool bar icons.
**** menu
     This face determines the colors and font of Emacs's menus.
**** tty-menu-enabled-face
     This face is used to display enabled menu item on text-mode
     terminals.
**** tty-menu-disabled-face
     This face is used to display disabled menu items on text-mode
     terminals.
**** tty-menu-selected-face
     This face is used to display on text-mode terminals the menu item
     that would be selected if you click a mouse or press ~<RET>~.
*** other faces
**** font-lock-string-face
     Face for how to display strings in font lock mode.
**** font-lock-comment-face
     Face for how to display comments in font lock mode.
**** fill-column-indicator
     Specifies the face used to display the indicator. It inherits its
     default values from the face ~shadow~ but without background
     color. To change the indicator color you need only set the
     foreground color of this face.
**** trailing-whitespace
     This is the face used to display trailing whitespace when
     ~show-trailing-whitespace~ is set to ~t~.
**** display-time-mail-face
     Face used to customize how prominent the mail indicator is when
     Display Time mode is enabled.
**** mode-line
     On graphical displays, the mode line is drawn as a 3D box. If you
     don't like this effect, you can disable it by customizing this
     face and setting the ~box~ attribute to ~nil~.

     This is the face specifically for the mode-line of the active
     window.
**** mode-line-inactive
     The mode line of nonselected windows is displayed in this face.
**** escape-glyph
     This face is used to display some control characters when one
     needs to display a control character explicitly. Known example
     are all control characters whose codes are below ~U+0020~ and are
     also not ~U+000A~ nor ~U+0009~ since those are the newline
     character and tab character respectively and are displayed
     specially. For instance the '~control-A~' character, ~U+0001~,
     would be displayed as '~^A~' in this face.
**** nobreak-space
     A special face specifically for all characters that may look
     exactly like an ASCII space, but are not coded as an ASCII
     space. This is for characters like ~U+00A0~ (no-break space).
**** nobreak-hyphen
     A special face specifically for all characters that may look
     exactly like an ASCII hyphen, but are not coded as an ASCII
     hyphen. This is for characters like ~U+00AD~ (soft hyphen),
     ~U+2010~ (hyphen), and ~U+2011~ (non-breaking hyphen).
**** glyphless-char
     The face applied to all characters that cannot find a glyph in
     any available font.
**** homoglyph
     This face is used when two different character codes map to the
     same looking glyph.
* .emacs addition
** Registers
*** Saving Text in Registers
    If you always want to use a register separator in all buffers you
    can use the following setting.

    #+BEGIN_SRC emacs-lisp
    (setq register-separator ?+)
    (set-register register-separator "\n\n")
    #+END_SRC

*** Keeping File Names in Registers
    Generic lisp code for storing a file name in a particular
    register.

    #+BEGIN_SRC emacs-lisp
    (set-register c '(file . name))
    #+END_SRC

    Example code
    #+BEGIN_SRC emacs-lisp
    (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))
    #+END_SRC
    puts the file name shown into register 'z'.
** Controlling the Display
*** Font Lock mode
    To impose the setting to disable Font Lock mode in all buffers for
    future Emacs sessions, add the following line to your init file:

    #+BEGIN_SRC emacs-lisp
    (global-font-lock-mode 0)
    #+END_SRC

    If you have disabled Global Font Lock mode, you can still enable
    Font Lock for specific major modes by adding the function
    ~font-lock-mode~ to the mode hooks. For example, to enable Font
    Lock mode for editing C files, you can do this:

    #+BEGIN_SRC emacs-lisp
    (add-hook 'c-mode-hook 'font-lock-mode)
    #+END_SRC

    Font Lock highlighting patterns already exist for most modes, but
    you may want to fontify additional patterns. You can use the
    function ~font-lock-add-keywords~, to add your own highlighting
    patterns for a particular mode. For example, to highlight
    '~FIXME:~' words in C comments, use this:

    #+BEGIN_SRC emacs-lisp
    (add-hook 'c-mode-hook
              (lambda ()
	       (font-lock-add-keywords nil
	        '(("\\<\\(FIXME\\):" 1
		   font-lock-warning-face t)))))
    #+END_SRC

    To remove keywords from the font-lock highlighting patterns, use
    the function ~font-lock-remove-keywords~.
*** Interactive Highlighting
    To enable Hi Lock mode for all buffers, place

    #+BEGIN_SRC emacs-lisp
    (global-hi-lock-mode 1)
    #+END_SRC

*** Displaying Boundaries
    Emacs can add an indicator to display a fell column position. It
    is possible to use the following addition to activate the
    indicator in a hook:

    #+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook 'display-fill-column-indicator-mode)
    #+END_SRC

    And the following addition to enable it globally.
    #+BEGIN_SRC emacs-lisp
    (global-display-fill-column-indicator-mode 1)
    #+END_SRC

*** Useless Whitespace
    On graphical displays, Emacs can indicate unused lines at the end
    of the window with a small image in the left fringe. The image
    appears for screen lines that do not correspond to any buffer
    text, so blank lines at the end of the buffer stand out because
    they lack this image. You can enable or disable this feature for
    all new buffers by setting the default value for this variable:

    #+BEGIN_SRC emacs-lisp
    (setq-default indicate-empty-lines t)
    #+END_SRC

* Niche Modes
** Bookmark Menu
*** Description
    Use this buffer to edit bookmark definitions or annotate the
    bookmarks.
*** Enter Mode
    ~C-x r l~
*** Find Commands
    ~C-h m~
* Notes
** Undo
   There are a few ways someone can break a sweat in Emacs and wonder
   what has gone wrong. My experience has told me that Emacs does not
   immediately make it obvious how to undo each of these scenarios. It
   is important to understand each one.
*** My screen looks entirely different than what I had been working on
    In this case it is likely that the user "switched buffers". You
    can think of buffers as like different tabs in a browser. Emacs
    has different tabs too that can hold different content that you
    are working on. Likely you accidentally switched tabs (buffers)
    without realizing it. Switching back to what you were working on
    is simple. You can hit the keys ~C-x b <RET>~ and it should bring
    you back to the tab (buffer) you were working in. If you are
    nervous about keyboard shortcuts, likely you are using a version
    of Emacs that should have a menu at the top. One of the menu items
    should say /Buffers/. Click on this menu item and you can see all
    the open tabs. There are some tabs that are always available by
    default like the /GNU Emacs/ welcome screen, or a space that
    serves as essentially /scratch/ paper. Emacs requires that you
    name each file that you work on, so you should find the name of
    that file in this list of tabs (buffers). Try to think of this
    separation of work as buffers though as it makes memorizing the
    shortcut keys easier. In this case ~C-x~ is the command for what I
    think of as e-*x*-tra commands, and then when I hit the key ~b~
    I'm indicating I want to switch buffers. You can type the buffer
    name explicitly, but normally when you switch away from a buffer,
    just hitting enter will return you to the buffer you just left.
*** My cursor isn't returning to the spot I was working on
    Likely your cursor is at the bottom of the screen in what is
    called the /Echo Area/. Your cursor gets moved here when you are
    in the middle of an instruction to Emacs. If you did not intend to
    tell Emacs anything, there are two methods to escaping this
    area. One is ~C-g~. This is often a universal way to escape a
    command. It is very helpful. I have found every once in a while
    this method does not work in which case the command ~<ESC> <ESC>
    <ESC>~ normally does the trick for me. Please note that it is best
    practice after hitting ~<ESC> <ESC> <ESC>~ to then type
    ~C-g~. This avoids unintended effects due to quirks in Emacs
    commands.

    The ~<ESC>~ key can sometimes double as the ~<META>~ key if your
    computer is missing an ~<ALT>~ key or a keybinding in Emacs is
    overridden by your computer. Sometimes when you are nervous it's
    easy to just keep hitting ~<ESC>~ until the problem in Emacs is
    finished. If you hit ~<ESC>~ four (4) times, there's a possibility
    the next key you hit will be interpreted as being tied to a meta
    command. For example, ~<ESC> q~ will wrap text according to your
    preferences (or preset preferences). For this reason, if you hit
    ~C-g~ after hitting ~<ESC> <ESC> <ESC>~ you are less likely to
    have unintended consequences.
*** My Emacs screen appears to be split in half
    Each part of the screen is called a /window/. This can be
    confusing for new users since we are used to a window being
    whatever we can minimize in our operating system. The thing to
    keep in mind is that Emacs has been around for a long time, back
    when computers were only text. It used to be that what you see in
    the Emacs frame was the entire screen of old computers. This is
    why the word /window/ was used, and for consistency has not been
    changed. There are two commands I use most to make it so there is
    only one window, and it is the window I care about. The first is
    ~C-x o~. This moves my cursor from window to window. I use this
    until I see my cursor blinking in the window I care about. Once
    the cursor is in the window I care about, I use the command ~C-x
    1~. This is essentially saying "I want one (1) window, and I want
    it to be the active window."
*** I made a sudden huge edit I did not mean to make
    This is the normal way we think of undo! This command is fairly
    straight forward, but I have found the Emacs documentation doesn't
    make it easy to find. The command is ~C-/~.
*** My screen looks like a long list, I can't type, what's happening?
    Sometimes Emacs switches into a special mode without making it
    clear. If your screen looks like a long list do not type. So far
    there have been two keys in these scenarios that appear to be
    fairly universal regardless of the specific mode you have found
    yourself in. ~h~ will bring up a small help window, and ~q~ will
    quit the mode. Emacs and Emacs manuals do a terrible job
    telegraphing this information to the user.
** Language
   There are times when first reading an Emacs manual, you will run
   into language that you don't understand because Emacs hasn't
   defined it yet. In an attempt to make this easier on people here is
   some of the language Emacs forgets is new for lots of people
*** customize the variable
    Emacs has so much customizability. Basically anything in Emacs you
    can imagine is possible to customize. This means that Emacs makes
    a lot of assumptions for you when you start up Emacs. Each
    assumption is held in a value called a /Variable/. If you want to
    change one of the assumptions that Emacs has made for you, then
    you need to change the value of the associated variable. This is
    what Emacs means when they say "customize the variable". They are
    saying "You can change the set of assumptions we made".

    TODO: How do you actually make those changes.
** Emacs manual
   On my Ubuntu computer, when I installed Emacs, the official Emacs
   manual was not included for some strange reason. I needed to
   install the package ~emacs-common-non-dfsg~ for Emacs 26 and up
   onto my computer from the command line (it's a Linux package, not
   an Emacs package).
