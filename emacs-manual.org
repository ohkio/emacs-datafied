* Manual
** Distribution
** Introduction
** The Organization of the Screen
   Goes through an overview of
   - Frame :: The Graphical window or entire terminal running Emacs.
   - Menu Bar :: Organization of various commands and instructions in
                 Emacs's.
   - Tool Bar :: Only appears when running Emacs in a graphical
                 display. List of shortcuts to common commands.
   - Echo Area :: Where informative messages are displayed and where
                  you enter information when Emacs asks for it.
   - Window :: Area of editing below the tool bar (if one exists) and
               above the echo area.
   - Buffer :: the text or other graphics you are editing or viewing.
   - Mode Line :: This displays various information about what is
                  going on in the buffer.
*** Point
    Basically the cursor. Comes from ~.~ which was the original
    command for accessing the editing position way back when.
*** The Echo Area
    Detailed explanation of stuff.
    - Minibuffer :: a special window where you can input arguments to
                    commands within the [[Echo Area]]
*** The Mode Line
    #+BEGIN_SRC
    cs:ch-fr  buf     pos line   (major minor)
    #+END_SRC
    Explanation:
    - ~cs~ :: Character Set. Depends on the encoding of the document
    - ~:~ :: Changes depending on the newline convention.
      - ~:~ or ~Unix~ :: Lines end in newline character
      - ~\~ or ~DOS~ :: Lines end in carriage return, linefeed
      - ~/~ or ~Mac~ :: Lines end in carriage return
      - ~@~ :: When the frame was created for ~emacsclient~
    - ~ch~ :: Status of buffer
      - ~--~ :: Buffer is unchanged from file
      - ~**~ :: Buffer is modified from file
      - ~%%~ :: Unmodified read only buffer
      - ~%*~ :: Modified read only buffer
    - ~-~ :: Location of file for current buffer
      - ~-~ :: Local file
      - ~@~ :: Remote file
    - ~fr~ :: Name of selected frame. Only relevant for text terminals
      - ~F1~ :: Name of initial frame
    - ~buf~ :: Name of buffer. Normally the file name.
    - ~pos~ :: Indicates whether there is additional text above the
      top of the window or below the bottom.
      - ~All~ :: The entire buffer is visible in the window
      - ~Top~ :: You are looking at the beginning of the buffer
      - ~Bot~ :: You are looking at the end of the buffer
      - ~nn%~ :: This means /nn/ is the percentage of the buffer above
        the top of the window.
    - ~line~ :: the character ~L~ followed by the line number at
      point.
    - ~major~ :: Name of the major mode used in the buffer.
    - ~minor~ :: A list of some of the enabled minor modes, or
      relevant features.
      - ~Narrow~ :: Buffer being displayed has editing restricted to
        only a portion of it's text.
      - ~Def~ :: A keyboard macro is currently being defined.
    - ~(...)~ :: If Emacs is inside a recursive editing level, square
      brackets ~[...]~ appear around the parentheses that surround
      the modes

    Extra Functionality:
    - Hovering around the mode line shows tool tips.
    - Clicking on different parts of the mode line performs various
      commands

    Words and concepts defined or mentioned:
    - Major Mode :: the principal editing mode for a given buffer.
    - Minor Mode :: Optional editing modes that provide additional
      features on top of the major mode.
    - Narrowing :: When you restrict editing to only a portion of
      buffer.
    - Keyboard Macro :: Mentioned not defined
    - Recursive Edit :: Mentioned not defined
    - Tooltips :: Mentioned not defined
*** The Menu Bar
    Some interesting details about the menu bar.

    Mentions the concept:
    - Variable
** Kinds of User Input
   Some Syntax
   - <SPC> :: The space-bar
   - <RET> :: The Return or Enter key
   - <TAB> :: The Tab key
   - <DEL> :: The Delete key
   - <ESC> :: The Esc or Escape key
   - <F1> :: The F1 or first function key
   - <Home> :: The Home key
   - <LEFT> :: The Left Arrow key
   - <Control> or <Ctrl> :: The Control or Ctrl key (not different
                            keys)
   - <Meta> :: The Meta or Alt key
   - ~Control-a~ or ~C-a~ :: Holding down the <Ctrl> key while
     pressing ~a~
   - ~<Meta>-a~ or ~M-a~ :: Holding down the <Alt> key while pressing
     ~a~
   - ~C-M-a~ :: Holding down <Ctrl> and <Alt> while pressing ~a~

   These commands might be blocked by the OS
   - ~M-<TAB>~
   - ~M-<SPC>~
   - ~C-M-d~
   - ~C-M-l~
** Keys
   Definitions:
   - Key Sequence or Key :: A sequence of one or more input events
     that is meaningful as a unit.
     - Complete Key :: A Key Sequence that invokes a command
     - Prefix Key :: A Key Sequence that isn't long enough to invoke a
       command

   All Key Sequences are either Complete Keys or Prefix Keys.

   These are the default Prefix Keys
   - ~C-c~
   - ~C-h~ or ~<F1>~
   - ~C-x~
   - ~C-x <RET>~
   - ~C-x @~
   - ~C-x a~
   - ~C-x n~
   - ~C-x r~
   - ~C-x v~
   - ~C-x 4~
   - ~C-x 5~
   - ~C-x 6~ or ~<F2>~
   - ~<ESC>~
   - ~M-g~
   - ~M-o~
** Keys and Commands
   Definitions
   - Command :: a name used to store an action to perform in Emacs
   - Function :: Not defined, but mentioned
   - Keymaps :: Not defined, but mentioned
   - Variable :: a name used to store a value
** Entering Emacs
   Start Emacs from the shell.
   #+BEGIN_SRC sh
   emacs
   #+END_SRC

   Run Emacs in the background of a terminal to continue to use the
   terminal.
   #+BEGIN_SRC sh
   emacs &
   #+END_SRC

   Open ~foo.txt~ in Emacs
   #+BEGIN_SRC sh
   emacs foo.txt
   #+END_SRC

   Vocabulary mentioned or defined
   - Kill Ring :: Not defined but mentioned
   - Registers :: Not defined but mentioned
   - Undo History :: Not defined but mentioned
   - Mark Ring :: Not defined but mentioned
** Exiting Emacs
** Basic Editing Commands
*** Inserting Text
*** Changing the Location of Point
*** Erasing Text
*** Undoing Changes
*** Files
*** Help
*** Blank Lines
*** Continuation Lines
*** Cursor Position Information
*** Numeric Arguments
    Examples
    #+BEGIN_SRC
    M-5 C-n
    #+END_SRC
    Move down five (5) lines.

    #+BEGIN_SRC
    M-- C-n
    #+END_SRC
    Move up one (1) line.

    #+BEGIN_SRC
    M-- 3 C-n
    #+END_SRC
    Move up three (3) lines

    #+BEGIN_SRC
    M-5 0 C-n
    #+END_SRC
    Move down fifty (50) lines.

    #+BEGIN_SRC
    M-5 C-u 0
    #+END_SRC
    Insert five (5) copies of ~0~.

    #+BEGIN_SRC
    C-u 2 5 C-n
    #+END_SRC
    Move down twenty-five (25) lines

    #+BEGIN_SRC
    C-u - 1 2 C-n
    #+END_SRC
    Move up twelve (12) lines

    #+BEGIN_SRC
    C-u - C-n
    #+END_SRC
    Move up one (1) line

    #+BEGIN_SRC
    C-u C-n
    #+END_SRC
    Move down four (4) lines

    #+BEGIN_SRC
    C-u C-u C-n
    #+END_SRC
    Move down sixteen (16) lines

    #+BEGIN_SRC
    C-u 6 4 a
    #+END_SRC
    Insert sixty-four (64) copies of the character ~a~.

    #+BEGIN_SRC
    C-u 6 4 C-u 1
    #+END_SRC
    Insert sixty-four (64) copies of the character ~1~.
*** Repeating a Command
    Example
    #+BEGIN_SRC
    C-u 2 0 C-d
    C-x z z z
    #+END_SRC
    Delete 80 characters.
** The Minibuffer
*** Using the Minibuffer
    Can exit the minibuffer using ~C-g~
*** Minibuffers for File Names
    Options to change file/directory
    - ~M-n~ :: Next default for file name
    - ~M-<DEL>~ :: Kill directory name backwards
    - ~C-a C-k~ :: Clear entire minibuffer

    When file is a remote file:
    - a double slash ignores the file-name but keeps the method, host
      and username.
    - three slashes in a row ignores everything, both file-name and
      the method, host and username.

    #+BEGIN_SRC
    ~/
    #+END_SRC
    home directory

    #+BEGIN_SRC
    ~user-id/
    #+END_SRC
    The home directory of a user whose login name is /user-id/
*** Editing in the Minibuffer
    The following commands behave differently in the minibuffer
    compared with standard buffers:
    - ~<RET>~
    - ~<TAB>~
    - ~<SPC>~
    - ~?~

    You can use ~C-q~ to insert these into the minibuffer as you would
    expect them to be inserted.

    The minibuffer is displayed in the Echo Area. When the minibuffer
    is active, it can be thought of as it's own window. You can
    navigate windows how you normally would and return to the
    minibuffer as if it is it's own window. However standard windows
    can be split, and the Echo Area cannot be split into multiple
    windows.

    Clicking ~mouse-1~ in the Echo Area when the minibuffer is not
    active shows the ~*Messages*~ buffer in a new window.
*** Completion
    - Completion :: A helpful feature of Emacs to help enter
      arguments. This means that after you type part of the argument,
      Emacs can fill in the rest, or some of it, based on what was
      typed so far.
**** Completion Example
     #+BEGIN_SRC
     M-x c u s <TAB> i <TAB> - v <TAB>
     #+END_SRC
     Enter ~customize-variable~ into the minibuffer as a command to
     run.
**** Completion Commands
**** Completion Exit
     There are Four types of behavior for the command
     ~minibuffer-complete-and-exit~.

     - Strict Completion
       - If minibuffer is exact match :: Exits the minibuffer.
       - If minibuffer completes to exact match :: Complete match and
         exit the minibuffer.
       - Else :: Attempts to complete, refuses to exit, displays "[No
         match]"
     - Cautious Completion
       - If minibuffer is exact match :: Exits the minibuffer.
       - If minibuffer completes to exact match :: Complete match,
         does not exit the minibuffer.
       - Else :: (unsure of exact behavior)
     - Permissive Completion
       - Any context :: Exits the minibuffer.
     - Permissive Completion with Confirmation
       - After typing <TAB> to partial completion :: does not exit
         minibuffer, displays "[Confirm]".
       - Else :: Exits the minibuffer.
**** How Completion Alternatives Are Chosen
     Completion tries each style and then moves onto the next in the
     list if unsuccessful. Here is the list in order:
     - ~basic~ :: A matching completion alternative must have the same
       beginning as the text in the minibuffer before
       point. Furthermore, if there is any text in the minibuffer
       after point, the rest of the completion alternative must
       contain that text as a sub-string.
     - ~partial-completion~ :: This aggressive completion style
       divides the minibuffer text into words separated by hyphens or
       spaces, and completes each word separately. (for example, when
       completing command names, 'em-l-m' completes to
       'emacs-lisp-mode'.) Furthermore a '*' in the minibuffer text is
       treated as a wildcard - it matches any string of characters at
       the corresponding position in the completion alternative.
     - ~emacs22~ :: This completion style is similar to ~basic~,
       except that it ignores the text in the minibuffer after
       point. It is so-named because it corresponds to the completion
       behavior in Emacs 22.

     Additional list options
     - ~substring~ :: A matching completion alternative must contain
       the text in the minibuffer before point, and the text in the
       minibuffer after point, as sub-strings (in that same
       order). Thus if the text in the minibuffer is 'foobar', with
       point between 'foo' and 'bar', that matches 'dfooebarf', where
       d, e, and f can be any string including the empty string.
     - ~initials~ :: This very aggressive completion style attempts to
       complete acronyms and initialisms. For example, when completing
       command names, it matches 'lch' to 'list-command-history'.
     - ~emacs21~ :: Only matches that start with the text in the
       minibuffer are considered, regardless of point location.
**** Completion Options
*** Minibuffer History
*** Repeating Minibuffer Commands
    Vocabulary
    - Command History :: Special history list that records complex
      commands that required an argument from the minibuffer.
*** Entering passwords
    Entering passwords is a slightly different context than the
    minibuffer is normally.

    Most features and commands associated with the minibuffer /cannot/
    be used when entering a password. No completion, no changing
    windows.

    - ~<DEL>~ :: removes last character entered.
    - ~C-u~ :: deletes everything you have typed so far.
    - ~C-g~ :: quits the password prompt.
    - ~C-y~ :: inserts the current kill into the password.
    - ~<RET>~ OR ~<ESC>~ :: submit password.
*** Yes or No Prompts
    There are two types of yes or no prompts.

    The first kind ends an Echo Area prompt with ~(y or n)~.
    - ~C-l~ :: recenter the selected window
    - ~C-v~ OR ~<PageDown>~ OR ~<next>~ :: scroll forward.
    - ~M-v~ OR ~<PageUp>~ OR ~<prior>~ :: scroll backward.
    - ~C-M-v~ :: scrolls forward in the next window.
    - ~C-M-S-v~ :: scrolls backward in the next window.
    - ~C-g~ :: dismisses query and quits the command.

    The second kind ends an Echo Area prompt with ~(yes or no)~. This
    behaves the exact same as standard minibuffer context
** Running Commands by Name
** Help
   When looking for a feature but don't know what it's called, here is
   the suggested method of how to find it in the following order:
   - ~C-h a /topics/ <RET>~ :: This is an apropos command, literally
     runs ~apropos-command~. Searches for commands whose names match
     the argument /topics/
   - ~C-h r i /topic/ <RET>~ :: This navigates to the
     Emacs manual and then searches for /topic/ in the indices.
   - ~C-h r s /topic/ <RET>~ :: Similar as above, but
     searches the text of the manual rather than the indices
   - ~C-h C-f~ :: Displays the Emacs FAQ, using Info.
   - ~C-h p~ :: Displays the available Emacs packages based on
     keywords.

   Additionally, typing one of the following commands after a prefix
   command can mean seeing a list of possible complete keys:
   - ~C-h~
   - ~<F1>~
   - ~?~
*** Help Summary
*** Documentation for a Key
*** Help by Command or Variable Name
*** Apropos
    When searching apropos, entering one word will look for that word
    anywhere in the name. Entering more than one word will look for
    two of the provided words anywhere in the name.

    If text contains regex characters: ~^$*+?.\[~ the text to search
    is interpreted as a regular expression

    Helpful apropos words
    - char
    - line
    - word
    - sentence
    - paragraph
    - region
    - page
    - sexp
    - list
    - defun
    - rect
    - buffer
    - frame
    - window
    - face
    - file
    - dir
    - register
    - mode
    - beginning
    - end
    - forward
    - backward
    - next
    - previous
    - up
    - down
    - search
    - goto
    - kill
    - delete
    - mark
    - insert
    - yank
    - fill
    - indent
    - case
    - change
    - set
    - what
    - list
    - find
    - view
    - describe
    - default

    By default, all apropos commands except ~apropos-documentation~
    list their results in alphabetical order.

    The ~apropos-documentation~ command lists its results in order of
    relevance by default.
*** Help Mode Commands
    Vocabulary mentioned:
    - Faces
*** Keyword Search for Packages
*** Help for International Language Support
*** Other Help Commands
*** Help Files
*** Help on Active Text and Tooltips
** The Mark and the Region
   Vocabulary
   - Mark :: An arbitrary point you define that stays in place while
     you move the point around. Deactivates after editing or
     quitting.
   - Region :: The portion of the buffer that is contained between the
     Mark and the Point. Only active when Mark is active.

   Setting the mark in one buffer has no effect on the marks in other
   buffers. When you return to a buffer with an active mark, the mark
   is at the same place as before. When multiple windows show the same
   buffer, they can have different values of point, and thus different
   regions, but they all share one common mark position.
*** Setting the Mark
    Vocabulary:
    - Shift Selection :: You can set the mark by holding down the
      shift key while typing certain cursor motion commands (such as
      ~S-<RIGHT>~, ~S-C-f~, ~S-C-n~, etc.).
    - Primary Selection :: Mentioned not well defined.

    Whenever the mark is active, you can deactivate it by typing
    ~C-g~. Most commands that operate on the region also automatically
    deactivate the mark.

    Many commands that insert text, such as ~C-y~ (~yank~), set the
    mark at the other end of the inserted text, without activating
    it. You can tell that a command does this when it shows '~Mark
    set~' in the echo area.
*** Commands to Mark Textual Objects
    Repeated invocations of ~M-@~ extend the region by advancing the
    mark one word at a time. As an exception, if the mark is active
    and located before point, ~M-@~ moves the mark backwards from its
    current position one word at a time.

    Similarly repeated invocations of ~C-M-<SPC>~ extend the region to
    subsequent expressions.

    In fact for all ~mark~-COMMAND commands the following is
    true. Repeated invocations play the same role as above, extending
    the region to consecutive objects.
*** Operating on the Region
    Example commands on region:
    - ~C-w~ :: Kill Region
    - ~M-w~ :: Copy Region to kill ring
    - ~C-x C-l~ :: Entire region to lower case
    - ~C-x C-u~ :: Entire region to upper case
    - ~C-u C-/~ :: Undo changes within region
    - ~M-%~ :: Find and replace within region
    - ~C-x <TAB>~ OR ~C-M-\~ :: Indent region
    - ~M-x fill-region~ :: Fill it as text
    - ~M-$~ :: Check spelling of words within region
    - ~M-x eval-region~ :: Evaluate region as Lisp code
    - ~C-x r s~ :: Save region in a register
    - Save region in a buffer or a file.
    - ~<DEL>~ OR ~<Delete>~ :: Delete the text in the region
*** The Mark Ring
    Each buffer remembers the previous locations of the mark, in the
    mark ring. Commands that set the mark also push the old mark onto
    this ring. One of the uses of the mark ring is to remember spots
    that you may want to go back to.

    ~C-<SPC> C-<SPC>~ is a way to set the mark, push it onto the mark
    ring, all without activating it.

    When Transient Mark mode is off, ~C-<SPC> C-<SPC>~ instead
    activates Transient Mark mode temporarily.

    To return to a marked position, use ~set-mark-command~ with a
    prefix argument: ~C-u C-<SPC>~. This moves point to where the mark
    was, and deactivates the mark if it was active. Each subsequent
    ~C-u C-<SPC>~ jumps to a prior position stored in the mark
    ring. The positions you move through in this way or not lost; they
    go to the end of the ring.
*** The Global Mark Ring
    In addition to the ordinary mark ring that belongs to each buffer,
    Emacs has a single global mark ring. Each time you set a mark,
    this is recorded in the global mark ring in addition to the
    current buffer's own mark ring, if you have switched buffers since
    the previous mark setting.
*** Shift Selection
    Definition:
    - Shift Selection :: If you hold down the shift key while typing a
      cursor motion command, this sets the mark before the moving
      point, so that the region extends from the original position of
      point to its new position.

    The mark set via shift-selection behaves a little differently from
    what we have described above. Firstly, in addition to the usual
    way of deactivating the mark (such as changing the buffer text or
    typing ~C-g~), the mark is deactivated by any /unshifted/ cursor
    motion command. Secondly, any subsequent /shifted/ cursor motion
    command avoids setting the mark anew. Therefore, a series of
    shifted cursor motion commands will continuously adjust the
    region.

    Shift-selection only works if the shifted cursor motion key is not
    already bound to a separate command. For example, if you bind
    ~S-C-f~ to another command, typing ~S-C-f~ runs that command
    instead of performing a shift-selected version of ~C-f~
    (~forward-char~).

    A mark set via mouse commands behaves the same as a mark set via
    shift-selection. For example, if you specify a region by dragging
    the mouse, you can continue to extend the region using shifted
    cursor motion commands. In either case, any unshifted cursor
    motion command deactivates the mark.
*** Disabling Transient Mark Mode
    Turning off Transient Mark mode switched Emacs to an alternative
    mode of operation:
    - Setting the mark, with commands like ~C-<SPC>~ or ~C-x C-x~,
      does not highlight the region. Therefore, you can't tell by
      looking where the mark is located; you have to remember. The
      usual solution to this problem is to set the mark and then use
      it soon, before you forget where it is. You can also check where
      the mark is by using ~C-x C-x~, which exchanges the position of
      the point and the mark.
    - Some commands, which ordinarily act on the region when the mark
      is active, no longer do so. For example, normally ~M-%~
      (~query-replace~) performs replace within the region, if the
      mark is active. When Transient Mark mode is off, it always
      operates from point to the end of the buffer. Commands that act
      this way are identified in their own documentation

    While Transient Mark mode is off, you can activate it temporarily
    using ~C-<SPC> C-<SPC>~ or ~C-u C-x C-x~.

    - ~C-<SPC> C-<SPC>~ :: Set the mark at point (like plain
      ~C-<SPC>~) and enable Transient Mark mode just once, until the
      mark is deactivated.
    - ~C-u C-x C-x~ :: Exchange point and mark, activate the mark and
      enable Transient Mark mode temporarily, until the mark is next
      deactivated.

    When you specify a region with the mouse, or with shift-selection,
    this likewise activates Transient Mark mode temporarily and
    highlights the region.
** Killing and Moving Text
   - Kill :: Erase text and copy text into the "kill ring".
   - Yank :: Bring text from the "kill ring" back into the buffer.
   - Kill Ring :: Can be visualized as a set of blocks of text
     arranged in a ring, which you can access in cyclic order.
*** Deletion and Killing
    Most commands which erase text from the buffer save it in the kill
    ring. These are known as kill commands, and their names normally
    contain the word '~kill~' (e.g., ~kill-line~). The kill ring
    stores several recent kills, not just the last one, so killing is
    a very safe operation: you don't have to worry much about losing
    text that you previously killed. The kill ring is shared by all
    buffers, so text that is killed in one buffer can be yanked into
    another buffer.

    When you use ~C-/~ (~undo~) to undo a kill command, that brings
    the killed text back into the buffer, but does not remove it from
    the kill ring.

    On graphical displays, killing text also copies it into the system
    clipboard.

    Commands that erase text but do not save it in the kill ring are
    known as delete commands; their names usually contain the word
    '~delete~'. These include ~C-d~ (~delete-char~) and ~<DEL>~
    (~delete-backward-char~), which delete only one character at a
    time, and those commands that delete only spaces or
    newlines. Commands that can erase significant amounts of
    nontrivial data generally do a kill operation instead.

    You can also use the mouse to kill and yank.
**** Deletion
**** Killing by Lines
**** Other Kill Commands
**** Options for Killing
     The kill commands work specially in a read-only buffer: they move
     over text and copy it to the kill ring, without actually deleting
     it from the buffer.
*** Yanking
    Vocabulary:
    - Yanking :: Reinserting text previously killed.

    On graphical displays, ~C-y~ first checks if another application
    has placed any text in the system clipboard more recently than the
    last Emacs kill. If so, it inserts the clipboard's text
    instead. Thus Emacs effectively treats "cut" or "copy" clipboard
    operations performed in other applications like Emacs kills,
    except that they are not recorded in the kill ring.
**** The Kill Ring
     Vocabulary
     - Kill Ring :: A list of blocks of text that were previously
       killed.

     There is only one Kill Ring, shared by all buffers, so you can
     kill text in one buffer and yank it in another buffer.

     If you make a new kill when the limit defined in ~kill-ring-max~
     has been reached, Emacs makes room by deleting the oldest entry
     in the kill ring.
**** Yanking Earlier Kills
     If the previous command was a yank command, ~M-y~ takes the text
     that was yanked and replaces it with the text from an earlier
     kill. So to recover the text of the next-to-the-last kill, first
     use ~C-y~ to yank the last kill, and then use ~M-y~ to replace it
     with the previous kill. ~M-y~ is allowed only after a ~C-y~ or
     another ~M-y~.

     You can understand ~M-y~ in terms of a last-yank pointer which
     points at an entry in the kill ring. Each time you kill, the
     last-yank pointer moves to the newly made entry at the front of
     the ring. ~C-y~ yanks the entry with the last-yank pointer points
     to. ~M-y~ moves the last-yank pointer to a different entry, and
     the text in the buffer changes to match. Enough ~M-y~ commands
     can move the pointer to any entry in the ring, so you can get any
     entry into the buffer. Eventually the pointer reaches the end of
     the ring; the next ~M-y~ loops back around to the first entry
     again.

     ~M-y~ moves the last-yank pointer around the ring, but it does
     not change the order of the entries in the ring, which always
     runs from the most recent kill at the front to the oldest one
     still remembered.

     As long as no new killing is done, the last-hank pointer remains
     at the same place in the kill ring, so repeating ~C-y~ will yank
     another copy of the same previous kill.
**** Appending Kills
     Normally, each kill command pushes a new entry onto the kill
     ring. However, two or more kill commands in a row combine their
     text into a single entry, so that a single ~C-y~ yanks all the
     text as a unit, just as it was before it was killed.

     Commands that kill forward from point add onto the end of the
     previous killed text. Commands that kill backward from point add
     text onto the beginning. This way, any sequence of mixed forward
     and backward kill commands puts all the killed text into one
     entry without rearrangement.

     If a kill command is separated from the last kill command by
     other commands (not just numeric arguments), it starts a new
     entry on the kill ring.

     A kill command following ~M-w~ (~kill-ring-save~) does not append
     to the text that ~M-w~ copied into the kill ring.
*** "Cut and Paste" Operations on Graphical Displays
    In most graphical desktop environments, you can transfer data
    (usually text) between different applications using a system
    facility called the /clipboard/. On X, two other similar
    facilities are available: the primary selection and the secondary
    selection. When Emacs is run on a graphical display, its kill and
    yank commands integrate with these facilities, so that you can
    easily transfer text between Emacs and other graphical
    applications.

    By default, Emacs uses UTF-8 as the coding system for
    inter-program text transfers. If you find that the pasted text is
    not what you expected, you can specify another coding system by
    typing ~C-x <RET> x~ or ~C-x <RET> X~.
**** Using the Clipboard
     The /clipboard/ is the facility that most graphical applications
     use for "cutting and pasting". When the clipboard exists, the
     kill and yank commands in Emacs make use of it.

     When you kill some text with a command such as ~C-w~
     (~kill-region~), or copy it to the kill ring with a command such
     as ~M-w~ (~kill-ring-save~), that text is also put in the
     clipboard.

     When an Emacs kill command puts text in the clipboard, the
     existing clipboard contents are normally lost.

     Yank commands, such as ~C-y~ (~yank~), also use the clipboard. If
     another application "owns" the clipboard - i.e., if you cut or
     copied text there more recently than your last kill command in
     Emacs - then Emacs yanks from the clipboard instead of the kill
     ring.

     Normally, rotating the kill ring with ~M-y~ (~yank-pop~) does not
     alter the clipboard.

     Many X desktop environments support a feature called the
     /clipboard manager/. If you exit Emacs while it is the current
     "owner" of the clipboard data, and there is a clipboard manager
     running, Emacs transfers the clipboard data to the clipboard
     manager so that it is not lost. In some circumstances, this may
     cause a delay when exiting Emacs.

     Since strings containing NUL bytes are usually truncated when
     passed through the clipboard, Emacs replaces such characters with
     "\0" before transferring them to the system's clipboard.

     Prior to Emacs 24, the kill and yank commands used the primary
     selection, not the clipboard. If you prefer this behavior, change
     ~select-enable-clipboard~ to ~nil~, ~select-enable-primary~ to
     ~t~, and ~mouse-drag-copy-region~ to ~t~. In this case, you can
     use the following commands to act explicitly on the clipboard:
     ~clipboard-kill-region~; ~clipboard-kill-ring-save~; and
     ~clipboard-yank~.
**** Cut and Paste with Other Window Applications
     Under the X Window System, there exists a /primary selection/
     containing the last stretch of text selected in an X application
     (usually by dragging the mouse). Typically, this text can be
     inserted into other X applications by ~mouse-2~ clicks. The
     primary selection is separate from the clipboard. Its contents
     are more fragile; they are overwritten each time you select text
     with the mouse, whereas the clipboard is only overwritten by
     explicit cut or copy commands.

     Under X, whenever the region is active, the text in the region is
     saved in the primary selection. This applies regardless of
     whether the region was made by dragging or clicking the mouse, or
     by keyboard commands.

     MS-Windows provides no primary selection, but Emacs emulates it
     within a single Emacs session by storing the selected text
     internally. Therefore, all the features and commands related to
     the primary selection work on Windows as they do on X, for
     cutting and pasting within the same session, but not across Emacs
     sessions or with other applications.
**** Secondary Selection
     In addition to the primary selection, the X Window System
     provides a second similar facility known as the /secondary
     selection/. Nowadays, few X applications make use of the
     secondary selection, but you can access it using the following
     Emacs commands:
     - ~mouse-set-secondary~
     - ~mouse-start-secondary~
     - ~mouse-secondary-save-then-kill~
     - ~mouse-yank-secondary~
*** Accumulating Text
*** Rectangles
    Rectangle commands operate on rectangular areas of the text: all
    the characters between a certain pair of columns, in a certain
    range of lines. Emacs has commands to kill rectangles, yank killed
    rectangles, clear them out, fill them with blanks or text, or
    delete them. Rectangle commands are useful with text in
    multi-column formats, and for changing text into or out of such
    formats.

    To specify a rectangle for a command to work on, set the mark at
    one corner and point at the opposite corner. The rectangle thus
    specified is called the /region-rectangle/. If point and the mark
    are in the same column, the region-rectangle is empty. If they are
    in the same line, the region-rectangle is one line high.

    The region-rectangle is controlled in much the same way as the
    region is controlled. But remember that a given combination of
    point and mark values can be interpreted either as a region or as
    a rectangle, depending on the command that uses them.

    Killing a rectangle is not killing in the usual sense; the
    rectangle is not stored in the kill ring, but in a special place
    that only records the most recent rectangle killed. This is
    because yanking a rectangle is so different from yanking linear
    text that different yank commands have to be used. Yank-popping is
    not defined for rectangles.

    When yanking a rectangle, the rectangle's first line is inserted
    at point, the rectangle's second line is inserted at the same
    horizontal position one line vertically below, and so on. The
    number of lines affected is determined by the height of the saved
    rectangle.
*** CUA Bindings
** Registers
   Vocabulary:
   - Register :: compartments were you can save test, rectangles,
     positions ans other things for later use.
   - Bookmark :: record files and positions in them

   Valid register names:
   - characters (case sensitive) :: a, b, A, C
   - digits :: 1, 2, 3
   - non-alphanumeric :: *, #, ?
   - single input event with multiple keystrokes :: C-d, M-v

   Invalid register names:
   - C-g
   - <ESC>

   Registers can store one thing at a time including but not limited
   to the following options:
   - position
   - piece of text
   - rectangle
   - number
   - window configuration
   - file name
*** Saving Positions in Registers
*** Saving Text in Registers
    When you want to insert a copy of the same piece of text several
    times, it may be inconvenient to yank it from the kill ring, since
    each subsequent kill moves that entry further down the ring. An
    alternative is to store the text in a register and later retrieve
    it.
*** Saving Rectangles in Registers
*** Saving Window Configurations in Registers
*** Keeping Numbers in Registers
    There are commands to store a number in a register, to insert the
    number in the buffer in decimal, and to increment it. These
    commands can be useful in keyboard macros.
*** Keeping File Names in Registers
*** Keyboard Macro Registers
    If you need to execute a keyboard macro frequently, it is more
    convenient to put it in a register or save it.
*** Bookmarks
    Vocabulary:
    - Bookmark :: Record a position you can jump to using long
      names. They persist automatically across Emacs
      sessions. Normally used to record where you left off reading in
      various files.

    When you kill Emacs, Emacs saves your bookmarks, if you have
    changed any bookmark values. Bookmarks are saved to the file
    '~/.emacs.d/bookmarks' (for compatibility with older versions of
    Emacs, if you have a file named '~/.emacs.bmk', that is used
    instead). The bookmark commands load your default bookmark file
    automatically. This saving and loading is how bookmarks persist
    from one Emacs session to the next.

    Bookmark position values are saved with surrounding context, so
    that ~bookmark-jump~ can find the proper position even if the file
    is modified slightly.
** Controlling the Display
*** Scrolling
    Scrolling forward or up advances the portion of the buffer
    displayed in the window; equivalently, it moves the buffer text
    upwards relative to the window. Scrolling backward or down
    displays an earlier portion of the buffer, and moves the text
    downwards relative to the window.

    In Emacs, scrolling up or down refers to the direction that the
    text moves in the window, /not/ the direction that the window
    moves relative to the text. This terminology was adopted by Emacs
    before the modern meaning of "scrolling up" and "scrolling down"
    became widespread. Hence the strange result that ~<PageDown>~
    scrolls up in the Emacs sense.

    The portion of a buffer displayed in a window always contains
    point. If you move point past the bottom or top of the window,
    scrolling occurs automatically to bring it back onscreen.
*** Recentering
    Some combinations of variables and commands can lead to clearing
    and redisplaying the screen. Redisplaying is useful in case the
    screen becomes garbled for any reason. Read the documentation for
    ~recenter-top-bottom~ and ~recenter-redisplay~ for more
    information.
*** Automatic Scrolling
    Emacs performs automatic scrolling when point moves out of the
    visible portion of the text. Normally, automatic scrolling centers
    point vertically in the window, but there are several ways to
    alter this behavior. Check out the documentation for the following
    variables:
    - ~scroll-conservatively~
    - ~scroll-step~
    - ~scroll-up-aggressively~ / ~scroll-down-aggressively~

    Note that these variables control automatic scrolling in
    contradictory ways. Therefore, you should pick no more than one of
    these methods to customize automatic scrolling. In case you
    customize multiple variables, the order of priority is in the same
    order listed above.
*** Horizontal Scrolling
    Horizontal scrolling means shifting all the lines sideways withing
    a window, so that some of the text near the left margin is not
    displayed.

    When the text in a window is scrolled horizontally, text lines are
    truncated rather than continued. If a window shows truncated
    lines, Emacs performs automatic horizontal scrolling whenever the
    point moves off the left or right edge of the screen.

    If you use the commands ~scroll-left~ and ~scroll-right~ to scroll
    a window horizontally, that sets a lower bound for automatic
    horizontal scrolling. Automatic scrolling will continue to scroll
    the window, but never farther to the right than the amount you
    previously set by ~scroll-left~. When ~auto-hscroll-mode~ is set
    to ~current-line~, all the lines other than the one showing the
    cursor will be scrolled by that minimal amount.
*** Narrowing
    *Narrowing* means focusing in on some portion of the buffer,
    making the rest temporarily inaccessible. The portion which you
    can still get to is called the accessible portion.

    Canceling the narrowing, which makes the entire buffer once again
    accessible, is called *widening*.

    The bounds of narrowing in effect in a buffer are called the
    buffer's *restriction*.

    When you have narrowed down to a part of the buffer, that part
    appears to be all there is. You can't see the rest, you can't move
    into it (motion commands won't go inside the accessible part), you
    can't change it in any way. However, it is not gone, and if you
    save the file all the inaccessible text will be saved. The word
    ~Narrow~ appears in the mode line whenever narrowing is in
    effect.

    You can get information on what part of the buffer you are
    narrowed down to using the command ~what-cursor-position~,
    normally: ~C-x =~.

    Because narrowing can easily confuse users who do not understand
    it, ~narrow-to-region~ is normally a disabled command. Attempting
    to use this command asks for confirmation and gives you the option
    of enabling it; if you enable the command, confirmation will no
    longer be required for it.
*** View Mode
*** Follow Mode
*** Text Faces
    Emacs can display text in several different styles, called
    faces. Each face can specify various face attributes, such as the
    font, height, weight, slant, foreground and background color, and
    underlining or overlining. Most major modes assign faces to the
    text automatically, via Font Lock mode.

    It's possible for a given face to look different in different
    frames. For instance, some text terminals do not support all face
    attributes, particularly font, height, and width, and some support
    a limited range of colors. In addition, most Emacs faces are
    defined so that their attributes are different on light and dark
    frame backgrounds, for reasons of legibility.

    You can customize a face to alter its attributes, and save those
    customizations for future Emacs sessions.

    The ~default~ face is the default for displaying text, and all of
    its attributes are specified. Its background color is also used as
    the frame's background color.

    Another special face is the ~cursor~ face. On graphical displays,
    the background color of this face is used to draw the the text
    color. None of the other attributes of this face have any effect;
    the foreground color for text under the cursor is taken from the
    background color of the underlying text. On text terminals, the
    appearance of the text cursor is determined by the terminal, not
    by the ~cursor~ face.

    You can also use X resources to specify attributes of any
    particular face.

    Emacs can display variable-width fonts, but some Emacs commands,
    particularly indentation commands, do not account for variable
    character display widths. Therefore, we recommend not using
    variable-width fonts for most faces, particularly those assigned
    by Font Lock mode.
*** Colors for Faces
    Faces can have various foreground and background colors. When you
    specify a color for a face you can use either a color name or an
    RGB triplet.

    A color name is a pre-defined name, such as ~dark orange~ or
    ~medium sea green~. These are standard X11 color names, defined in
    X's ~rgb.txt~ file. Emacs understands X11 color names even on text
    terminals; if a face is given a color specified by an X11 color
    name, it is displayed using the closest-matching terminal color.

    An RGB triplet is a string of the form ~#RRGGBB~. Each of the R,
    G, and B components is a hexadecimal number specifying the
    component's relative intensity, one to four digits long (usually
    two digits are used). The components must have the same number of
    digits. For hexadecimal values A to F, either upper or lower case
    are acceptable.
*** Standard Faces
*** Text Scale
*** Font Lock mode
    The easiest way to find all of the faces Font Lock mode uses to do
    it's job is to use ~M-x customize-group RET font-lock-faces
    RET~. You can then use that customization buffer to customize the
    appearance of these faces.

    Comment and string fontification (or "syntactic" fontification)
    relies on analysis of the syntactic structure of the buffer
    text. For the sake of speed, some modes, including Lisp mode, rely
    on a special convention: an open-parenthesis or open-brace in the
    leftmost column always defines the beginning of a defun, and is
    thus always outside any string or comment. Therefore, you should
    avoid placing an open-parenthesis or open-brace in the leftmost
    column, if it is inside a string or comment.

    Fontifying large buffers can take a long time. To avoid large
    delays when a file is visited, Emacs initially fontifies only the
    visible portion of a buffer. As you scroll through the buffer,
    each portion that becomes visible is fontified as soon as it is
    displayed; this type of Font Lock is called /Just-In-Time/ (or
    /JIT/) Lock. You can control how JIT Lock behaves, including
    telling it to perform fontification while idle, by customizing
    variables in the customization group '~jit-lock~'.
*** Interactive Highlighting
*** Window Fringes
    On graphical displays, each Emacs window normally has narrow
    /fringes/ on the left and right edges. The fringes are used to
    display symbols that provide information about the text in the
    window.

    Uses of fringes:
    - Continuation Lines (most common)
    - Line Truncation
    - Buffer boundaries
    - Unused lines near the end of the window
    - Where a program you are debugging is executing
    - Draw the cursor, if the current line is exactly as wide as the
      window and point is at the end of the line.

    If you customize the ~fringe-mode~ variable to remove the fringes
    on one or both sides of the window display, these are the only
    features still available:
    - Continuation Lines
    - Line Truncation

    This reduces the width available for displaying text on each line,
    because the character cells used for truncation and continuation
    indicators are reserved for that purpose. Since buffer text can
    include bidirectional text, and thus both left-to-right and
    right-to-left paragraphs, removing only one of the fringes still
    reserves two character cells, one on each side of the window, for
    truncation and continuation indicators, because these indicators
    are displayed on opposite sides of the window in right-to-left
    paragraphs.
*** Displaying Boundaries
    Emacs can add an indicator to display a fill column position. The
    fill column indicator is a useful functionality especially in
    ~prog-mode~ to indicate the position of a specific column.
*** Useless Whitespace
*** Selective Display
*** Optional Mode Line Features
    If you have narrowed the buffer, the displayed line number is
    relative to the accessible portion of the buffer. Thus, it isn't
    suitable as an argument to ~goto-line~. (Use ~what-line~ command
    to see the line number relative to the whole file.)

    On graphical displays, the mode line is drawn as a 3D box. If you
    don't like this effect, you can disable it by customizing the
    ~mode-line~ face and setting its ~box~ attribute to ~nil~.

    By default, the mode line of nonselected windows is displayed in a
    different face, called ~mode-line-inactive~. Only the selected
    window is displayed in the ~mode-line~ face. This helps show which
    window is selected. When the minibuffer is selected, since it has
    no mode line, the window from which you activated the minibuffer
    has its mode line displayed using ~mode-line~; as a result,
    ordinary entry to the minibuffer does not change any mode lines.

    You can customize the mode line display for each of the
    end-of-line formats by setting each of the variables
    ~eol-mnemonic-unix~, ~eol-mnemonic-mac~, and
    ~eol-mnemonic-undecided~ to the strings you prefer.
*** How Text Is Displayed
    There are two types of characters:
    - printing characters
    - control characters

    Most characters are /printing characters/: when they appear in a
    buffer, they are displayed literally on the screen. Printing
    characters include ASCII numbers, letters, and punctuation
    characters, as well as many non-ASCII characters.

    There are some printable characters that may be displayed in a
    special way. They are:
    - Characters that have the same appearance as an ASCII space
    - Characters that have the same appearance as an ASCII hyphen
    - English quotation marks and all variants
    - Characters with no glyphs in any available fonts

    Such characters can cause problems if they are entered into a
    buffer without your realization, e.g. by yanking; for instance,
    source code compilers typically do not treat non-ASCII spaces as
    whitespace characters. To deal with this problem, Emacs displays
    such characters specially: it displays ~U+00A0~ (no-break space)
    with the ~nobreak-space~ face, and it displays ~U+00AD~ (soft
    hyphen), ~U+2010~ (hyphen), and ~U+2011~ (non-breaking hyphen)
    with the ~nobreak-hyphen~ face.

    Emacs tries to determine if the curved quotes `~‘~' and `~’~' can
    be displayed on the current display. By default, if this seems to
    be so, then Emacs will translate the ASCII quotes (`~`~' and
    `~'~'), when they appear in messages and help texts, to these
    curved quotes.

    If the curved quotes ~‘~, ~’~, ~“~, and ~”~ are known to look just
    like ASCII characters, they are shown with the ~homoglyph~
    face. Curved quotes that are known not to be displayable are shown
    as their ASCII approximations ~`~ and ~'~ and ~"~ with the
    ~homoglyph~ face. (Emacs bug ")

    On graphical displays, some characters may have no glyphs in any
    of the fonts available to Emacs. These /glyphless characters/ are
    normally displayed as boxes containing the hexadecimal character
    code. Similarly, on text terminals, characters that cannot be
    displayed using the terminal encoding are normally displayed as
    question signs.

    Control characters are displayed in many different ways. Here are
    some different types of control characters and how they are
    displayed.
    - newline character
    - tab character
    - Other ASCII low code (under ~U+0020~)
    - Bytes with codes ~U+0080~ through ~U+009F~

    The ASCII character set contains non-printing /control
    characters/. Two of these are displayed specially: the newline
    character (Unicode code point ~U+000A~) is displayed by starting a
    new line, while the tab character (~U+0009~) is displayed as a
    space that extends to the next tab stop column (normally every 8
    columns). Note that the way the tab character in the buffer is
    displayed has nothing to do with the definition of ~TAB~ as a
    command.

    Other ASCII control characters, whose codes are below ~U+0020~
    (octal 40, decimal 32), are displayed as a caret ('~^~') followed
    by the non-control version of the character, with the
    ~escape-glyph~ face. For instance, the '~control-A~' character,
    ~U+0001~, is displayed as '~^A~'.

    The raw bytes with codes ~U+0080~ (octal 200) through ~U+009F~
    (octal 237) are displayed as /octal escape sequences/, with the
    ~escape-glyph~ face. For instance, character code ~U+0098~
    (octal 230) is displayed as '~\230~'.

    You can customize the way any particular character code is
    displayed by means of a display table.
*** Displaying the Cursor
    On a text terminal, the cursor's appearance is controlled by the
    terminal, largely out of the control of Emacs. Some terminals
    offer two different cursors: a visible static cursor, and a very
    visible blinking cursor. By default, Emacs uses the very visible
    cursor, and switches to it when you start or resume Emacs.

    On a graphical display, many more properties of the text cursor
    can be altered. To customize its color, change the ~:background~
    attribute of the face named ~cursor~. To change its shape,
    customize the buffer-local variable ~cursor-type~.

    By default, the cursor stops blinking after 10 blinks, if Emacs
    does not get any input during that time; any input event restarts
    the count. You can customize the variable ~blink-cursor-blinks~ to
    control that.

    You can change how the cursor looks when it blinks off by
    customizing the list variable ~blink-cursor-alist~.

    Some characters, such as tab characters, are extra wide. When the
    cursor is positioned over such a character, it is normally drawn
    with the default character width. You can make the cursor stretch
    to cover wide characters, by changing the variable
    ~x-stretch-cursor~ to a non-nil value.

    The cursor normally appears in non-selected windows as a
    non-blinking hollow box. (for a bar cursor, it instead appears as
    a thinner bar.) To turn off cursors in non-selected windows,
    change the variable ~cursor-in-non-selected-windows~ to ~nil~.

    To make the cursor even more visible, you can use HL Line mode, a
    minor mode that highlights the line containing point.
*** Line Truncation
    As an alternative to continuation, Emacs can display long lines by
    /truncation/. This means that all the characters that do not fit
    in the width of the screen or window do not appear at all. On
    graphical displays, a small straight arrow in the fringe indicates
    truncation at either end of the line. On text terminals, this is
    indicated with '~$~' signs in the rightmost and/or leftmost
    columns.

    Horizontal scrolling automatically causes line truncation.

    If a split window becomes too narrow, Emacs may automatically
    enable line truncation.
*** Visual Line Mode
    You can turn on Visual Line mode using the menu bar: in the
    Options menu, select the '~Line Wrapping in this Buffer~' submenu,
    followed by the '~Word Wrap (Visual Line mode)~' menu item.

    While Visual Line mode is enabled, the mode line shows the string
    '~wrap~' in the mode display.

    To move by logical lines, use the commands ~M-x next-logical-line~
    and ~M-x previous-logical-line~. If you use these commands
    frequently, it may be convenient to assign key bindings to them.
*** Customization of Display
** Searching and Replacement
*** Incremental Search
**** Basics of Incremental Search
     ~isearch-forward~ starts a forward incremental search. It reads
     characters from the keyboard, and moves point just past the end
     of the next occurrence of those characters in the buffer.

     Emacs records a new /input item/ whenever you type a command
     that changes:
     - the search string
     - the position of point
     - the success or failure of the search
     - the direction of the search
     - the position of the other end of the current search result
     - the "wrappedness" of the search.

     When you are satisfied with the place you have reached, type
     ~<RET>~. This stops searching, leaving the cursor where the
     search brought it. Also, any command not specifically meaningful
     in searches stops the searching and is then executed. Thus,
     typing ~C-a~ exits the search and then moves to the beginning of
     the line; typing one of the arrow keys exits the search and
     performs the respective movement command; etc. ~<RET>~ is
     necessary only if the next command you want to type is a printing
     character, ~<DEL>~, ~RET~, or another character that is special
     within searches (~C-q~, ~C-w~, ~C-r~, ~C-s~, ~C-y~, ~M-y~, ~M-r~,
     ~M-c~, ~M-e~, and some others described below). You can fine-tune
     the commands that exit the search.

     As a special exception, entering ~RET~ when the search string is
     empty launches nonincremental search.

     When you exit the incremental search, it adds the original value
     of point to the mark ring, without activating the mark; you can
     thus use ~C-u C-<SPC>~ or ~C-x C-x~ to return to where you were
     before beginning the search. (Emacs only does this if the mark
     was not already active; if the mark was active when you started
     the search, both ~C-u C-<SPC>~ and ~C-x C-x~ will go to the
     mark.)
**** Repeating Incremental Search
     After exiting a search, you can search for the same string again
     by typing just ~C-s C-s~. The first ~C-s~ is the key that invokes
     incremental search, and the second ~C-s~ means to search again
     for the last search string. Similarly, ~C-r C-r~ searches
     backward for the last search string. In determining the last
     search string, it doesn't matter whether that string was searched
     for with ~C-s~ or ~C-r~.

     If you are searching forward but you realize you were looking for
     something before the starting point, type ~C-r~ to switch to a
     backward search, leaving the search string unchanged. Similarly,
     ~C-s~ in a backward search switches to a forward search.

     If a search is failing and you ask to repeat it by typing another
     ~C-s~, it starts again from the beginning of the
     buffer. Repeating a failing reverse search with ~C-r~ starts
     again from the end. This is called /wrapping around/, and
     '~Wrapped~' appears in the search prompt once this has
     happened. If you keep on going past the original starting point
     of the search, it changes to '~Overwrapped~', which means that
     you are revisiting matches that you have already seen.

     To reuse earlier search strings, use the /search ring/. The
     commands ~M-p~ and ~M-n~ move through the ring to pick a search
     string to reuse. These commands leave the selected search ring
     element in the minibuffer, where you can edit it.

     To edit the current search string in the minibuffer without
     replacing it with items from the search ring, type ~M-e~ or click
     ~mouse-1~ in the minibuffer. Type ~<RET>~, ~C-S~ or ~C-r~ to
     finish editing the string and search for it. Type ~C-f~ or
     ~<RIGHT>~ to add to the search string characters following point
     from the buffer from which you started the search
**** Isearch Yanking
**** Errors in Incremental Search
     If your string is not found at all, the echo area says '~Failing
     I-Search~', and the cursor moves past the place where Emacs found
     as much of your string as it could. Thus, if you search for
     '~FOOT~', and there is no '~FOOT~', you might see the cursor
     after the '~FOO~' in '~FOOL~'.

     At this point, there are several things you can do. If your
     string was mistyped, use ~DEL~ to cancel a previous input item,
     ~C-M-d~ to erase one character at a time, or ~M-e~ to edit it. If
     you like the place you have found, you can type ~RET~ to remain
     there. Or you can type ~C-g~, which removes from the search
     string the characters that could not be found (the '~T~' in
     '~FOOT~'), leaving those that were found (the '~FOO~' in
     '~FOOT~'). A second ~C-g~ at that point cancels the search
     entirely, returning point to where it was when the search
     started.

     The quit command, ~C-g~, does special things during searches;
     just what it does depends on the status of the search. If the
     search has found what you specified and is waiting for input,
     ~C-g~ cancels the entire search, moving the cursor back to where
     you started the search. If ~C-g~ is typed when there are
     characters in the search string that have not been found -
     because Emacs is still searching for them, or because it has
     failed to find them - then the search string characters which
     have not been found are discarded from the search string. With
     them gone, the search is now successful and waiting for more
     input, so a second ~C-g~ will cancel the entire search.
**** Special Input for Incremental Search
     If an input method is enabled in the current buffer when you
     start the search, the same input method will be active in the
     minibuffer when you type the search string. When an input method
     is active during incremental search, the search prompt includes
     the input method mnemonic, like this:

     #+BEGIN_SRC org
     I-search [im]:
     #+END_SRC

     Where /im/ is the mnemonic of the active input method. Any input
     method you enable during incremental search remains enabled in
     the current buffer afterwards.
**** Not Exiting Incremental Search
     In incremental search, when you type a command that specifies a
     prefix argument, by default it will apply either to the next
     action in the search or to the command that exits the search. In
     other words, entering a prefix argument will not by itself
     terminate the search.
**** Searching the Minibuffer
     If you start an incremental search while the minibuffer is
     active, Emacs searches the contents of the minibuffer. Unlike
     searching an ordinary buffer, the search string is not shown in
     the echo area, because that is used to display the minibuffer.

     If an incremental search fails in the minibuffer, it tries
     searching the minibuffer history. You can visualize the
     minibuffer and its history as a series of pages, with the
     earliest history element on the first page and the current
     minibuffer on the last page. A forward search, ~C-s~, searches
     forward to later pages; a reverse search, ~C-r~, searches
     backwards to earlier pages. Like in ordinary buffer search, a
     failing search can wrap around, going from the last page to the
     first page or vice versa.

     When the current match is on a history element, that history
     element is pulled into the minibuffer. If you exit the
     incremental search normally (e.g., by typing ~RET~), it remains
     in the minibuffer afterwards. Canceling the search, with ~C-g~,
     restores the contents of the minibuffer when you began the
     search.
*** Nonincremental Search
    Emacs also has conventional nonincremental search commands, which
    require you to type the entire search string before searching
    begins.

    To start a nonincremental search, first type ~C-s RET~. This
    enters the minibuffer to read the search string; terminate the
    string with ~RET~, and then the search takes place. If the string
    is not found, the search command signals an error.

    When you type ~C-s RET~, the ~C-s~ invokes incremental search as
    usual. That command is specially programmed to invoke the command
    for nonincremental search, if the string you specify is
    empty. (Such an empty argument would otherwise be useless.) ~C-r
    RET~ does likewise, invoking the nonincremental backward-searching
    command.

    Nonincremental search can also be invoked from the menu bar's
    '~Edit->Search~' menu.

    You can also use two simpler commands, ~M-x search-forward~ and
    ~M-x search-backward~. These commands look for the literal strings
    you specify, and don't support any of the lax-search features
    except for case folding.
*** Word Search
    Incremental and nonincremental word searches differ slightly in
    the way they find a match. In a nonincremental word search, each
    word in the search string must exactly match a whole word. In an
    incremental word search, the matching is more lax: while you are
    typing the search string, its first and last words need not match
    whole words. This is so that the matching can proceed
    incrementally as you type. This additional laxity does not apply
    to the lazy highlight, which always matches whole words. While you
    are typing the search string, '~Pending~' appears in the search
    prompt until you use a search repeating key like ~C-s~.

    The word search commands don't perform character folding, and
    toggling lax whitespace matching has no effect on them.
*** Symbol Search
    - ~M-s _ RET symbol RET~ :: Search forward for /symbol/,
      nonincrementally.
    - ~M-s _ C-r RET symbol RET :: Search backward for /symbol/,
      nonincrementally.

    The symbol search commands don't perform character folding, and
    toggling lax whitespace matching has no effect on them.
*** Regular Expression Search
    All of the special key sequences in an ordinary incremental search
    do similar things in an incremental regexp search. For instance,
    typing ~C-s~ immediately after starting the search retrieves the
    last incremental search regexp used and searches forward for
    it. Incremental regexp and non-regexp searches have independent
    defaults. They also have separate search rings, which you can
    access with ~M-p~ and ~M-n~.

    Unlike ordinary incremental search, incremental regexp search does
    not use lax space matching by default.

    Also unlike ordinary incremental search, incremental regexp search
    cannot use character folding. (If you toggle character folding
    during incremental regexp searches with ~M-s '~, the search
    becomes a non-regexp search and the search pattern you typed is
    interpreted as a literal string.)

    In some cases, adding characters to the regexp in an incremental
    regexp search can make the cursor move back and start again. For
    example, if you have searched for '~foo~' and you add '~\|bar~',
    the cursor backs up in case the first '~bar~' precedes the first
    '~foo~'.

    Forward and backward regexp search are not symmetrical, because
    regexp matching in Emacs always operates forward, starting with
    the beginning of the regexp. Thus forward regexp search scans
    forward, trying a forward match at each possible starting
    position. Backward regexp search scans backward, trying a forward
    match at each possible starting position. These search methods are
    not mirror images.
*** Syntax of Regular Expressions
    Regular expressions have a syntax in which a few characters are
    special constructs and the rest are ordinary. An ordinary
    character matches that same character and nothing else. The
    special characters are '~$^.*+?[\~'. The character '~]~' is
    special if it ends a character alternative. The character '~-~' is
    special inside a character alternative. Any other character
    appearing in a regular expression is ordinary, unless a '~\~'
    precedes it. (When you use regular expressions in a Lisp program,
    each '~\~' must be doubled.)

    Any two regular expressions /a/ and /b/ can be concatenated. The
    result is a regular expression which matches a string if /a/
    matches some amount of the beginning of that string and /b/
    matches the rest of the string. To do something less trivial, you
    need to use one of the special characters. Here is a list of
    them.

    - ~.~ (Period) :: Is a special character that matches any single
      character except a newline.
    - ~*~ :: Is not a construct by itself; it is a postfix operator
      that means to match the preceding regular expression
      repetitively any number of times, as many times as
      possible. '~*~' always applies to the smallest possible
      preceding expression. The matcher processes a '~*~' construct by
      matching, immediately, as many repetitions as can be found. Then
      it continues with the rest of the pattern. If that fails,
      backtracking occurs, discarding some of the matches of the
      '~*~'-modified construct in case that makes it possible to match
      the rest of the pattern.
    - ~+~ :: Is a postfix operator, similar to '~*~' except that it
      must match the preceding expression at least once.
    - ~?~ :: Is a postfix operator, similar to '~*~' except that it
      can match the preceding expression either once or not at all.
    - ~*?~, ~+?~, ~??~ :: are non-greedy variants of the operators
      above. The normal operators '~*~', '~+~', '~?~' match as much as
      they can, as long as the overall regexp can still match. With a
      following '~?~', they will match as little as
      possible. Non-greedy operators match the shortest possible
      string starting at a given starting point; in a forward search,
      though, the earliest possible starting point for match is always
      the one chosen.
    - ~\{n\]~ :: is a postfix operator specifying /n/ repetitions -
      that is, the preceding regular expression must match exactly
      /n/ times in a row.
    - ~\{n,m\}~ :: Is a postfix operator specifying between /n/ and
      /m/ repetitions - that is, the preceding regular expression must
      match at least /n/ times, but no more than /m/ times. If /m/ is
      omitted, then there is no upper limit, but the preceding regular
      expression must match at least /n/ times.
      - '~\{0,1\}~' is equivalent to '~?~'
      - '~\{0,\}~' is equivalent to '~*~'
      - '~\{1,\}~' is equivalent to '~+~'
    - ~[ ... ]~ :: Is a character set, beginning with '~[~' and
      terminated by '~]~'. In the simplest case, the characters
      between the two brackets are what this set can match. You can
      also include character ranges in a character set, by writing the
      starting and ending characters with '~-~' between them. You can
      also include certain special character classes in a character
      set. A '~[:~' and balancing '~:]~' enclose a /character class/
      inside a character set. To include a '~]~' in a character set,
      you must make it the first character. To include a '~-~', write
      '~-~' as the last character of the set, tho you can also put it
      first or after a range. To include '~^~' in a set, put it
      anywhere but at the beginning of the set. (at the beginning, it
      compliments the set - see below.) When you use a range in
      case-insensitive search, you should write both ends of the range
      in upper case, or both in lower case, or both should be
      non-letters. The behavior of a mixed-case range such as '~A-z~'
      is somewhat ill-defined, and it may change in future Emacs
      versions.
    - ~[^ ... ]~ :: '~[^~' begins a complemented character set, which
      matches any character except the ones specified. '~^~' is not
      special in a character set unless it is the first character. The
      character following the '~^~' is treated as if it were first (in
      other words, '~-~' and '~]~' are not special there). A
      complemented character set can match a newline, unless newline
      is mentioned as one of the characters not to match. This is in
      contrast to the handling of regexps in programs such as ~grep~.
    - ~^~ :: Is a special character that matches the empty string, but
      only at the beginning of a line in the text being
      matched. Otherwise it fails to match anything. For historical
      compatibility reasons, '~^~' can be used with this meaning only
      at the beginning of the regular expression, or after '~\(~' or
      '~\|~'.
    - ~$~ :: Is similar to '~^~' but matches only at the end of a
      line. For historical compatibility reasons, '~$~' can be used
      with this meaning only at the end of the regular expression, or
      before '~\)~' or '~\|~'.
    - ~\~ :: has two functions: it quotes the special characters
      (including '~\~'), and it introduces additional special
      constructs. See the following section for the special constructs
      that begin with '~\~'.

    Note: for historical compatibility, special characters are treated
    as ordinary ones if they are in contexts where their special
    meanings make no sense. It is poor practice to depend on this
    behavior; it is better to quote the special character anyway,
    regardless of where it appears.

    As a '~\~' is not special inside a character alternative, it can
    never remove the special meaning of '~-~' or '~]~'. So you should
    not quote these characters when they have no special meaning
    either. This would not clarify anything, since backslashes can
    legitimately precede these characters where they have special
    meaning, as in '~[^\]~' ("~[^\\]~" for List string syntax), which
    matches any single character except a backslash.
*** Backslash in Regular Expressions
    For the most part, '~\~' followed by any character matches only
    that character. However, there are several exceptions:
    two-character sequences starting with '~\~' that have special
    meanings. The second character in the sequence is always an
    ordinary character when used on its own. Here is a table of '~\~'
    constructs.

    - ~\|~ :: specifies an alternative. Two regular expressions /a/
      and /b/ with '~\|~' in between form an expression that matches
      some text if either /a/ matches it or /b/ matches it. It works
      by trying to match /a/, and if that fails, by trying to match
      /b/. '~\|~' applies to the largest possible surrounding
      expressions. Only a surrounding '~\( ... \)~' grouping can limit
      the grouping power of '~\|~'. Full backtracking capability
      exists to handle multiple uses of '~\|~'.
    - ~\( ... \)~ :: is a grouping construct that serves three
      purposes
      - To enclose a set of '~\|~' alternatives for other
        operations.
      - To enclose a complicated expression for the postfix operators
        '~*~', '~+~' and '~?~' to operate on.
      - To record a matched substring for future reference. This
        application is not a consequence of the idea of a
        parenthetical grouping; it is a separate feature that is
        assigned as a second meaning to the same '~\( ... \)~'
        construct. In practice there is usually no conflict between
        the two meanings; when there is a conflict, you can use a shy
        group, described below.
    - ~\(?: ... \)~ :: specifies a shy group that does not record
      the matched substring; you can't refer back to it with '~\d~'
      (see below). This is useful in mechanically combining regular
      expressions, so that you can add groups for syntactic purposes
      without interfering with the numbering of the groups that are
      meant to be referred to.
    - ~\d~ :: matches the same text that matched the /d/-th occurrence
      of a '~\( ... \)~' construct. This is called a back
      reference. After the end of a '~\( ... \)~' construct, the
      matcher remembers the beginning and end of the text matched by
      that construct. Then, later on in the regular expression, you
      can use '~\~' followed by the digit '~d~' to mean "match the
      same text matched by the /d/-th time by the '~\( ... \)~'
      construct". The strings matching the first nine '~\( ... \)~'
      constructs appearing in a regular expression are assigned
      numbers 1 through 9 in the order that the open-parentheses
      appear in the regular expression. So you can use '~\1~' through
      '~\9~' to refer to the text matched by the corresponding '~\(
      ... \)~' constructs. If a particular '~\( ... \)~' construct
      matches more than once (which can easily happen if it is
      followed by '~*~'), only the last match is recorded.
    - ~\`~ :: matches the empty string, but only at the beginning of
      the string or buffer (or its accessible portion) being matched
      against.
    - ~\'~ :: matches the empty string, but only at the end of the
      string or buffer (or its accessible portion) being matched
      against.
    - ~\=~ :: matches the empty string, but only at point.
    - ~\b~ :: matches the empty string, but only at the beginning or
      end of a word. '~\b~' matches at the beginning or end of the
      buffer regardless of what text appears next to it.
    - ~\B~ :: matches the empty string, but not at the beginning or
      end of a word.
    - ~\<~ :: matches the empty string, but only at the beginning of a
      word. '~\<~' matches at the beginning of the buffer only if a
      word-constituent character follows.
    - ~\>~ :: matches the empty string, but only at the end of a word
      '~\>~' matches at the end of the buffer only if the contents end
      with a word-constituent character.
    - ~\w~ :: matches any word-constituent character. The syntax table
      determines which characters these are.
    - ~\W~ :: matches any character that is not a word-constituent.
    - ~\_< :: matches the empty string, but only at the beginning of a
      symbol. A symbol is a sequence of one or more symbol-constituent
      characters. A symbol-constituent character is a character whose
      syntax is either '~w~' or '~_~'. '~\_<~' matches at the
      beginning of the buffer only if a symbol-constituent character
      follows. As with words, the syntax table determines which
      characters are symbol constituent.
    - ~\_>~ :: matches the empty string, but only at the end of a
      symbol. '~\_>~' matches at the end of the buffer only if the
      contents end with a symbol-constituent character.
    - ~\sc~ :: matches any character whose syntax is /c/. Here /c/ is
      a character that designates a particular syntax class: thus,
      '~w~' for word constituent, '~-~' or '~ ~' for whitespace, '~.~'
      for ordinary punctuation, etc.
    - ~\Sc~ :: matches any character whose syntax is not /c/.
    - ~\cc~ :: matches any characters that belong to the category
      /c/. For the description of the known categories, use the
      command ~describe-categories~.
    - ~\Cc~ :: matches any character that does not belong to category
      /c/.

    The constructs that pertain to words and syntax are controlled by
    the setting of the syntax table.
*** Regular Expression Example
*** Lax Matching During Searching
    By default, search commands perform /lax space matching/: each
    space, or sequence of spaces, matches any sequence of one or more
    whitespace characters in the text.

    Searches in Emacs by default ignore the case of the text they are
    searching through, if you specify the search string in lower
    case. Regexps and in particular character sets, behave
    likewise. This feature is known as /case folding/, and it is
    supported in both incremental and non-incremental search modes.

    An upper-case letter anywhere in the search string makes the
    search case-sensitive. This applies to regular expression search
    as well as to literal string search. The effect ceases if you
    delete the upper-case letter from the search string.
*** Replacement Commands
    The replace commands normally operate on the text from point to
    the end of the buffer. When the region is active, they operate on
    it instead.
**** Unconditional Replacement
**** Regexp Replacement
**** Replace Commands and Lax Matches
     If the first argument of a replace command is all lower case, the
     command ignores case while searching for occurrences to replace
     according to how the variables: ~case-fold-search~ and
     ~search-upper-case~ are set.

     In addition, when the newstring argument is all or partly lower
     case, replacement commands try to preserve the case pattern of
     each occurrence. ~replace-string~ can distinguish between three
     capitalization alternatives - lower case, all caps, and
     capitalized.

     If upper-case letters are used in the replacement string, they
     remain upper case every time that text is inserted. If upper-case
     letters are used in the first argument, the second argument is
     always substituted exactly as given, with no case conversion.
**** Query Replace
     You can reuse earlier replacements with the commands
     ~query-replace~ or ~query-replace-regexp~. When either these
     commands prompts for the search string, use ~M-p~ and ~M-n~ to
     show previous replacements in the form '~from -> to~', where
     /from/ is the search pattern, /to/ is its replacement, and the
     separator between them is determined by the value of the variable
     ~query-replace-from-to-separator~.

     If you type any other key, besides the predefined keys when in
     the ~query-replace~ context, then you exit the ~query-replace~,
     and the key is reread as part of a key sequence. Thus, if you
     type ~C-k~, it exits the ~query-replace~ and then kills to the
     end of line. In particular, ~C-g~ simply exits the
     ~query-replace~.

     To restart a ~query-replace~ once it is exited, use ~C-x ESC
     ESC~, which repeats the ~query-replace~ because it used the
     minibuffer to read its argument.
*** Other Search-and-Loop Commands
    This section details many commands that find matches for a regular
    expression. They all ignore case in matching, if the pattern
    contains no upper-case letters and ~case-fold-search~ is
    non-nil. Aside from ~multi-occur~ and
    ~multi-occur-in-matching-buffers~, which always search the whole
    buffer, all operate on the text from point to the end of the
    buffer, or on the region if it is active.

    Check out the specifics of each command in the command section.

    - ~multi-isearch-buffers~
    - ~multi-isearch-buffers-regexp~
    - ~multi-isearch-files~
    - ~multi-isearch-files-regexp~
    - ~occur~
    - ~multi-occur~
    - ~multi-occur-in-matching-buffers~
    - ~how-many~
    - ~flush-lines~
    - ~keep-lines~
** Commands for Fixing Typos
*** Undo
    Each buffer records changes individually, and the undo command
    always applies to the current buffer. You can undo all the changes
    in a buffer for as far back as the buffer's records go. Usually,
    each editing command makes a separate entry in the undo records,
    but some commands such as ~query-replace~ divide their changes
    into multiple entries for flexibility in undoing. Consecutive
    character insertion commands are usually grouped together into a
    single undo record, to make undoing less tedious.

    To begin to undo, type ~C-/~. This undoes the most recent change
    in the buffer, and moves point back to where it was before that
    change. Consecutive repetitions of ~C-/~ undo earlier and earlier
    changes in the current buffer. If all the recorded changes have
    already been undone, the undo command signals an error.

    Any command other than an undo command breaks the sequence of undo
    commands. Starting from that moment, the entire sequence of undo
    commands that you have just performed are themselves placed into
    the undo record. Therefore, to re-apply changes you have undone,
    type ~C-f~ or any other command that harmlessly breaks the
    sequence of undoing; then type ~C-/~ one or more times to undo
    some of the undo commands.

    Alternatively, if you want to resume undoing, without redoing
    previous undo commands, use the command ~undo-only~. This is like
    ~undo~, but will not redo changes you have just undone.

    If you notice that a buffer has been modified accidentally, the
    easiest way to recover is to type ~C-/~ repeatedly until the stars
    disappear from the front of the mode line. Whenever an undo
    command makes the stars disappear from the mode line, it means
    that the buffer contents are the same as they were when the file
    was last read in or saved.

    When there is an active region, any use of ~undo~ performs
    selective undo: it undoes the most recent change within the
    region, instead of the entire buffer. However, when Transient Mark
    mode is off, ~C-/~ always operates on the entire buffer, ignoring
    the region. In this case, you can perform selective undo by
    supplying a prefix argument to the ~undo~ command: ~C-u C-/~. To
    undo further changes in the same region, repeat the ~undo~ command
    (no prefix argument is needed).

    Some specialized buffers do not make undo records. Buffers whose
    names start with spaces never do; these buffers are used
    internally by Emacs to hold text that users don't normally look at
    or edit.

    When the undo information for a buffer becomes too large, Emacs
    discards the oldest records from time to time. You can specify how
    much undo information to keep by setting the variables
    ~undo-limit~, ~undo-strong-limit~, and ~undo-outer-limit~. Their
    values are expressed in bytes.

    The most recent change is never discarded unless it gets bigger
    than ~undo-outer-limit~. At that point, Emacs discarded the undo
    data and warns you about it. This is the only situation in which
    you cannot undo the last command. If this happens, you can
    increase the value of ~undo-outer-limit~ to make it even less
    likely to happen in the future. But if you didn't expect the
    command to create such large undo data, then it is probably a bug
    and you should report it.
*** Transposing Text
*** Case Conversion
*** Checking and Correcting Spelling
    Spell-checkers look up spelling in two dictionaries: the standard
    dictionary and your personal dictionary.

    A separate dictionary is used for word completion. The completion
    dictionary must be different because it cannot use the information
    about roots and affixes of the words, which spell-checking uses to
    detect variations of words. For some languages, there is a spell
    checking dictionary but no word completion dictionary.
** Keyboard Macros
   You define a keyboard macro by executing and recording the commands
   which are its definition. Put differently, as you define a keyboard
   macro, the definition is being executed for the first time. When
   you close the definition, the keyboard macro is defined and also
   has been, in effect, executed once. You can then do the whole thing
   over again by invoking the macro.

   Keyboard macros differ from ordinary Emacs commands in that they
   are written in the Emacs command language rather than in Lisp. This
   makes it easier for the novice tow rite them, and makes them more
   convenient as temporary hacks. However, the Emacs command language
   is not powerful enough as a programming language to be useful for
   writing anything intelligent or general. For such things, Lisp must
   be used.
*** Basic Use
    Most keyboard commands work as usual in a keyboard macro
    definition, with some exceptions. Typing ~C-g~ (~keyboard-quit~)
    quits the keyboard macro definition. Typing ~C-M-c~
    (~exit-recursive-edit~) can be unreliable: it works as you'd
    expect if exiting a recursive edit that started within the macro,
    but if it exits a recursive edit that started before you invoked
    the keyboard macro, it also necessarily exits the keyboard macro
    too. Mouse events are also unreliable, even though you can use
    them in a keyboard macro: when the macro replays the mouse event,
    it uses the original mouse position of that event, the position
    that the mouse had while you were defining the macro. The effect
    of this may be hard to predict.
* Vocabulary
** Distribution
*** Free Software
    GNU Emacs is /free software/; this means that everyone is free to
    use it and free to redistribute it under certain conditions.
** Introduction
*** Advanced Editor
    We call Emacs /advanced/ because it can do much more than simple
    insertion and deletion of text.
*** Self-Documenting Editor
    The fact we call Emacs /self-documenting/ means that at any time
    you can use special commands to find out what your options are, or
    to find our what any command does, or to find all the commands
    that pertain to a given topic.
*** Help Commands
    /Help commands/ are special commands you can use at any time to
    find out what your options are, or to find out what any command
    does, or to find all the commands that pertain to a given topic.
*** Customizable Editor
    The fact we call Emacs /customizable/ means that you can easily
    alter the behavior of Emacs commands in simple ways.
*** Extensible Editor
    The fact we call Emacs /extensible/ means that you can go beyond
    simple customization and create entirely new commands.
** The Organization of the Screen
*** Frame
    We will use the term /frame/ to mean a graphical window or
    terminal screen occupied by Emacs. Each frame consists of several
    distinct regions.
*** Menu Bar
    At the top of the frame is a /menu bar/, which allows you to
    access commands via a series of menus.
*** Tool Bar
    On a graphical display, directly below the menu bar is a /tool
    bar/, a row of icons that perform editing commands when you click
    on them.
*** Echo Area
    At the very bottom of the frame is an /echo area/, where
    informative messages are displayed and where you enter information
    when Emacs asks for it.
*** The Window
    This is the main area of the frame, below the tool bar (if one
    exists) and above the echo area. Henceforth in this manual, we
    will use the word "window" in this sense. Graphical display
    systems commonly use the word "window" with a different meaning;
    but, as stated above, we refer to those graphical windows as
    "frames".
*** Buffer
    An Emacs window is where the /buffer/ - the text or other graphics
    you are editing or viewing - is displayed.
*** Scroll Bar
    On a graphical display, the window possesses a /scroll bar/ on one
    side, which can be used to scroll through the buffer.
*** Mode Line
    The last line of the window is a /mode line/. This displays
    various information about what is going on in the buffer, such as
    whether there are unsaved changes, the editing modes that are in
    use, the current line number, and so forth.
*** Selected Window
    At any time, one window is the /selected window/. On a graphical
    display, the selected window shows a more prominent cursor
    (usually solid and blinking); other windows show a less prominent
    cursor (usually a hollow box). On a text terminal, there is only
    one cursor, which is shown in the selected window.
*** Current Buffer
    The buffer displayed in the selected window is called the /current
    buffer/, and it is where everything happens.
*** Point
    The cursor in the selected window shows the location where most
    editing commands take effect, which is called /point/.
*** Echoing
    The echo area is so-named because one of the things it is used for
    is /echoing/, which means displaying the characters of a
    multi-character command as you type.
*** Error Message
    The echo area is also used to display an /error message/ when a
    command cannot do its job. Error messages may be accompanied by
    beeping or by flashing the screen.
*** Informative Message
    Some commands display /informative messages/ in the echo area to
    tell you what the command has done, or to provide you with some
    specific information. These informative messages, unlike error
    messages, are not accompanied with a beep or a flash.
*** Minibuffer
    The echo area is also used to display the /minibuffer/, a special
    window where you can input arguments to commands, such as the name
    of a file to be edited.
*** Prompt String
    When the minibuffer is in use, the text displayed in the echo area
    begins with a /prompt string/, and the active cursor appears
    within the minibuffer, which is temporarily considered the
    selected window.
*** Coding System
    A /coding system/ is the character set of the text in the buffer.
*** Newline Characters
    Lines of text are separated by /newline characters/ in a file.
*** Major Mode
    A major mode is the principal editing mode for the buffer, such as
    Text mode, Lisp mode, C mode, and so forth.
*** Minor Mode
    /Minor modes/ are optional editing modes that provide additional
    features on top of the major mode.
*** Submenu
    An arrow on the right edge of a menu item means that it leads to a
    subsidiary menu, or /submenu/.
** Kinds of User Input
*** Simple Characters
    /Simple characters/, like '~a~', '~B~', '~3~', '~=~', and the
    space character (denoted as ~SPC~), are entered by typing the
    corresponding key.
*** Control Characters
    /Control characters/, such as ~RET~, ~TAB~, ~DEL~, ~ESC~, ~F1~,
    ~Home~, and ~LEFT~, are also entered by typing the corresponding
    key.
*** Modifier Keys
    Emacs also recognizes control characters that are entered using
    /modifier keys/. Two commonly-used modifier keys are ~Control~
    (usually labeled ~Ctrl~), and ~Meta~ (usually labeled ~Alt~).
*** Input Events
    Simple characters and control characters, as well as certain
    non-keyboard inputs such as mouse clicks, are collectively
    referred to as /input events/.
** Keys
*** Key Sequence
    A /key sequence/, or /key/ for short, is a sequence of one or more
    input events that is meaningful as a unit.
*** Complete Key
    If a key sequence invokes a command, we call it a /complete key/;
    for example, ~C-f~, ~C-x C-f~ and ~C-x 4 C-f~ are all complete
    keys.
*** Prefix Key
    If a key sequence isn't long enough to invoke a command, we call
    it a /prefix key/; from the preceding example, we see that ~C-x~
    and ~C-x 4~ are prefix keys.
** Keys and Commands
*** Commands
    This manual is full of passages that tell you what particular keys
    do. But Emacs does not assign meanings to keys directly. Instead,
    Emacs assigns meanings to named /commands/.
*** Binding
    Emacs gives keys their meanings by /binding/ them to commands.
*** Function
    Internally, each command is a special type of Lisp /function/, and
    the actions associated with the command are performed by running
    the function.
*** Keymaps
    The bindings between keys and commands are recorded in tables
    called /keymaps/.
*** Variables
    A /variable/ is a name used to store a value. Most of the
    variables documented in this manual are meant for customization:
    some command or other part of Emacs examines the variable and
    behaves differently according to the value that you set.
** Entering Emacs
*** Startup Screen
    When Emacs starts up, the initial frame displays a special buffer
    named '~*GNU Emacs*~'. This /startup screen/ contains information
    about Emacs and links to common tasks that are useful for
    beginning users.
*** Links
    To activate a link, either move point onto it and type ~RET~, or
    click on it with ~mouse-1~ (the left mouse button).
** Exiting Emacs
*** Killing Emacs
    /Killing Emacs/ means terminating the Emacs program.
*** Minimize
    On a graphical display, the command ~suspend-frame~ /minimizes/
    (or /iconifies/) the selected Emacs frame, hiding it in a way that
    lets you bring it back later (exactly how this hiding occurs
    depends on the window system).
*** Suspend Emacs
    On a text terminal, the ~suspend-frame~ command /suspends Emacs/,
    stopping the program temporarily and returning control to the
    parent process (usually a shell); in most shells, you can resume
    Emacs after suspending it with the shell command ~%emacs~.
** Basic Editing Commands
*** Graphic Character
    You can insert an ordinary /graphic character/ (e.g., '~a~',
    '~B~', '~3~', and '~=~') by typing the associated key.
*** Quote
    To insert a non-graphic character, or a character that your
    keyboard does not support, first /quote/ it by typing ~C-q~
    (~quoted-insert~).
*** Arrow Keys
    Most folks will recognize the /arrow keys/ present on most
    keyboards: ~RIGHT~, ~LEFT~, ~DOWN~, and ~UP~.
*** Semipermanent Goal Column
    When a /semipermanent goal column/ is in effect, the commands
    ~C-n~ and ~C-p~ always try to move to this column, or as close as
    possible to it, after moving vertically.
*** Screen Lines
    When a line of text in the buffer is longer than the width of the
    window, Emacs usually displays it on two or more /screen lines/.
*** Logical Lines
    /Logical lines/ are calculated according to the text lines in the
    buffer, rather than according to how the screen wrapped a long
    line into screen lines.
*** File
    Text that you insert in an Emacs buffer lasts only as long as the
    Emacs session. To keep any text permanently, you must put it in a
    /file/.
*** Minibuffer Argument
    Many commands use the minibuffer to read a /minibuffer argument/,
    and you type ~RET~ to terminate the argument.
*** Visiting
    Emacs obeys the command ~find-file~ by /visiting/ the file: it
    creates a buffer, copies the contents of the file into the buffer,
    and displays the buffer for editing.
*** Save
    If you alter the text in a file that you are visiting via Emacs,
    you can /save/ the new text in the file by typing ~C-x C-s~
    (~save-buffer~). This copies the altered buffer contents back into
    the file you are visiting, making them permanent.
*** Line Wrapping
    Sometimes, a line of text in the buffer - a logical line - is too
    long to fit in the window, and Emacs displays it as two or more
    screen lines. This is called /line wrapping/ or /continuation/.
*** Continued Line
    Sometimes, a line of text in the buffer - a logical line - is too
    long to fit in the window, and Emacs displays it as two or more
    screen lines. This long logical line is called a /continued
    line/.
*** Truncate
    Emacs can optionally /truncate/ long logical lines instead of
    continuing them. This means that every logical line occupies a
    single screen line; if it is longer than the width of the window,
    the rest of the line is not displayed.
*** Word Wrapping
    Sometimes, you may need to edit files containing many long logical
    lines, and it may not be practical to break them all up by adding
    newlines. In that case, you can use Visual Line mode, which
    enables /word wrapping/: instead of wrapping long lines exactly at
    the right window edge, Emacs wraps them at the word boundaries
    (i.e., space or tab characters) nearest to the right window edge.
*** Argument
    In the terminology of mathematics and computing, /argument/ means
    "data provided to a function or operation".
*** Numeric Argument
    You can give any Emacs command a /numeric argument/. The easiest
    way to specify a numeric argument is to type a digit and/or a
    minus sign while holding down the ~Meta~ key.
*** Prefix Argument
    We use the term /prefix argument/ to emphasize that you type such
    arguments *before* the command, and to distinguish them from
    minibuffer arguments, which are entered *after* invoking the
    command.
** The Minibuffer
*** Minibuffer
    The /minibuffer/ is where Emacs commands read complicated
    arguments, such as file names, buffer names, Emacs command names,
    or Lisp expressions. We call it the "minibuffer" because it's a
    special-purpose buffer with a small amount of screen space.
*** Prompt
    When the minibuffer is in use, it appears in the echo area, with a
    cursor. The minibuffer starts with a /prompt/, usually ending with
    a colon. The prompt states what kind of input is expected, and how
    it will be used.
*** Default Argument
    Sometimes, the prompt shows a /default argument/, inside
    parentheses before the colon. This default will be used as the
    argument if you just type ~RET~.
*** Default Directory
    When the minibuffer is used to read a file name, it typically
    starts out with some initial text ending in a slash. This is the
    /default directory/.
*** Read-Only
    A buffer that is /read-only/ usually can be navigated, but it
    cannot be changed.
*** Completion Commands
    Inside a minibuffer, the keys ~TAB~, ~SPC~, and ~?~ are often
    bound to /completion commands/, which allow you to easily fill in
    the desired text without typing all of it.
*** Completion
    You can often use a feature called /completion/ to help enter
    minibuffer arguments. This means that after you type part of the
    argument, Emacs can fill in the rest, or some of it, based on what
    was typed so far.
*** Completion Alternatives
    When completion is available, certain keys (usually ~TAB~, ~RET~,
    and ~SPC~) are rebound in the minibuffer to special completion
    commands. These commands attempt to complete the text in the
    minibuffer, based on a set of /completion alternatives/ provided
    by the command that requested the argument.
*** Completion Styles
    Emacs performs completion using one or more /completion styles/ -
    sets of criteria for matching minibuffer text to completion
    alternatives.
*** Wildcard
    A '~*~' in the minibuffer text is treated as a /wildcard/ - it
    matches any string of characters at the corresponding position in
    the completion alternative.
*** Minibuffer History List
    Every argument that you enter with the minibuffer is saved in a
    /minibuffer history list/ so you can easily use it again later.
*** Command History
    Every command that uses the minibuffer once is recorded on a
    special history list, the /command history/, together with the
    values of its arguments, so that you can repeat the entire
    command.
** Running Commands by Name
*** Obsolete Commands
    /Obsolete commands/ are those for which newer, better alternatives
    exist, and which are slated for removal in some future Emacs
    release.
** Help
*** Help Buffer
    Many help commands display their information in a special /help
    buffer/. In this buffer, you can type ~SPC~ and ~DEL~ to scroll
    and type ~RET~ to follow hyperlinks.
*** Syntax Table
    The /syntax table/ says which characters are opening delimiters,
    which are parts of words, and so on.
*** Documentation String
    The /documentation string/ describes exactly what the command
    does.
*** Apropos
    The /apropos/ commands answer questions like, "what are the
    commands for working with files?"
*** Apropos Pattern
    An /apropos pattern/, is either a word, a list of words, or a
    regular expression.
*** Hyperlink
    When a function name, variable name, or face name appears in the
    documentation in the help buffer, it is normally an underlined
    /hyperlink/. To view the associated documentation, move point
    there and type ~RET~ (~help-follow~), or click on the hyperlink
    with ~mouse-1~ or ~mouse-2~. Doing so replaces the contents of the
    help buffer.
*** Packages
    Most optional features in Emacs are grouped into /packages/. Emacs
    contains several hundred built-in packages, and more can be
    installed over the network.
*** Keywords
    To make it easier to find packages related to a topic, most
    packages are associated with one more more /keywords/ based on
    what they do.
*** Active Text
    /Active text/ is text that does something special in response to
    mouse clicks or ~RET~.
*** Tooltip
    On graphical displays, as well as some text terminals which
    support mouse tracking, moving the mouse over the active text
    displays the help text as a /tooltip/.
** The Mark and the Region
*** The Mark
    Many Emacs commands operate on an arbitrary contiguous part of the
    current buffer. To specify the text for such a command to operate
    on, you set /the mark/ at one end of it, and move point to the
    other end.
*** The Region
    The text between the point and the mark is called /the
    region/. The region always extends between point and the mark, no
    matter which one comes earlier in the text; each time you move
    point, the region changes.
*** Activate The Mark
    Setting the mark at a position in the text also /activates the
    mark/. When the mark is active, we also say that the region is
    active; Emacs indicates its extent by highlighting the text within
    it.
*** Deactivate The Mark
    After certain non-motion commands, including any command that
    changes the text in the buffer, Emacs automatically /deactivates
    the mark/; this turns off the highlighting.
*** Shift-Selection
    You can set the mark by holding down the shift key while typing
    certain cursor motion commands (such as ~S-RIGHT~, ~S-C-f~,
    ~S-C-n~, etc.). This is called /shift-selection/. It sets the mark
    at point before moving point, but only if there is no active mark
    set via a previous shift-selection or mouse commands.
*** Primary Selection
    Under X, every time the active region changes, Emacs saves the
    text in the region to the /primary selection/.
*** Inactive Region
    The /inactive region/ is the text between point and the position
    at which the mark was last set.
*** Mark Ring
    Each buffer remembers previous locations of the mark, in the /mark
    ring/. Commands that set the mark also push the old mark onto this
    ring. One of the uses of the mark ring is to remember spots that
    you may want to go back to.
*** Global Mark Ring
    In addition to the ordinary mark ring that belongs to each buffer,
    Emacs has a single /global mark ring/. Each time you set a mark,
    this is recorded in the global mark ring in addition to the
    current buffer's own mark ring, if you have switched buffers since
    the previous mark setting. Hence, the global mark ring records a
    sequence of buffers that you have been in, and, for each buffer, a
    place where you set the mark.
** Killing and Moving Text
*** Killing
    In Emacs, /killing/ means erasing text and copying it to remember
    for later.
*** Kill Ring
    In Emacs, killing text copies it into the /kill ring/. The kill
    ring is a list of blocks of text that were previously killed.
*** Yanking
    /Yanking/ means bringing text from the kill ring back into the
    buffer.
*** Kill Commands
    Most commands which erase text from the buffer save it in the kill
    ring. These are known as /kill commands/, and their names normally
    contain the word '~kill~'.
*** Delete Commands
    Commands that erase text but do not save it in the kill ring are
    known as /delete commands/; their names usually contain the word
    '~delete~'.
*** Read-Only Text
    Some specialized buffers contain /read-only text/, which cannot be
    modified and therefore cannot be killed.
*** Clipboard
    In most graphical desktop environments, you can transfer data
    (usually text) between different applications using a system
    facility called the /clipboard/.
*** Clipboard Manager
    Many X desktop environments support a feature called the
    /clipboard manager/. If you exit Emacs while it is the current
    "owner" of the clipboard data, and there is a clipboard manager
    running, Emacs transfers the clipboard data to the clipboard
    manager so that it is not lost.
*** Primary Selection
    Under the X Window System, there exists a /primary selection/
    containing the last stretch of text selected in an X application
    (usually by dragging the mouse). Typically, this text can be
    inserted into other X applications by ~mouse-2~ clicks. The
    primary selection is separate from the clipboard. Its contents are
    more fragile; they are overwritten each time you select text with
    the mouse, whereas the clipboard is only overwritten by explicit
    cut or copy commands.
*** Secondary Selection
    In addition to the primary selection, the X Window System provides
    a second similar facility known as the /secondary
    selection/.
*** Rectangles
    /Rectangle/ commands operate on rectangular areas of the text: all
    the characters between a certain pair of columns, in a certain
    range of lines.
*** Region-Rectangle
    To specify a rectangle for a command to work on, set the mark at
    one corner and point at the opposite corner. The rectangle thus
    specified is called the /region-rectangle/.
*** Last Killed Rectangle
    There are two ways to erase the text in a rectangle: ~C-x r d~
    (~delete-rectangle~) to delete the text outright, or ~C-x r k~
    (~kill-rectangle~) to remove the text and save it as the /last
    killed rectangle/.
** Registers
*** Registers
    Emacs /registers/ are compartments where you can save, rectangles,
    positions, and other things for later use.
*** Bookmarks
    /Bookmarks/ record files and positions in them, so you can return
    to those positions when you look at the file again.
** Controlling the Display
*** Scrolling
    If a window is too small to display all the text in its buffer, it
    displays only a portion of it. /Scrolling/ commands change which
    portion of the buffer is displayed.
*** Recentering
    The ~C-l~ (~recenter-top-bottom~) command /recenters/ the selected
    window, scrolling it so that the current screen line is exactly in
    the center of the window, or as close to the center as possible.
*** Automatic Scrolling
    Emacs performs /automatic scrolling/ when point moves out of the
    visible portion of the text.
*** Horizontal Scrolling
    /Horizontal scrolling/ means shifting all the lines sideways
    within a window, so that some of the text near the left margin is
    not displayed.
*** Narrowing
    /Narrowing/ means focusing in on some portion of the buffer,
    making the rest temporarily inaccessible.
*** Accessible Portion
    The portion of a narrowed buffer which you can still get to is
    called the /accessible portion/.
*** Widening
    Canceling the narrowing, which makes the entire buffer once again
    accessible, is called /widening/.
*** Restriction
    The bounds of narrowing in effect in a buffer are called the
    buffer's /restriction/.
*** Faces
    Emacs can display text in several different styles, called
    /faces/.
*** Face Attributes
    Each face can specify various /face attributes/, such as the font,
    height, weight, slant, foreground and background color, and
    underlining or overlining.
*** Color Name
    A /color name/ is a pre-defined name, such as '~dark orange~' or
    '~medium sea green~'.
*** RGB Triplet
    An /RGB triplet/ is a string of the form '~#RRGGBB~'. Each of the
    primary color components is represented by a hexadecimal number
    between '~00~' (intensity 0) and '~FF~' (the maximum intensity).
*** Fontifies
    Font Lock mode is a minor mode, always local to a particular
    buffer, which assigns faces to (or /fontifies/) the text in the buffer.
*** Just-In-Time Lock
    As you scroll through the buffer, each portion that becomes
    visible is fontified as soon as it is displayed; this type of Font
    Lock is called /Just-In-Time Lock/ (or /JIT Lock/).
*** Highlighting
    Highlight Changes mode is a minor mode that /highlights/ the part
    of the buffer that were changed most recently, by giving that text
    a different face.
*** Fringes
    On graphical displays, each Emacs window normally has narrow
    /fringes/ on the left and right edges. The fringes are used to
    display symbols that provide information about the text in the
    window.
*** Trailing Whitespace
    It is easy to leave unnecessary spaces at the end of a line, or
    empty lines at the end of a buffer, without realizing it. In most
    cases, this /trailing whitespace/ has no effect, but sometimes it
    can be a nuisance.
*** Printing Characters
    Most characters are /printing characters/: when they appear in a
    buffer, they are displayed literally on the screen. Printing
    characters include ASCII numbers, letters, and punctuation
    characters, as well as many non-ASCII characters.
*** Control Characters
    The ASCII character set contains non-printing /control
    characters/. Two of these are displayed specially: the newline
    character (Unicode code point ~U+000A~) is displayed by starting a
    new line, while the tab character (~U+0009~) is displayed as a
    space that is extended to the next tab stop column (normally every
    8 columns).
*** Octal Escape Sequences
    The raw bytes with codes ~U+0080~ (octal 200) through ~U+009F~
    (octal 237) are displayed as /octal escape sequences/, with the
    ~escape-glyph~ face.
*** Glyphless Characters
    On graphical displays, some characters may have no glyphs in any
    of the fonts available to Emacs. These /glyphless characters/ are
    normally displayed as boxes containing the hexadecimal character code.
*** Truncation
    As an alternative to continuation, Emacs can display long lines by
    /truncation/. This means that all the characters that do not fit
    in the width of the screen or window do not appear at all.
*** Word Wrap
    Another alternative to ordinary line continuation is to use /word
    wrap/. Here, each long logical line is divided into two or more
    screen lines, like in ordinary line continuation. However, Emacs
    attempts to wrap the line at the word boundaries near the right
    window edge.
** Searching and Replacement
*** Incremental Search
    The principal search command in Emacs is /incremental/: it begins
    searching as soon as you type the first character of the search
    string. As you type in the search string, Emacs shows you where
    the string (as you have typed it so far) would be found.
*** Current Match
    The /current match/ is the buffer text that matches the search
    string.
*** Wrapping Around
    If a search is failing and you ask to repeat it by typing another
    ~C-s~, it starts again from the beginning of the buffer. Repeating
    a failing reverse search with ~C-r~ starts again from the
    end. This is called /wrapping around/.
*** Search Ring
    To reuse earlier search strings, use the /search ring/.
*** Word Search
    A /word search/ finds a sequence of words without regard to the
    type of punctuation between them.
*** Symbol
    The meaning of /symbol/ can depend on the major mode, and usually
    refers to a source code token, such as a Lisp symbol in Emacs Lisp
    mode.
*** Symbol Search
    A /symbol search/ is much like an ordinary search, except that the
    boundaries of the search must match the boundaries of a symbol.
*** Regular Expression
    A /regular expression/ is a pattern that denotes a class of
    alternative strings to match.
*** Regexp
    The term /regexp/ is an abbreviation of the phrase "Regular
    Expression".
*** Ordinary Characters
    An /ordinary character/ in the context of regular expressions
    matches that same character and nothing else.
*** Special Characters
    The /special characters/ are '~$^.*+?[\~'. The character '~]~' is
    special if it ends a character alternative. The character '~-~' is
    special inside a character alternative. Some characters are
    special if it is preceded by '~\~'.
*** Character Set
    In the simplest case, the characters between the two brackets in
    a /character set/ are what the set can match in the context of a
    regular expression.
*** Character Class
    A '~[:~' and balancing '~:]~' enclose a /character class/ inside a
    character set.
*** Complemented Character Set
    A /complemented character set/ matches any character except the
    ones specified. This is in the context of a regular expression
*** Shy Group
    A /shy group/ does not record the matched substring; you can't
    refer back to it with '~\d~'. This is in the context of regular
    expressions.
*** Back Reference
    In a regular expression, the construct '~\d~', where /d/ is some
    digit from 1 thru 9, matches the same text that matched the /d/-th
    occurrence of a '~\( ... \)~' construct. This is called a /back
    reference/.
*** Character Equivalence
    Normally, you'd want search commands to disregard certain minor
    differences between the search string you type and the text being
    searched. For example, sequences of whitespace characters of
    different length are usually perceived as equivalent; letter-case
    differences usually don't matter; etc. This is known as /character
    equivalence/.
*** Lax Space Matching
    By default, search commands perform /lax space matching/: each
    space, or sequence of spaces, matches any sequence of one or more
    whitespace characters in the text.
*** Case Folding
    Searches in Emacs by default ignore the case of the text they are
    searching through, if you specify the search string in lower
    case. Regexps and in particular character sets, behave
    likewise. This feature is known as /case folding/, and it is
    supported in both incremental and non-incremental search modes.
*** Character Folding
    Case folding disregards case distinctions among characters, making
    upper-case characters match lower-case variants, and vice versa. A
    generalization of case folding is /character folding/, which
    disregards wider classes of distinctions among similar
    characters. Matches disregard the diacritics that distinguish
    these variants. In addition, letters match other characters that
    resemble it, or have it as a part of their graphical
    representation.
*** Equivalent Character Sequences
    Character sequences that are not identical, but match under
    character folding are known as /equivalent character sequences/.
*** Search String
    The /search string/ is the string or regular expression that you
    use to find appropriate matches that already exist within the
    buffer you are searching.
*** Replacement String
    When searching, the /replacement string/ is the string of text
    that you can opt to replace any match you found while searching.
** Commands for Fixing Typos
*** Undo
    The /undo/ command reserves recent changes in the buffer's text.
*** Selective Undo
    A /selective undo/ undoes the most recent changes within an active
    region.
*** Garbage Collection
    When the undo information for a buffer becomes too large, Emacs
    discards the oldest records from time to time (during /garbage
    collection/).
*** Near-Misses
    A list of /near-misses/ are words that are close to an incorrect
    word.
** Keyboard Macros
*** Keyboard Macro
    A /keyboard macro/ is a command defined by an Emacs user to stand
    for another sequence of keys.
* Modes
** The Organization of the Screen
*** Size Indication mode
    you can display the size of the buffer in the Mode Line

    [[The Mode Line][first mention]]
*** Column Number mode
    You can display the current column in the Mode Line

    [[The Mode Line][first mention]]
** Basic Editing Commands
*** Auto Fill mode
    Splits lines automatically when they get too long

    [[Inserting Text][first mention]]
*** Overwrite mode
    Causes inserted characters to replace (overwrite) existing text,
    instead of shoving it to the right.

    [[Inserting Text][first mentioned]]
*** Visual Line mode
    Enables word wrapping: instead of wrapping long lines exactly at
    the right window edge, Emacs wraps them at the word boundaries
    (i.e., space or tab characters) nearest to the right window
    edge. Visual Line mode also redefines editing commands such as
    C-a, C-n, and C-k to operate on screen lines rather than logical
    lines.
*** Line Number mode
    The current line number of point appears in the mode line when
    this mode is enabled.
*** Column Number mode
    Display the current column number in the mode line.
*** HL Line mode
    Highlights the line containing point.
** The Minibuffer
*** Minibuffer Electric Default mode
    Emacs hides the default argument as soon as you modify the
    contents of the minibuffer.
*** File Name Shadow mode
    The ignored part of the file name is dimmed if the terminal allows
    it. And to disable this dimming disable this mode.
*** Minibuffer Inactive mode
    When the minibuffer is not active in the Echo Area, then that is a
    particular mode that has hooks etc.
** Help
*** Help Mode
    Help buffers provide the same commands as View mode (not yet
    defined). Help buffers normally provide a definition, a list of
    commands or symbols. Not as heavily formatted as documentation,
    but still provides very helpful insight.
** The Mark and the Region
*** Transient Mark mode
    When a region is active, Emacs indicates its extent by
    highlighting the text within it. After certain non-motion
    commands, including any command that changes the text in the
    buffer, Emacs automatically deactivates the mark; this turns off
    the highlighting.
*** Delete Selection mode
    By default, text insertion occurs normally even if the mark is
    active - for example, typing ~a~ inserts the character 'a', then
    deactivates the mark. Delete Selection mode, a minor mode,
    modifies this behavior: if you enable this mode, then inserting
    text while the mark is active causes the text in the region to be
    deleted first.
*** Shift Select mode
    Minor mode specifying that shift selection is allowed. Set
    corresponding variable to ~nil~ to turn off shift-selection
** Killing and Moving Text
*** Rectangle Mark mode
    When this mode is enabled, commands that resize the region do so
    in a rectangular fashion, and killing and yanking operate on the
    rectangle. The mode persists only as long as the region is
    active.
*** CUA mode
    Sets up key bindings that are compatible with the Common User
    Access (CUA) system used in many other applications.

    When CUA mode is enabled, they keys ~C-x~, ~C-c~, ~C-v~, and ~C-z~
    invoke commands that cut (kill), copy, paste (yank), and undo
    respectively. The ~C-x~ and ~C-c~ keys perform cut and copy only
    if the region is active. Otherwise, they still act as prefix keys,
    so that standard Emacs commands like ~C-x C-c~ still work.

    To enter an Emacs command like ~C-x C-f~ while the mark is active,
    use one of the following methods: either hold ~<Shift>~ together
    with the prefix key, e.g., ~S-C-x C-f~, or quickly type the prefix
    key twice, e.g., ~C-x C-x C-f~.

    this mode by default activates Delete-Selection mode so that typed
    text replaces the active region.

    This mode provides enhanced rectangle support with visible
    rectangle highlighting. Use ~C-<RET>~ to start a rectangle, extend
    it using the movement commands, and cut or copy it using ~C-x~ or
    ~C-c~. ~<RET>~ moves the cursor to the next (clockwise) corner of
    the rectangle, so you can easily expand it in any
    direction. Normal text you type is inserted to the left or right
    of each line in the rectangle (on the same side as the cursor).

    With CUA you can easily copy text and rectangles into and out of
    registers by providing a one-digit numeric prefix to the kill,
    copy, and yank commands, e.g., ~C-1 C-c~ copies the region into
    register 1, and ~C-2 C-v~ yanks the contents of register 2.

    This mode also has a global mark feature which allows easy moving
    and copying of text between buffers. Use ~C-S-<SPC>~ to toggle the
    global mark on and off. When the global mark is on, all text that
    you kill or copy is automatically inserted at the global mark, and
    text you type is inserted at the global mark rather than at the
    current position.
*** CUA Rectangle Mark mode
    Uses the same rectangle support as the CUA mode without needing to
    enable CUA mode.

    Use ~C-<RET>~ to start a rectangle, extend it using the movement
    commands. <RET> moves the cursor to the next (clockwise) corner of
    the rectangle, so you can easily expand it in any
    direction. Normal text you type is inserted to the left or right
    of each line in the rectangle (on the same side as the cursor).
** Controlling the Display
*** View mode
    View mode is a minor mode that lets you scan a buffer by
    sequential screenfuls. It provides commands for scrolling through
    the buffer conveniently but not for changing it. Apart from the
    usual Emacs cursor motion commands, you can type ~<SPC>~ to scroll
    forward one window, ~S-<SPC>~ or ~<DEL>~ to scroll backward, and
    ~s~ to start an incremental search.
*** Follow mode
    Follow mode is a minor mode that makes two windows, both showing
    the same buffer, scroll as a single tall virtual window. To use
    Follow mode, go to a frame with just one window, split it into two
    side-by-side windows using ~split-window-right~ usually ~C-x 3~,
    and then use the command ~follow-mode~. From then on, you can edit
    the buffer in either of the two windows, or scroll either one; the
    other window follows it.

    In Follow mode, if you move point outside the portion visible in
    one window and into the portion visible in the other window, that
    selects the other window - again, treating the two as if they were
    parts of one large window.
*** Text Scale mode
    Absolutely unclear what the heck this mode is
*** Font Lock mode
    Font Lock mode is a minor mode, always local to a particular
    buffer, which assigns faces to (or fontifies) the text in the
    buffer. Each buffer's major mode tells Font Lock mode which text
    to fontify; for instance, programming language modes fontify
    syntactically relevant constructs like comments, strings, and
    function names.

    Font Lock mode is enabled by default in major modes that support
    it.
*** Highlight Changes mode
    Highlight Changes mode is a minor mode that /highlights/ the parts
    of the buffer that were changed most recently, by giving that text
    a different face.
*** Hi Lock mode
    Hi Lock mode is a minor mode that highlights text that matches
    regular expressions you specify. For example, you can use it to
    highlight all the references to a certain variable in a program
    source file, highlight certain parts in a voluminous output of
    some program, or highlight certain names in an article.
*** Fringe mode
    Display fringes on left and right edges of each Emacs window.
*** Whitespace mode
    Whitespace mode is a buffer-local minor mode that lets you
    visualize many kinds of whitespace in the buffer, by either
    drawing the whitespace characters with a special face or
    displaying them as special glyphs.
*** Global Whitespace mode
    A global minor mode that lets you visualize whitespace in all
    buffers.
*** Size Indication mode
    The buffer percentage /pos/ indicates the percentage of the buffer
    above the top of the window. You can additionally display the size
    of the buffer by turning on this mode. The size will be displayed
    immediately following the buffer percentage like this:
    #+BEGIN_SRC emacs-lisp
    pos of size
    #+END_SRC

    Here /size/ is the human readable representation of the number of
    characters in the buffer, which means that '~k~' for 10^3, '~M~'
    for 10^6, '~G~' for 10^9, etc., are used to abbreviate.
*** Line Number mode
    The current line number of point appears in the mode line when
    this mode is enabled. The line number appears after the buffer
    percentage /pos/, with the letter '~L~' to indicate what it
    is. However, when both this mode and Column Number mode are
    enabled, the line and column numbers are displayed in parentheses,
    the line number first, rather than with '~L~' and '~C~'. For
    example '~(561, 2)~'.
*** Column Number mode
    You can display the current column number by turning on Column
    Number mode. The column number is indicated by the letter
    '~C~'. However, when both this mode and Line Number mode are
    enabled, the line and column numbers are displayed in parentheses,
    the line number first, rather than with '~L~' and '~C~'. For
    example '~(561, 2)~'.

    In this mode, the displayed column number counts from zero
    starting at the left margin of the window.
*** Display Time mode
    Emacs can optionally display the time and system load in all mode
    lines. This minor mode is the mode that accomplishes this. The
    information added to the mode line looks like this:

    #+BEGIN_SRC
    hh:mmPM l.ll
    #+END_SRC

    Here /hh/ and /mm/ are the hour and minute, followed always be
    '~AM~' or '~PM~'. /l.ll/ is the average number, collected for the
    last few minutes, of processes in the whole system that were
    either running or ready to run (i.e., were waiting for an
    available processor). (Some fields may be missing if your
    operating system cannot support them.)

    If you prefer time displays in 24-hour format, set the variable
    ~display-time-24hr-format~ to ~t~.

    The word '~Mail~' appears after the load level if there is mail
    for you that you have not read yet. On graphical displays, you can
    use an icon instead of '~Mail~' by customizing
    ~display-time-use-mail-icon~; this may save some space on the mode
    line. You can customize ~display-time-mail-face~ to make the mail
    indicator prominent. Use ~display-time-mail-file~ to specify the
    mail file to check, or set ~display-time-mail-directory~ to
    specify the directory to check for incoming mail (any nonempty
    regular file in the directory is considered to be newly arrived
    mail).
*** Display Battery mode
    When running Emacs on a laptop computer, you can display the
    battery charge on the mode-line using this mode.
*** Blink Cursor mode
    Minor mode that makes sure the cursor blinks a number of times
    based on the variable ~blink-cursor-blinks~.
*** Visual Line mode
    In this mode, each long logical line is divided into two or more
    screen lines, like in ordinary line continuation. However, Emacs
    attempts to wrap the line at word boundaries near the right window
    edge. (If the line's direction is right-to-left, it is wrapped at
    the left window edge instead.)

    In Visual Line mode, some editing commands work on screen lines
    instead of logical lines: ~C-a~ (~beginning-of-visual-line~) moves
    to the beginning of the screen line, ~C-e~ (~end-of-visual-line~)
    moves to the end of the screen line, and ~C-k~
    (~kill-visual-line~) kills text to the end of the screen line.

    By default, word-wrapped lines do not display fringe
    indicators. Visual Line mode is often used to edit files that
    contain many long logical lines, so having a fringe indicator for
    each wrapped line would be visually distracting. You can change
    this by customizing the variable ~visual-line-fringe-indicators~.
*** Display Line Numbers mode
    If you want to have Emacs display line numbers for every line in
    the buffer, you can turn on this mode. The variable
    ~display-line-numbers-type~ controls which sub-mode of line-number
    display will be active for this mode. Here is a description of
    these sub-modes:
    - ~t~ :: Display (an absolute) line number before each
      non-continuation screen line that displays buffer text. If the
      line is a continuation line, or if the entire screen line
      displays a display or an overlay string, that line will not be
      numbered.
    - ~relative~ :: Display relative line numbers before
      non-continuation lines which show buffer text. The line numbers
      are relative to the line showing point, so the numbers grow both
      up and down as lines become farther from the current line
    - ~visual~ :: This value causes Emacs to count lines visually: only
      lines actually shown on the display will be counted
      (disregarding any lines in invisible parts of text), and lines
      which wrap to consume more than one screen line will be numbered
      that many times. The displayed numbers are relative, as with
      ~relative~ value above. This is handy in modes that fold text,
      such as outline mode, and when you need to move by exact number
      of screen lines.
    - anything else :: Any other non-nil value is treated as ~t~.

    Note that line numbers are not displayed in the minibuffer and in
    the tooltips, even if you turn on ~display-line-numbers-mode~
    globally.

    When Emacs displays relative line numbers, you can control the
    number displayed before the current line, the line showing
    point. By default, Emacs displays the absolute number of the
    current line there, even though all the other line numbers are
    relative. If you customize the variable
    ~display-line-numbers-current-absolute~ to a ~nil~ value, the
    number displayed for the current line will be zero.

    In a narrowed buffer lines are normally numbered starting at the
    beginning of the narrowing. However, if you customize the variable
    ~display-line-numbers-widen~ to a non-nil value, line numbers will
    disregard any narrowing and will start at the first character of
    the buffer

    In Selective Display mode, and other modes that hide many lines
    from display (such as Outline and Org modes), you may wish to
    customize the variables ~display-line-numbers-width-start~ and
    ~display-line-numbers-grow-only~, or set
    ~display-line-numbers-width~ to a large enough value, to avoid
    occasional miscalculations of space reserved for the line
    numbers.
** Searching and Replacement
*** Occur mode
    Prompt for a regexp, and display a list showing each line in the
    buffer that contains a match for it. If you type ~M-n~ at the
    prompt, you can reuse search strings from previous incremental
    searches. The text that matched is highlighted using the ~match~
    face.

    Note that matches for the regexp you type are extended to include
    complete lines, and a match that starts before the previous match
    ends is not considered a match.
*** Occur Edit mode
    While in this mode, edits made to the standard occur entries are
    also applied to the text in the originating buffer.
** Commands for Fixing Typos
*** Flyspell mode
    Flyspell mode is a minor mode that performs automatic
    spell-checking of the text you type as you type it. When it finds
    a word that it does not recognize, it highlights that word. Note
    that as Flyspell mode needs to check each word across which you
    move, it will slow down cursor motivation and scrolling
    commands. It also doesn't automatically check the text you didn't
    type or move across.
*** Flyspell Prog mode
    Flyspell Prog mode works just like ordinary Flyspell mode, except
    that it only checks words in comments and string contants.
* Contexts
** anywhere
   literally anywhere
** editing
   when editing a buffer
** navigating
   When in a buffer that is possible to navigate with the standard
   ~C-f~, ~C-b~, ~C-n~, ~C-p~ commands
** minibuffer
   when in the minibuffer
** completion-buffer
   when in the window with current completion options
** password
   when typing in a password for minibuffer
   [[Entering passwords]]
** yes-no
   when echo prompt ends with ~(y or n)~
   [[Yes or No Prompts]]
** help
   Window that appears below buffer with some contents of a help
   buffer. One such help window is activated with [[help-for-help]]
** info
   The documentation browser. Able to read just every possible
   documentation imaginable.
** special-text
   When one location inside text might behave differently from the
   rest of the text. For example, links in *Help* buffers. Seems to
   mostly be for links or clickable locations in text.
** after-yank
   Occasionally a command will only work when it is made immediately
   after making a yank. Particularly: ~C-y~
** rectangle
   When Rectangle Mark mode is enabled and therefore an active region
   is highlighted as a rectangle.
** cua
   CUA mode which sets up key bindings that are compatible with the
   Common User Access (CUA) system used in many other applications.
** cua-rectangle
   The enhanced rectangle selection mode provided by cua. Check out
   CUA Rectangle Mark mode
** register
   When there is a prompt for a register in the minibuffer
** bookmark
   Bookmark Menu mode
** view
   View mode
** follow-ready
   A frame is ready for Follow mode when a frame contains two windows
   side by side with the same buffer in both windows.
** mini-select-list
   Some commands have an option for selecting something from a list
   including faces, previous commands, etc. to complete the
   command. This context is when you are at the point in the command
   where the minibuffer is asking you to provide one of these options
   from a particular list.
** visual-line-mode
   In Visual Line mode, some editing commands work on screen lines
   instead of logical lines.
** isearch
   Whenever incremental search is currently activated. See commands
   ~isearch-forward~ and ~isearch-backward~.
** isearch-after-edit
   There are some commands that only work within isearch and after
   having made an edit. For example after the following commands: ~C-s
   M-e~.
** isearch-after-yank
   There are some commands that only work within isearch and after
   having made a yank. For example after the following commands: ~C-s
   C-y~.
** query-replace
   There are some commands that are only valid as you are working on a
   ~query-replace~ or a ~query-replace-regexp~ command.
** recursive-edit
   A recursive edit is a situation in which you are using Emacs
   commands to perform arbitrary editing while in the middle of
   another Emacs command.
** occur
   Occur mode
** occur-edit
   Occur Edit mode
** ispell
   Interactive Spell-check mode. Check ~C-$~ (~ispell~)
** flyspell
   Flyspell mode is currently highlighting misspelled words
* Commands
** The Organization of the Screen
*** what-cursor-position                                   :inform:char:echo:
    :PROPERTIES:
    :Command:  C-x =
    :Description: Display char code, position, column of character after point
    :Context:  navigating
    :END:
*** keyboard-quit                                              :undo:command:
    :PROPERTIES:
    :Command:  C-g
    :Description: Quit: Cancel running or partially typed command
    :Context:  anywhere
    :END:
*** menu-bar-open                                                      :menu:
    :PROPERTIES:
    :Command:  <F10>
    :Description: Invoke first menu bar item.
    :Context:  anywhere
    :END:
*** tmm-menubar                                                        :menu:
    :PROPERTIES:
    :Command:  M-`
    :Description: Select a menu item with the keyboard
    :Context:  anywhere
    :END:
** Keys
*** Prefix Help Man                                :inform:helps:keys:window:
    :PROPERTIES:
    :Command:  <Prefix> C-h OR <Prefix> <F1>
    :Description: Displays a list of the commands starting with that prefix
    :Context:  anywhere
    :END:
    There is one exception. The key ~<ESC> C-h~ is equivalent to
    ~C-M-h~ which is a different command. To list the commands that
    start with <ESC> one should instead use the key ~<ESC> <F1>~.
** Entering Emacs
*** help-with-tutorial                                         :helps:buffer:
    :PROPERTIES:
    :Command:  C-h t
    :Description: Open the Emacs tutorial
    :Context:  anywhere
    :END:
** Exiting Emacs
*** save-buffers-kill-terminal                                   :kill:frame:
    :PROPERTIES:
    :Command:  C-x C-c
    :Description: Kill Emacs
    :Context:  anywhere
    :END:
*** suspend-frame                                                     :frame:
    :PROPERTIES:
    :Command:  C-z
    :Description: Minimize GUI, suspend terminal Emacs
    :Context:  anywhere
    :END:
*** kill-emacs                                                   :kill:frame:
    :PROPERTIES:
    :Description: Kill Emacs without being prompted about saving
    :Context:  anywhere
    :END:
** Basic Editing Commands
*** newline                                                       :edit:char:
    :PROPERTIES:
    :Command:  <RET>
    :Description: End a line and start a new one
    :Context:  editing
    :END:
    The binding of this and ~newline-and-indent~ may be swapped
*** newline-and-indent                                            :edit:char:
    :PROPERTIES:
    :Command:  C-j
    :Description: insert newline then indent according to mode
    :Context:  editing
    :END:
    The binding of this and ~newline~ may be swapped
*** quoted-insert                                                 :edit:char:
    :PROPERTIES:
    :Command:  C-q
    :Description: Insert a non-graphic character
    :Context:  editing
    :Argument: numeric
    :END:
    There are two ways to use ~quoted-insert~.
    - ~C-q~ followed by any non-graphic character inserts that
      character
    - ~C-q~ followed by a sequence of octal digits inserts the
      character with the specified octal character code.
    A numeric argument specifies how many copies of the character to
    insert.
*** Insert Char Help Man                      :inform:helps:edit:char:window:
    :PROPERTIES:
    :Command:  C-x 8 C-h
    :Description: Show list of possible characters to insert
    :Context:  navigating
    :END:
    There are a lot of helpful characters one can insert. Check this
    out.
*** insert-char                                                   :edit:char:
    :PROPERTIES:
    :Command:  C-x 8 <RET>
    :Description: Prompts for Unicode name or code-point and inserts
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument specifies how many copies of the character to
    insert.
*** forward-char                                                   :nav:char:
    :PROPERTIES:
    :Command:  C-f
    :Description: Move forward one character
    :Context:  navigating
    :END:
*** right-char                                                     :nav:char:
    :PROPERTIES:
    :Command:  <RIGHT>
    :Description: Move right one character
    :Context:  navigating
    :END:
*** backward-char                                                  :nav:char:
    :PROPERTIES:
    :Command:  C-b
    :Description: Move backward one character
    :Context:  navigating
    :END:
*** left-char                                                      :nav:char:
    :PROPERTIES:
    :Command:  <LEFT>
    :Description: Move left one character
    :Context:  navigating
    :END:
*** next-line                                                      :nav:line:
    :PROPERTIES:
    :Command:  C-n OR <DOWN>
    :Description: Move down one screen line
    :Context:  navigating
    :END:
*** previous-line                                                  :nav:line:
    :PROPERTIES:
    :Command:  C-p OR <UP>
    :Description: Move up one screen line
    :Context:  navigating
    :END:
*** move-beginning-of-line                                         :nav:line:
    :PROPERTIES:
    :Command:  C-a OR <Home>
    :Description: Move to the beginning of the line
    :Context:  navigating
    :END:
*** move-end-of-line                                               :nav:line:
    :PROPERTIES:
    :Command:  C-e OR <End>
    :Description: Move to the end of the line
    :Context:  navigating
    :END:
*** forward-word                                                   :nav:word:
    :PROPERTIES:
    :Command:  M-f
    :Description: Move forward one word
    :Context:  navigating
    :END:
*** right-word                                                     :nav:word:
    :PROPERTIES:
    :Command:  C-<RIGHT> OR M-<RIGHT>
    :Description: Move right one word
    :Context:  navigating
    :END:
*** backward-word                                                  :nav:word:
    :PROPERTIES:
    :Command:  M-b
    :Description: Move backward one word
    :Context:  navigating
    :END:
*** left-word                                                      :nav:word:
    :PROPERTIES:
    :Command:  C-<LEFT> OR M-<LEFT>
    :Description: Move left one word
    :Context:  navigating
    :END:
*** move-to-window-line-top-bottom                               :nav:window:
    :PROPERTIES:
    :Command:  M-r
    :Description: Move point to left margin center, top, bottom
    :Context:  navigating
    :Argument: numeric
    :END:
    A numeric argument says which screen line to place point on,
    counting downward from the top of the window (zero means the top
    line). A negative argument counts lines up from the bottom (-1
    means the bottom line).
*** beginning-of-buffer                                          :nav:buffer:
    :PROPERTIES:
    :Command:  M-< OR C-<HOME>
    :Description: Move to the top of the buffer
    :Context:  navigating
    :Argument: numeric
    :END:
    With numeric argument n, move to n/10 of the way from the top.
*** end-of-buffer                                                :nav:buffer:
    :PROPERTIES:
    :Command:  M-> OR C-<END>
    :Description: Move to the end of the buffer
    :Context:  navigating
    :END:
*** scroll-up-command                                            :nav:buffer:
    :PROPERTIES:
    :Command:  C-v OR <PageDown> OR <next>
    :Description: Scroll the display one screen forward
    :Context:  navigating
    :Argument: numeric
    :END:
    With a numeric argument, /n/, you scroll by /n/ lines; Emacs
    attempts to leave point unchanged, so that the text and point move
    up or down together. With a negative argument this behaves like
    ~scroll-down-command~.
*** scroll-down-command                                          :nav:buffer:
    :PROPERTIES:
    :Command:  M-v OR <PageUp> OR <prior>
    :Description: Scroll one screen backward
    :Context:  navigating
    :Argument: numeric
    :END:
    With a numeric argument, /n/, you scroll by /n/ lines; Emacs
    attempts to leave point unchanged, so that the text and point move
    up or down together. With a negative argument this behaves like
    ~scroll-down-command~.
*** goto-char                                                    :nav:buffer:
    :PROPERTIES:
    :Command:  M-g c
    :Description: Go to 1 indexed character in buffer
    :Context:  navigating
    :END:
*** goto-line                                                    :nav:buffer:
    :PROPERTIES:
    :Command:  M-g M-g OR M-g g
    :Description: Goto 1 indexed line number
    :Context:  navigating
    :Argument: numeric, plain
    :END:
    You can specify line number by giving command a numeric prefix
    argument. Plain prefix not yet defined.
*** move-to-column                                                 :nav:line:
    :PROPERTIES:
    :Command:  M-g <TAB>
    :Description: Move to 0 indexed column
    :Context:  navigating
    :Argument: numeric
    :END:
    If called with a prefix argument, move to the column number
    specified by the argument's numeric value.
*** set-goal-column                                              :nav:window:
    :PROPERTIES:
    :Command:  C-x C-n
    :Description: Use current column as semi-permanent goal column
    :Context:  navigating
    :Argument: plain
    :END:
    With a plain prefix argument cancels the goal column
*** delete-backward-char                            :delete:char:edit:region:
    :PROPERTIES:
    :Command:  <DEL> OR <BACKSPACE>
    :Description: Delete character before point, or region if active
    :Context:  editing
    :Argument: numeric
    :END:
    If you supply a numeric argument /n/, this commands delete /n/
    characters.
*** delete-forward-char                             :delete:char:edit:region:
    :PROPERTIES:
    :Command:  <Delete>
    :Description: Delete character after point, or region if active
    :Context:  editing
    :Argument: numeric
    :END:
    If you supply a numeric argument /n/, this commands delete /n/
    characters.
*** delete-char                                            :delete:char:edit:
    :PROPERTIES:
    :Command:  C-d
    :Description: Delete the character after point
    :Context:  editing
    :END:
*** kill-line                                         :kill:line:edit:delete:
    :PROPERTIES:
    :Command:  C-k
    :Description: Kill to the end of the line
    :Context:  editing
    :Argument: numeric
    :END:
    If used at the end of a line, it kills the line-ending newline
    character, merging the next line into the current one (thus, a
    blank line is entirely removed). Otherwise, this command kills all
    the text from the point up to the end of the line; if point was
    originally at the beginning of the line, this leaves the line
    blank.

    Spaces and tabs at the end of the line are ignored when deciding
    which case applies. As long as point is after the last
    non-whitespace character in the line, you can be sure that ~C-k~
    will kill the newline. To kill an entire non-blank line, go to the
    beginning and type ~C-k~ twice.

    When ~C-k~ is given a positive argument /n/, it kills /n/ lines
    and the newlines that follow them (text on the current line before
    point is not killed). With a negative /-n/, it kills /n/ lines
    preceding the current line, together with the text on the current
    line before point. C-k with an argument of zero kills the text
    before the point on the current line.
*** kill-word                                         :kill:word:edit:delete:
    :PROPERTIES:
    :Command:  M-d
    :Description: Kill forward to the end of the next word
    :Context:  editing
    :END:
*** backward-kill-word                                :kill:word:edit:delete:
    :PROPERTIES:
    :Command:  M-<DEL> OR M-<BACKSPACE>
    :Description: Kill back to the beginning of the previous word
    :Context:  editing
    :END:
*** undo                                                   :undo:edit:buffer:
    :PROPERTIES:
    :Command:  C-/ OR C-x u OR C-_
    :Description: Undo one entry of the undo records
    :Context:  editing
    :Argument: plain
    :END:
    When not in Transient Mark mode, using a plain argument limits
    undo to changes within the current region.
*** find-file                                                  :files:buffer:
    :PROPERTIES:
    :Command:  C-x C-f
    :Description: Copy file into buffer
    :Context:  anywhere
    :END:
*** save-buffer                                                :files:buffer:
    :PROPERTIES:
    :Command:  C-x C-s
    :Description: Save current buffer into associated file
    :Context:  editing
    :END:
*** describe-key                                        :helps:window:inform:
    :PROPERTIES:
    :Command:  C-h k
    :Description: find out what a key does
    :Context:  anywhere
    :END:
*** open-line                                                     :edit:line:
    :PROPERTIES:
    :Command:  C-o
    :Description: Insert a blank line after the cursor
    :Context:  editing
    :Argument: numeric
    :END:
    With a numeric argument you can make several blank lines.
*** delete-blank-lines                                   :edit:buffer:delete:
    :PROPERTIES:
    :Command:  C-x C-o
    :Description: Delete all but one of many consecutive blank lines
    :Context:  editing
    :END:
*** what-line                                                   :inform:echo:
    :PROPERTIES:
    :Description: Display the line number of point
    :Context:  navigating
    :END:
*** line-number-mode                                     :inform:buffer:mode:
    :PROPERTIES:
    :Description: Toggle automatic display of current line number
    :Context:  navigating
    :END:
*** column-number-mode                                     :inform:line:mode:
    :PROPERTIES:
    :Description: Toggle automatic display of current column number
    :Context:  navigating
    :END:
*** count-words-region                                   :inform:region:echo:
    :PROPERTIES:
    :Command:  M-=
    :Description: Display the number of lines, words, chars in region
    :Context:  navigating
    :END:
*** count-words                                          :inform:echo:region:
    :PROPERTIES:
    :Command:  C-u M-=
    :Description: Display number of lines, words, and chars in buffer or region
    :Context:  navigating
    :END:
*** what-cursor-position                              :inform:char:echo:line:
    :PROPERTIES:
    :Command:  C-x =
    :Description: Display code char, position, and column of point
    :Context:  navigating
    :END:
*** hl-line-mode                                          :mode:display:line:
    :PROPERTIES:
    :Description: Toggle highlighting of the current line
    :Context:  navigating
    :END:
*** size-indication-mode                                 :mode:inform:buffer:
    :PROPERTIES:
    :Description: Toggle automatic display of size of buffer
    :Context:  navigating
    :END:
*** display-line-numbers-mode                    :display:window:mode:inform:
    :PROPERTIES:
    :Description: Toggle displaying line numbers for every line in buffer
    :Context:  navigating
    :END:
*** digit-argument                                                     :keys:
    :PROPERTIES:
    :Command:  M-[0-9]
    :Description: Compile numeric argument for next command
    :Context:  anywhere
    :END:
*** negative-argument                                                  :keys:
    :PROPERTIES:
    :Command:  M--
    :Description: Compile negative numeric argument for next command
    :Context:  anywhere
    :END:
*** universal-argument                                                 :keys:
    :PROPERTIES:
    :Command:  C-u
    :Description: start numeric, plain, double argument
    :Context:  anywhere
    :END:
*** repeat                                                             :keys:
    :PROPERTIES:
    :Command:  C-x z
    :Description: repeat the previous Emacs command.
    :Context:  anywhere
    :END:
** The Minibuffer
*** exit-minibuffer                                     :echo:command:buffer:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Submit provided argument and exit minibuffer
    :Context:  minibuffer
    :END:
*** minibuffer-electric-default-mode               :buffer:display:echo:mode:
    :PROPERTIES:
    :Description: Toggle Minibuffer Electric Default mode
    :Context:  anywhere
    :END:
*** file-name-shadow-mode                          :buffer:display:echo:mode:
    :PROPERTIES:
    :Description: Toggle File Name Shadow mode
    :Context:  anywhere
    :END:
*** minibuffer-complete                                 :buffer:command:echo:
    :PROPERTIES:
    :Command:  <TAB>
    :Description: Complete the text in the minibuffer as much as possible
    :Context:  minibuffer
    :END:
    If unable to complete, display a list of possible completions
*** minibuffer-complete-word                            :buffer:command:echo:
    :PROPERTIES:
    :Command:  <SPC>
    :Description: Complete up to one word from the minibuffer text before point
    :Context:  minibuffer
    :END:
    This command is not available for arguments that often include
    spaces, such as file names.
*** minibuffer-complete-and-exit                        :buffer:command:echo:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Submit minibuffer argument
    :Context:  minibuffer
    :END:
*** minibuffer-completion-help            :buffer:command:inform:window:echo:
    :PROPERTIES:
    :Command:  ?
    :Description: Display a list of completions
    :Context:  minibuffer
    :END:
*** switch-to-completions                    :buffer:command:window:nav:echo:
    :PROPERTIES:
    :Command:  M-v OR <PageUp> OR <prior>
    :Description: Selects the window showing the completion list
    :Context:  minibuffer
    :END:
*** choose-completion                            :window:command:buffer:echo:
    :PROPERTIES:
    :Command:  <RET> OR mouse-1 OR mouse-2
    :Description: Chooses the completion at point
    :Context:  completion-buffer
    :END:
*** next-completion                                      :buffer:command:nav:
    :PROPERTIES:
    :Command:  <RIGHT>
    :Description: This moves point to the following completion alternative
    :Context:  completion-buffer
    :END:
*** previous-completion                                  :buffer:command:nav:
    :PROPERTIES:
    :Command:  <LEFT>
    :Description: This moves point to the previous completion alternative
    :Context:  completion-buffer
    :END:
*** previous-history-element                          :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-p
    :Description: Move to the previous item in the minibuffer history
    :Context:  minibuffer
    :END:
*** next-history-element                              :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-n
    :Description: Move to the next item in the minibuffer history
    :Context:  minibuffer
    :END:
    If you use this command in the minibuffer when there are no later
    entries in the minibuffer history (e.g., if you haven't previously
    typed M-p), Emacs tries fetching from a list of default arguments:
    values that you are likely to enter. You can think of this as
    moving through the "future history".
*** previous-line-or-history-element              :buffer:line:nav:hist:echo:
    :PROPERTIES:
    :Command:  <UP>
    :Description: Move previous line if exists, else previous minibuffer item
    :Context:  minibuffer
    :END:
*** next-line-or-history-element                  :buffer:line:nav:hist:echo:
    :PROPERTIES:
    :Command:  <DOWN>
    :Description: Move next line if exists, else move next minibuffer item
    :Context:  minibuffer
    :END:
*** previous-matching-history-element                 :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-r
    :Description: Move earlier minibuffer item that matches regexp
    :Context:  minibuffer
    :Argument: numeric
    :END:
    A numeric prefix argument /n/ means to fetch the /n/-th matching
    entry.
*** next-matching-history-element                     :buffer:line:hist:echo:
    :PROPERTIES:
    :Command:  M-s
    :Description: Move later minibuffer item that matches regexp
    :Context:  minibuffer
    :Argument: numeric
    :END:
    A numeric prefix argument /n/ means to fetch the /n/-th matching
    entry.
*** repeat-complex-command                                     :command:hist:
    :PROPERTIES:
    :Command:  C-x <ESC> <ESC>
    :Description: Re-execute a recent minibuffer command from Command History
    :Context:  anywhere
    :Argument: numeric
    :END:
    With no argument, it repeats the last such command. A numeric
    argument specifies which command to repeat; 1 means the last one,
    2 the previous, and so on.
*** list-command-history                         :window:command:inform:hist:
    :PROPERTIES:
    :Description: Display command history
    :Context:  anywhere
    :END:
*** Password Delete Backwards Char                  :buffer:char:delete:echo:
    :PROPERTIES:
    :Command:  <DEL>
    :Description: Removes last character entered
    :Context:  password
    :END:
*** Password Delete All                             :buffer:delete:line:echo:
    :PROPERTIES:
    :Command:  C-u
    :Description: Deletes everything you have typed so far
    :Context:  password
    :END:
*** Password Quit                                          :undo:buffer:echo:
    :PROPERTIES:
    :Command:  C-g
    :Description: Quits the password prompt
    :Context:  password
    :END:
*** Password Yank                                          :buffer:edit:echo:
    :PROPERTIES:
    :Command:  C-y
    :Description: Inserts the current kill into the password
    :Context:  password
    :END:
*** Password Submit                                :buffer:command:line:echo:
    :PROPERTIES:
    :Command:  <RET> OR <ESC>
    :Description: Submits password
    :Context:  password
    :END:
*** Yes No Recenter Selected Window                      :window:display:nav:
    :PROPERTIES:
    :Command:  C-l
    :Description: Recenter the selected window
    :Context:  yes-no
    :END:
*** Yes No Scroll Up                                             :nav:buffer:
    :PROPERTIES:
    :Command:  C-v OR <PageDown> OR <next>
    :Description: Scroll forward
    :Context:  yes-no
    :END:
*** Yes No Scroll Down                                           :nav:buffer:
    :PROPERTIES:
    :Command:  M-v OR <PageUp> OR <previous>
    :Description: Scroll backward
    :Context:  yes-no
    :END:
*** Yes No Scroll Up Next Window                          :nav:buffer:window:
    :PROPERTIES:
    :Command:  C-M-v
    :Description: Scrolls forward in the next window
    :Context:  yes-no
    :END:
*** Yes No Scroll Down Next Window                        :nav:buffer:window:
    :PROPERTIES:
    :Command:  C-M-S-v
    :Description: Scrolls backward in the next window
    :Context:  yes-no
    :END:
*** Yes No Quit                                                :undo:command:
    :PROPERTIES:
    :Command:  C-g
    :Description: Dismisses query and quits the command
    :Context:  yes-no
    :END:
** Running Commands by Name
*** execute-extended-command                            :command:buffer:echo:
    :PROPERTIES:
    :Command:  M-x
    :Description: Run a command by name
    :Context:  anywhere
    :Argument: numeric
    :END:
    A numeric argument passes the same numeric argument along to the
    command you are trying to execute.
** Help
*** help-for-help                                       :helps:inform:window:
    :PROPERTIES:
    :Command:  C-h C-h
    :Description: View a list of help commands
    :Context:  anywhere
    :END:
*** scroll-up-command                                      :helps:nav:window:
    :PROPERTIES:
    :Command:  <SPC>
    :Description: Scroll contents of help window up
    :Context:  help
    :END:
*** scroll-down-command                                    :helps:nav:window:
    :PROPERTIES:
    :Command:  <DEL>
    :Description: Scroll contents of help window down.
    :Context:  help
    :END:
*** help-follow                                            :helps:nav:buffer:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Follow cross-reference at point
    :Context:  help
    :END:
*** push-button                                               :helps:command:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Perform action specified by a button at relevant location
    :Context:  help
    :END:
*** apropos-command                             :command:helps:window:search:
    :PROPERTIES:
    :Command:  C-h a
    :Description: Searches for commands whose names match provided input
    :Context:  navigating
    :END:
*** info                                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h i
    :Description: Enter Info, the documentation browser
    :Context:  navigating
    :END:
*** Info-directory                                        :buffer:inform:nav:
    :PROPERTIES:
    :Command:  d
    :Description: Go to the Info directory node.
    :Context:  info
    :END:
*** Info-menu                                      :buffer:inform:search:nav:
    :PROPERTIES:
    :Command:  m
    :Description: Go to the node pointed to by the menu item indicated
    :Context:  info
    :END:
*** Info-index                                     :buffer:inform:search:nav:
    :PROPERTIES:
    :Command:  i
    :Description: Look up given string in this manual's index and go there
    :Context:  info
    :END:
*** Info-search                                    :buffer:inform:search:nav:
    :PROPERTIES:
    :Command:  s
    :Description: Search for given REGEXP, starting from point, go to node
    :Context:  info
    :END:
*** view-emacs-FAQ                                            :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-f
    :Description: Display the Emacs Frequently Asked Questions (FAQ) file
    :Context:  navigating
    :END:
*** finder-by-keyword                                         :window:inform:
    :PROPERTIES:
    :Command:  C-h p
    :Description: Find packages matching a given keyword
    :Context:  navigating
    :END:
*** describe-bindings                                     :window:helps:keys:
    :PROPERTIES:
    :Command:  C-h b
    :Description: Display all active key bindings: minor, major, global
    :Context:  anywhere
    :END:
*** describe-key-briefly                                   :echo:keys:inform:
    :PROPERTIES:
    :Command:  C-h c
    :Description: Show name of command associated with key sequence
    :Context:  anywhere
    :END:
*** apropos-documentation                       :helps:command:window:search:
    :PROPERTIES:
    :Command:  C-h d
    :Description: Display commands and variables with matching documentation
    :Context:  navigating
    :END:
*** view-echo-area-messages                                :echo:buffer:hist:
    :PROPERTIES:
    :Command:  C-h e
    :Description: Display the *Messages* buffer
    :Context:  anywhere
    :END:
*** describe-function                                          :window:helps:
    :PROPERTIES:
    :Command:  C-h f
    :Description: Display documentation on function with provided name
    :Context:  anywhere
    :END:
*** view-hello-file                                      :buffer:inform:char:
    :PROPERTIES:
    :Command:  C-h h
    :Description: Display the ~HELLO~ file.
    :Context:  anywhere
    :END:
*** info                                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h i
    :Description: Run Info, the GNU documentation browser.
    :Context:  anywhere
    :Argument: numeric, plain
    :END:
    With a numeric argument /n/, ~C-h i~ selects the Info buffer
    '~*info*<n>'. This is useful if you want to browse multiple Info
    manuals simultaneously. With just a plain argument, ~C-h i~
    prompts for the name of a documentation file, so you can browse a
    file which doesn't have an entry in the top-level Info
    menu.
*** describe-key                                  :window:command:keys:helps:
    :PROPERTIES:
    :Command:  C-h k
    :Description: Display name and documentation for associated key
    :Context:  anywhere
    :END:
*** view-lossage                                          :window:helps:keys:
    :PROPERTIES:
    :Command:  C-h l
    :Description: Display a description of last 300 keystrokes
    :Context:  anywhere
    :END:
*** describe-mode                                         :window:mode:helps:
    :PROPERTIES:
    :Command:  C-h m
    :Description: Display documentation of current major and minor modes
    :Context:  anywhere
    :END:
*** view-emacs-news                                           :buffer:inform:
    :PROPERTIES:
    :Command:  C-h n
    :Description: Display news of recent Emacs changes
    :Context:  anywhere
    :END:
*** describe-symbol                                            :window:helps:
    :PROPERTIES:
    :Command:  C-h o
    :Description: Display documentation of Lisp symbol provided
    :Context:  anywhere
    :END:
*** finder-by-keyword                                   :window:inform:files:
    :PROPERTIES:
    :Command:  C-h p
    :Description: Find packages by topic keyword
    :Context:  anywhere
    :END:
*** describe-package                                     :window:helps:files:
    :PROPERTIES:
    :Command:  C-h P
    :Description: Display documentation about the specified package
    :Context:  navigating
    :END:
*** info-emacs-manual                                         :buffer:inform:
    :PROPERTIES:
    :Command:  C-h r
    :Description: Display the Emacs manual in Info
    :Context:  anywhere
    :END:
*** describe-syntax                                       :window:helps:char:
    :PROPERTIES:
    :Command:  C-h s
    :Description: Display the contents of the current syntax table
    :Context:  anywhere
    :END:
*** help-with-tutorial                          :buffer:startup:keys:command:
    :PROPERTIES:
    :Command:  C-h t
    :Description: Enter the Emacs interactive tutorial
    :Context:  anywhere
    :END:
*** describe-variable                                          :window:helps:
    :PROPERTIES:
    :Command:  C-h v
    :Description: Display the documentation of the Lisp variable provided
    :Context:  anywhere
    :END:
*** where-is                                              :echo:keys:command:
    :PROPERTIES:
    :Command:  C-h w
    :Description: Show which keys run the command provided
    :Context:  anywhere
    :END:
*** describe-coding-system                              :window:helps:coding:
    :PROPERTIES:
    :Command:  C-h C
    :Description: Describe the coding system provided
    :Context:  navigating
    :END:
*** Info-goto-emacs-command-node                      :buffer:inform:command:
    :PROPERTIES:
    :Command:  C-h F
    :Description: Enter Info at node that describes command provided
    :Context:  navigating
    :END:
*** describe-input-method                                      :window:helps:
    :PROPERTIES:
    :Command:  C-h I
    :Description: Describe the input method provided
    :Context:  anywhere
    :END:
*** Info-goto-emacs-key-command-node             :buffer:inform:command:keys:
    :PROPERTIES:
    :Command:  C-h K
    :Description: Enter Info at node that documents provided key sequence
    :Context:  anywhere
    :END:
*** describe-language-environment                              :window:helps:
    :PROPERTIES:
    :Command:  C-h L
    :Description: Display information of language environment provided
    :Context:  navigating
    :END:
*** info-lookup-symbol                                        :window:inform:
    :PROPERTIES:
    :Command:  C-h S
    :Description: Display the info documentation on provided symbol in context
    :Context:  navigating
    :END:
*** display-local-help                                          :echo:inform:
    :PROPERTIES:
    :Command:  C-h .
    :Description: Display the help message for selected special text area
    :Context:  special-text
    :END:
*** apropos                                            :window:inform:search:
    :PROPERTIES:
    :Description: Search for functions and variables
    :Context:  navigating
    :END:
*** apropos-user-option                                :window:inform:search:
    :PROPERTIES:
    :Description: Search for user-customizable variables
    :Context:  navigating
    :Argument: plain
    :END:
    With a prefix argument, search for non-customizable variables
    too.
*** apropos-variable                                   :window:inform:search:
    :PROPERTIES:
    :Description: Search for variables
    :Context:  navigating
    :Argument: plain
    :END:
    With a prefix argument, search for customizable variables only.
*** apropos-local-variable                             :window:inform:search:
    :PROPERTIES:
    :Description: Search for buffer-local variables
    :Context:  navigating
    :END:
*** apropos-value                                      :window:inform:search:
    :PROPERTIES:
    :Description: Search variables whose values match specified pattern
    :Context:  navigating
    :Argument: plain
    :END:
    With a prefix argument, search also for functions with definitions
    matching the pattern, and Lisp symbols with properties matching
    the pattern.
*** apropos-local-value                                :window:inform:search:
    :PROPERTIES:
    :Description: Search buffer-local variables that match specified pattern
    :Context:  navigating
    :END:
*** forward-button                                         :nav:helps:buffer:
    :PROPERTIES:
    :Command:  <TAB>
    :Description: Move point forward to the next hyperlink
    :Context:  help
    :END:
*** backward-button                                        :nav:helps:buffer:
    :PROPERTIES:
    :Command:  S-<TAB>
    :Description: Move point back to the previous hyperlink
    :Context:  help
    :END:
*** help-follow-symbol                                         :helps:buffer:
    :PROPERTIES:
    :Command:  C-c C-c
    :Description: Show all documentation about the symbol at point
    :Context:  help
    :END:
*** help-go-forward                                        :nav:buffer:helps:
    :PROPERTIES:
    :Command:  C-c C-f OR r
    :Description: Go forward to the next help topic
    :Context:  help
    :END:
*** help-go-back                                           :nav:buffer:helps:
    :PROPERTIES:
    :Command:  C-c C-b OR l
    :Description: Go back to the previous help topic
    :Context:  help
    :END:
*** describe-copying                                          :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-c
    :Description: Display the rules under which you can copy Emacs
    :Context:  anywhere
    :END:
*** view-emacs-debugging                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-d
    :Description: Display help for debugging Emacs
    :Context:  anywhere
    :END:
*** view-external-packages                                    :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-e
    :Description: Display information about where to get external packages
    :Context:  anywhere
    :END:
*** describe-gnu-project                                       :frame:inform:
    :PROPERTIES:
    :Command:  C-h g
    :Description: Visit the page with information about the GNU Project
    :Context:  anywhere
    :END:
*** view-order-manuals                                        :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-m
    :Description: Display info on printed copies of Emacs manuals
    :Context:  anywhere
    :END:
*** describe-distribution                                     :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-o
    :Description: Display how to download latest version of Emacs
    :Context:  anywhere
    :END:
*** view-emacs-problems                                       :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-p
    :Description: Display known Emacs problems, sometimes with workaround
    :Context:  anywhere
    :END:
*** view-emacs-todo                                           :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-t
    :Description: Display the Emacs to-do list
    :Context:  anywhere
    :END:
*** describe-no-warranty                                      :buffer:inform:
    :PROPERTIES:
    :Command:  C-h C-w
    :Description: Display full details on no warranty for GNU Emacs
    :Context:  anywhere
    :END:
** The Mark and the Region
*** set-mark-command                                          :buffer:region:
    :PROPERTIES:
    :Command:  C-<SPC> OR C-@
    :Description: Set the mark at point, and activate it
    :Context:  anywhere
    :Argument: plain
    :END:
    With plain prefix argument, move point to where the previous mark
    was, and restore the mark from the ring of former marks.
*** exchange-point-and-mark                               :buffer:region:nav:
    :PROPERTIES:
    :Command:  C-x C-x
    :Description: Swap mark and point and activate mark
    :Context:  anywhere
    :Argument: plain
    :END:
    If you call this with a plain prefix argument, it leaves the mark
    inactive and the region unhighlighted; you can use this to jump to
    the mark in a manner similar to ~C-u C-<SPC>~.
*** mouse-set-region                                      :buffer:region:nav:
    :PROPERTIES:
    :Command:  <drag-mouse-1>
    :Description: Set point and the mark around the text you drag across.
    :Context:  anywhere
    :END:
*** mouse-save-then-kill                                  :buffer:region:nav:
    :PROPERTIES:
    :Command:  <mouse-3>
    :Description: Set the mark at point, then move point to click
    :Context:  anywhere
    :END:
*** upcase-region                                        :buffer:region:edit:
    :PROPERTIES:
    :Command:  C-x C-u
    :Description: Convert text in active region to upcase, deactivate mark
    :Context:  editing
    :END:
*** mark-word                                            :buffer:region:word:
    :PROPERTIES:
    :Command:  M-@
    :Description: Set mark at the end of the next word
    :Context:  anywhere
    :Argument: numeric
    :END:
    This command also accepts a numeric argument /n/, which tells it
    to advance the mark by /n/ words. A negative argument -/n/ moves
    the mark back by /n/ words.
*** mark-sexp                                            :buffer:region:word:
    :PROPERTIES:
    :Command:  C-M-<SPC> OR C-M-@
    :Description: Set mark after end of following balanced expression
    :Context:  anywhere
    :Argument: numeric
    :END:
    Positive or negative numeric arguments move the mark forward or
    backward by the specified number of expressions.
*** mark-paragraph                                   :buffer:region:line:nav:
    :PROPERTIES:
    :Command:  M-h
    :Description: Move point to start of paragraph, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    numeric arguments specify how many objects to move the mark by.
*** mark-defun                                       :buffer:region:line:nav:
    :PROPERTIES:
    :Command:  C-M-h
    :Description: Move point to start of current defun, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    Numeric arguments specify how many objects to move the mark by.
*** mark-page                                             :buffer:region:nav:
    :PROPERTIES:
    :Command:  C-x C-p
    :Description: Move point to start of page, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    Numeric arguments specify how many objects to move the mark by.
*** mark-whole-buffer                                     :buffer:region:nav:
    :PROPERTIES:
    :Command:  C-x h
    :Description: Move point to start of buffer, set mark at end
    :Context:  anywhere
    :Argument: numeric
    :END:
    Numeric arguments specify how many objects to move the mark by.
*** kill-region                                     :kill:region:edit:delete:
    :PROPERTIES:
    :Command:  C-w
    :Description: Kill ("cut") text between point and mark
    :Context:  editing
    :END:
*** kill-ring-save                                              :kill:region:
    :PROPERTIES:
    :Command:  M-w
    :Description: Save the region as if killed, but don't kill it. ("Copy")
    :Context:  navigating
    :END:
*** downcase-region                                             :edit:region:
    :PROPERTIES:
    :Command:  C-x C-l
    :Description: Convert the region to lower case
    :Context:  editing
    :END:
*** upcase-region                                               :edit:region:
    :PROPERTIES:
    :Command:  C-x C-u
    :Description: Convert the region to upper case
    :Context:  editing
    :END:
*** query-replace                                               :edit:search:
    :PROPERTIES:
    :Command:  M-%
    :Description: Replace some occurrences of one string with another
    :Context:  editing
    :END:
*** indent-rigidly                                         :edit:line:region:
    :PROPERTIES:
    :Command:  C-x <TAB>
    :Description: Indent all lines starting in the region
    :Context:  editing
    :END:
*** indent-region                                          :edit:line:region:
    :PROPERTIES:
    :Command:  C-M-\
    :Description: Indent each non-blank line in the region
    :Context:  editing
    :END:
*** fill-region                                                 :edit:region:
    :PROPERTIES:
    :Description: Fill each of the paragraphs in the region
    :Context:  editing
    :END:
*** ispell-word                                                   :word:edit:
    :PROPERTIES:
    :Command:  M-$
    :Description: Check spelling of word under or before the cursor
    :Context:  editing
    :END:
*** eval-region                                                     :command:
    :PROPERTIES:
    :Description: Execute the region as Lisp code
    :Context:  anywhere
    :END:
*** copy-to-register                                                 :region:
    :PROPERTIES:
    :Command:  C-x r x OR C-x r s
    :Description: Copy region into given register
    :Context:  navigating
    :END:
*** delete-selection-mode                           :mode:delete:edit:region:
    :PROPERTIES:
    :Description: Toggle Delete Selection mode
    :Context:  editing
    :END:
*** pop-global-mark                                       :nav:region:buffer:
    :PROPERTIES:
    :Command:  C-x C-<SPC>
    :Description: Jumps to last buffer and position of global mark ring
    :Context:  navigating
    :END:
*** transient-mark-mode                             :display:region:nav:mode:
    :PROPERTIES:
    :Description: Toggle Transient Mark mode
    :Context:  navigating
    :END:
** Killing and Moving Text
*** delete-horizontal-space                                     :delete:char:
    :PROPERTIES:
    :Command:  M-\
    :Description: Delete spaces and tabs around point
    :Context:  editing
    :Argument: plain
    :END:
    With a prefix argument, this only deletes spaces and tab
    characters before point.
*** just-one-space                                              :delete:char:
    :PROPERTIES:
    :Command:  M-<SPC>
    :Description: Delete spaces and tabs around point, leaving one space
    :Context:  editing
    :Argument: numeric
    :END:
    With a numeric argument /n/, it leaves /n/ spaces before point if
    /n/ is positive; if /n/ is negative, it deletes newlines in
    addition to spaces and tabs, leaving /-n/ spaces before point.
*** delete-blank-lines                                          :delete:line:
    :PROPERTIES:
    :Command:  C-x C-o
    :Description: Delete blank lines around the current line
    :Context:  editing
    :END:
    ~C-x C-o~ (~delete-blank-lines~) deletes all blank lines after the
    current line. If the current line is blank, it deletes all blank
    lines preceding the current line as well (leaving one blank line,
    the current line). On a solitary blank line, it deletes that line.
*** delete-indentation                                          :delete:line:
    :PROPERTIES:
    :Command:  M-^
    :Description: Join two lines by deleting newline and indentation
    :Context:  editing
    :END:
*** cycle-spacing                                               :delete:char:
    :PROPERTIES:
    :Description: Manipulate whitespace around point in a smart way
    :Context:  editing
    :END:
    The command ~cycle-spacing~ acts like a more flexible version of
    ~just-one-space~. It does different things if you call it
    repeatedly in succession. The first call acts like
    ~just-one-space~, the next removes all whitespace, and a third
    call restores the original whitespace.
*** delete-duplicate-lines                                      :delete:line:
    :PROPERTIES:
    :Description: Delete all but one copy of any identical lines in the region
    :Context:  editing
    :Argument: plain, double, triple
    :END:
    - By default keeps first instance of each repeated line
    - With a plain prefix it keeps the last instance of each repeated
      line
    - With a double prefix argument, it only searches for adjacent
      identical lines.
    - With a triple prefix argument, it retains repeated blank lines
*** kill-whole-line                                        :kill:line:delete:
    :PROPERTIES:
    :Command:  C-S-<DEL>
    :Description: Kill an entire line at once
    :Context:  editing
    :END:
    Note that many text terminals will prevent you from typing the key
    sequence ~C-S-<DEL>~
*** backward-kill-sentence                                      :delete:kill:
    :PROPERTIES:
    :Command:  C-x <DEL>
    :Description: Kill back to the beginning of sentence
    :Context:  editing
    :END:
*** kill-sentence                                               :kill:delete:
    :PROPERTIES:
    :Command:  M-k
    :Description: Kill to the end of the sentence
    :Context:  editing
    :END:
*** kill-sexp                                                   :delete:kill:
    :PROPERTIES:
    :Command:  C-M-k
    :Description: Kill the following balanced expression
    :Context:  editing
    :END:
*** zap-to-char                                            :char:delete:kill:
    :PROPERTIES:
    :Command:  M-z <char>
    :Description: Kill through the next occurrence of <char>
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument acts as a repeat count; a negative argument
    means to search backward and kill text before point.
*** yank                                                               :edit:
    :PROPERTIES:
    :Command:  C-y
    :Description: Yank the last kill into the buffer, at point
    :Context:  editing
    :Argument: numeric, plain
    :END:
    Inserts the most recent kill, leaving the cursor at the end of the
    inserted text. It also sets the mark at the beginning of the
    inserted text, without activating the mark.

    With a plain prefix argument (~C-u C-y~), the command instead
    leaves the cursor in front of the inserted text, and sets the mark
    at the end.

    Using a numeric argument /n/ specifies reinserting the /n/-th
    earlier kill. And keeps the last-yank pointer at that kill.
*** yank-pop                                                      :edit:hist:
    :PROPERTIES:
    :Command:  M-y
    :Description: Replace recent yanked text with earlier batch of killed text
    :Context:  after-yank
    :Argument: numeric
    :END:
    A numeric argument defines how many entries to advance the
    last-yank pointer by. A negative argument moves the pointer toward
    the front of the ring; from the front of the ring, it moves around
    to the last entry and continues forward from there.
*** append-next-kill                                              :kill:hist:
    :PROPERTIES:
    :Command:  C-M-w
    :Description: Cause following kill command to append to previous kill
    :Context:  editing
    :END:
*** set-selection-coding-system                                 :kill:coding:
    :PROPERTIES:
    :Command:  C-x <RET> x
    :Description: set coding system for killed text in clipboard
    :Context:  navigating
    :END:
*** set-next-selection-coding-system                            :kill:coding:
    :PROPERTIES:
    :Command:  C-x <RET> X
    :Description: Use coding-system for only next communication with other apps
    :Context:  navigating
    :END:
*** clipboard-kill-region                                       :kill:delete:
    :PROPERTIES:
    :Command:  <f20>
    :Description: kills the region and saves it to the clipboard
    :Context:  editing
    :END:
*** clipboard-kill-ring-save                                           :kill:
    :PROPERTIES:
    :Command:  <f16>
    :Description: copies region to kill ring and saves to clipboard
    :Context:  navigating
    :END:
*** clipboard-yank                                                     :edit:
    :PROPERTIES:
    :Command:  <f18>
    :Description: yanks the contents of the clipboard at point
    :Context:  editing
    :END:
*** mouse-yank-primary                                                 :edit:
    :PROPERTIES:
    :Command:  <mouse-2>
    :Description: Insert primary selection in Emacs buffer at point or click
    :Context:  editing
    :END:
*** mouse-set-secondary                                              :region:
    :PROPERTIES:
    :Command:  <M-Drag-mouse-1>
    :Description: Set secondary selection within dragged region
    :Context:  navigating
    :END:
    The selected text is highlighted, using the ~secondary-selection~
    face, as you drag. The window scrolls automatically if you drag
    the mouse off the top or bottom of the window, just like
    ~mouse-set-region~.

    This command does not alter the kill ring
*** mouse-start-secondary                                            :region:
    :PROPERTIES:
    :Command:  <M-mouse-1>
    :Description: Set one endpoint for the secondary selection
    :Context:  navigating
    :END:
    Use ~M-mouse-3~ to set the other end and complete the
    selection. This command cancels any existing secondary selection,
    when it starts a new one.

    Double or triple clicking of ~M-mouse-1~ operates on words and
    lines, much like ~mouse-1~.
*** mouse-secondary-save-then-kill                              :region:kill:
    :PROPERTIES:
    :Command:  <M-mouse-3>
    :Description: Set the secondary selection and copy to kill ring
    :Context:  navigating
    :END:
    A second ~M-mouse-3~ at the same place kills the text selected by
    the secondary selection just made.
*** mouse-yank-secondary                                               :edit:
    :PROPERTIES:
    :Command:  <M-mouse-2>
    :Description: Insert secondary selection at point or click
    :Context:  editing
    :END:
    Places point at the end of the yanked text
*** append-to-buffer                                          :region:buffer:
    :PROPERTIES:
    :Description: Append region to the contents of a specified buffer
    :Context:  navigating
    :END:
    This reads a buffer name, then inserts a copy of the region into
    the buffer specified. If you specify a nonexistent buffer, this
    command creates the buffer.

    Point in that buffer is left at the end of the copied text, so
    successive uses of this command accumulate the text in the
    specified buffer in the same order as they were copied. Strictly
    speaking, the command does not always append to the text already
    in the buffer - it appends only if point in that buffer is at the
    end. However, if the command is the only command you use to alter
    a buffer then point is always at the end.
*** prepend-to-buffer                                         :region:buffer:
    :PROPERTIES:
    :Description: Prepend region to the contents of a specified buffer
    :Context:  navigating
    :END:
    This command is just like ~append-to-buffer~ except that point in
    the other buffer is left before the copied text, so successive
    uses of this command add text in reverse order.
*** copy-to-buffer                                     :region:buffer:delete:
    :PROPERTIES:
    :Description: Copy region into specified buffer, deleting the contents
    :Context:  navigating
    :END:
*** insert-buffer                                               :edit:buffer:
    :PROPERTIES:
    :Description: Insert specified buffer into current buffer at point
    :Context:  editing
    :END:
    This prompts for the name of a buffer, and inserts a copy of all
    the text in that buffer into the current buffer at point, leaving
    point at the beginning of the inserted text. It also adds the
    position of the end of the inserted text to the mark ring, without
    activating the mark.
*** append-to-file                                             :region:files:
    :PROPERTIES:
    :Description: Append region to contents of specified file, at the end
    :Context:  navigating
    :END:
    This prompts for a filename, and adds the text of the region to
    the end of the specified file. The file is changed immediately on
    disk.

    You should only use this command with files that are /not/ being
    visited in Emacs. Using it on a file that you are editing in Emacs
    would change the file behind Emacs's back, which can lead to losing
    some of your editing.
*** kill-rectangle                                       :region:kill:delete:
    :PROPERTIES:
    :Command:  C-x r k
    :Description: Kill text of region-rectangle, save as last killed rectangle
    :Context:  editing
    :END:
*** copy-rectangle-as-kill                                      :region:kill:
    :PROPERTIES:
    :Command:  C-x r M-w
    :Description: Save the text of region-rectangle as last killed rectangle
    :Context:  navigating
    :END:
*** delete-rectangle                                          :region:delete:
    :PROPERTIES:
    :Command:  C-x r d
    :Description: Delete the text of region-rectangle
    :Context:  editing
    :END:
*** yank-rectangle                                              :region:edit:
    :PROPERTIES:
    :Command:  C-x r y
    :Description: Yank last killed rectangle with up left corner at point
    :Context:  editing
    :END:
*** open-rectangle                                              :region:edit:
    :PROPERTIES:
    :Command:  C-x r o
    :Description: Insert blank space to fill region-rectangle, push right
    :Context:  editing
    :END:
*** rectangle-number-lines                                      :region:edit:
    :PROPERTIES:
    :Command:  C-x r N
    :Description: Insert line numbers on left of region-rectangle, push right
    :Context:  editing
    :Argument: numeric
    :END:
    Normally, the numbering begins from 1 (for the first line of the
    rectangle). With a numeric argument, the command prompts for a
    number to begin from, and for a format string with which to print
    the numbers.
*** clear-rectangle                                             :region:edit:
    :PROPERTIES:
    :Command:  C-x r c
    :Description: Clear region-rectangle by replacing contents with spaces
    :Context:  editing
    :END:
*** delete-whitespace-rectangle                               :region:delete:
    :PROPERTIES:
    :Description: Delete whitespace in region-rectangle along left edge
    :Context:  editing
    :END:
    Deletes horizontal whitespace starting from a particular
    column. This applies to each of the lines in the rectangle, and
    the column is specified by the left edge of the rectangle. The
    right edge of the rectangle does not make any difference to this
    command.
*** string-rectangle                                            :region:edit:
    :PROPERTIES:
    :Command:  C-x r t
    :Description: Replace rectangle contents with given string on each line
    :Context:  editing
    :END:
    The string's width need not be the same width of the rectangle. If
    the string's width is less, the text after the rectangle shifts
    left; if the string is wider than the rectangle, the text after
    the rectangle shifts right.
*** string-insert-rectangle                                     :region:edit:
    :PROPERTIES:
    :Description: Insert given string on each line of rectangle
    :Context:  editing
    :END:
*** rectangle-mark-mode                                 :region:display:mode:
    :PROPERTIES:
    :Command:  C-x <SPC>
    :Description: Toggle Rectangle Mark mode
    :Context:  navigating
    :END:
*** rectangle-exchange-point-and-mark                        :region:display:
    :PROPERTIES:
    :Command:  C-x C-x
    :Description: Cycle between four corners of region-rectangle
    :Context:  rectangle
    :END:
*** cua-mode                               :command:keys:mode:edit:kill:undo:
    :PROPERTIES:
    :Description: Toggle CUA mode
    :Context:  navigating
    :END:
*** kill-region                                     :kill:region:edit:delete:
    :PROPERTIES:
    :Command:  C-x <timeout>
    :Description: Kill ("cut") text between point and mark
    :Context:  cua
    :Argument: numeric
    :END:
    With a one digit numeric prefix kill text into that numbered
    register.
*** copy-region-as-kill                                         :kill:region:
    :PROPERTIES:
    :Command:  C-c <timeout>
    :Description: Save the region as if killed, but don't kill it
    :Context:  cua
    :Argument: numeric
    :END:
    With a one digit numeric prefix copy text into that numbered
    register.
*** cua-paste                                                          :edit:
    :PROPERTIES:
    :Command:  C-v
    :Description: Paste last cut or copied region or rectangle
    :Context:  cua
    :Argument: numeric
    :END:
    With a one digit numeric prefix paste text from that numbered
    register.
*** undo                                                               :undo:
    :PROPERTIES:
    :Command:  C-z
    :Description: Undo some previous changes
    :Context:  cua
    :END:
*** cua-set-rectangle-mark                                      :region:mode:
    :PROPERTIES:
    :Command:  C-<RET>
    :Description: Set mark and start in CUA rectangle mode
    :Context:  cua
    :END:
*** cua-rotate-rectangle                                         :region:nav:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Move to next corner of rectangle selection (clockwise)
    :Context:  cua-rectangle
    :END:
*** cua-toggle-global-mark                                             :edit:
    :PROPERTIES:
    :Command:  C-S-<SPC>
    :Description: Set or cancel the global marker
    :Context:  cua
    :END:
** Registers
*** view-register                                     :window:register:helps:
    :PROPERTIES:
    :Description: Display a description of what given register contains
    :Context:  anywhere
    :END:
    test
*** Display Available Registers                  :window:register:char:helps:
    :PROPERTIES:
    :Command:  C-h OR <F1>
    :Description: Explicitly request to preview available registers
    :Context:  register
    :END:
*** point-to-register                                   :register:nav:buffer:
    :PROPERTIES:
    :Command:  C-x r <SPC>
    :Description: Record current buffer and position in given register
    :Context:  navigating
    :END:
*** jump-to-register                                    :register:nav:buffer:
    :PROPERTIES:
    :Command:  C-x r j
    :Description: Restore state saved in given register
    :Context:  anywhere
    :Argument: plain
    :END:
    If given register stored a position in a buffer then this command
    jumps to saved position and buffer in given register.

    If you use this command to go to a saved position, but the buffer
    it was saved from has been killed, the command tries to create the
    buffer again by visiting the same file. Of course, this works only
    for buffers that were visiting files.

    If given register stored a window configuration then using this
    command restores the window configuration. When you restore a
    frame configuration, any existing frames not included in the
    configuration become invisible.

    If given register stored a window configuration then with a plain
    argument this command will delete any frames that are not included
    in the configuration.

    If given register stored a complete filename with path then this
    command visits that file.

    If given register stored a keyboard macro this command executes
    the keyboard macro.
*** copy-to-register                                        :region:register:
    :PROPERTIES:
    :Command:  C-x r s
    :Description: Copy region into given register
    :Context:  navigating
    :Argument: plain
    :END:
    If the mark is inactive, Emacs first reactivates the mark where it
    was last set. The mark is deactivated at the end of this command.

    With a plain argument this command copies the text into given
    register and deletes the text from the buffer as well.
*** insert-register                                    :region:register:edit:
    :PROPERTIES:
    :Command:  C-x r i
    :Description: Insert contents from given register at point
    :Context:  editing
    :Argument: plain
    :END:
    Normally this leaves point after the text and sets the mark
    before, without activating it.

    With a prefix argument, it instead puts point before the text and
    the mark after.

    Will insert rectangle if given register contains a rectangle.

    When contents of register is a number, will insert number from
    given register at point.
*** append-to-register                                      :region:register:
    :PROPERTIES:
    :Description: Append region to text in given register
    :Context:  navigating
    :Argument: plain
    :END:
    If invoked with a plain argument, it deletes the region after
    appending it to the register.
*** increment-register                                             :register:
    :PROPERTIES:
    :Command:  C-x r +
    :Description: Behaves different depending on contents of register
    :Context:  anywhere
    :Argument: numeric
    :END:
    When given register contains text, this command appends text in
    region to that register.

    When given register contains a number, this command increases that
    number by 1.

    With a numeric argument, when the register contains a number, this
    adds the number in the register with the numeric argument and
    stores the sum in the register.
*** prepend-to-register                                     :region:register:
    :PROPERTIES:
    :Description: Prepend region to text in given register
    :Context:  navigating
    :Argument: plain
    :END:
    If invoked with a prefix argument, it deletes the region after
    prepending it to the given register.
*** copy-rectangle-to-register                              :region:register:
    :PROPERTIES:
    :Command:  C-x r r
    :Description: Copy region-rectangle into given register
    :Context:  navigating
    :Argument: plain
    :END:
    With a plain argument, delete the rectangle in addition to copying
    the rectangle to the given register.
*** window-configuration-to-register                  :window:frame:register:
    :PROPERTIES:
    :Command:  C-x r w
    :Description: Save state of selected frame's windows in given register
    :Context:  anywhere
    :END:
*** frameset-to-register                              :window:frame:register:
    :PROPERTIES:
    :Command:  C-x r f
    :Description: Save state of all frames, all windows, in given register
    :Context:  anywhere
    :END:
*** number-to-register                                             :register:
    :PROPERTIES:
    :Command:  C-x r n
    :Description: Store number 0 in given register
    :Context:  anywhere
    :Argument: numeric
    :END:
    With a numeric argument store that number into the given
    register.
*** kmacro-to-register                                       :macro:register:
    :PROPERTIES:
    :Command:  C-x C-k x
    :Description: Stores the last keyboard macro in given register
    :Context:  anywhere
    :END:
*** bookmark-set                                                 :buffer:nav:
    :PROPERTIES:
    :Command:  C-x r m
    :Description: Set the bookmark named with given name at point
    :Context:  navigating
    :END:
    Default name for bookmark is the file name.
*** bookmark-set-no-overwrite                                    :buffer:nav:
    :PROPERTIES:
    :Command:  C-x r M
    :Description: set bookmark without overwriting existing bookmark
    :Context:  navigating
    :END:
    Displays error if attempting to overwrite an existing bookmark
*** bookmark-jump                                                :buffer:nav:
    :PROPERTIES:
    :Command:  C-x r b
    :Description: Jump to bookmark with given name
    :Context:  anywhere
    :END:
*** list-bookmarks                                          :buffer:list:nav:
    :PROPERTIES:
    :Command:  C-x r l
    :Description: List all bookmarks
    :Context:  anywhere
    :END:
*** bookmark-save                                          :files:nav:buffer:
    :PROPERTIES:
    :Description: Save all current bookmark values in default bookmark file
    :Context:  anywhere
    :END:
*** bookmark-load                                          :buffer:nav:files:
    :PROPERTIES:
    :Description: Load file with given name containing bookmarks
    :Context:  anywhere
    :END:
    You can use this command to work with other files of bookmark
    values in addition to your default bookmark file.
*** bookmark-write                                         :buffer:nav:files:
    :PROPERTIES:
    :Description: Save all current bookmark values in given file
    :Context:  anywhere
    :END:
*** bookmark-delete                                       :buffer:nav:delete:
    :PROPERTIES:
    :Description: Delete bookmark with given name
    :Context:  anywhere
    :END:
*** bookmark-insert-location                          :buffer:nav:files:edit:
    :PROPERTIES:
    :Description: Insert in buffer the filename pointed to by given bookmark
    :Context:  editing
    :END:
*** bookmark-insert                                         :buffer:nav:edit:
    :PROPERTIES:
    :Description: Insert in buffer the content that given bookmark points to
    :Context:  editing
    :END:
** Controlling the Display
*** scroll-up                                                   :display:nav:
    :PROPERTIES:
    :Description: Like ~C-v~ but disobeys ~scroll-error-top-bottom~
    :Context:  navigating
    :END:
*** scroll-down                                                 :display:nav:
    :PROPERTIES:
    :Description: Like ~M-v~ but disobeys ~scroll-error-top-bottom~
    :END:
*** scroll-up-line                                              :display:nav:
    :PROPERTIES:
    :Description: Scroll the current window up by one line at a time
    :Context:  navigating
    :END:
*** scroll-down-line                                            :display:nav:
    :PROPERTIES:
    :Description: Scroll current window down by one line at a time
    :Context:  navigating
    :END:
*** recenter-top-bottom                                         :display:nav:
    :PROPERTIES:
    :Command:  C-l
    :Description: Scroll selected window so current line is center
    :Context:  navigating
    :Argument: numeric, plain
    :END:
    On subsequent consecutive invocations, make the current line the
    top line, the bottom line, and so on in cyclic order. Possibly
    redisplay the screen too.

    With a plain prefix argument, the command simply recenters the
    line showing point.

    A positive argument /n/ moves the line showing point /n/ lines
    down from the top of the window. An argument of zero moves point's
    line to the top of the window. A negative argument /-n/ moves
    point's line /n/ lines from the bottom of the window.

    When given an argument, the command does not clear the screen or
    cycle through different screen positions
*** recenter                                                    :display:nav:
    :PROPERTIES:
    :Description: Scroll selected window so current line is center
    :Context:  navigating
    :END:
    Possibly redisplay the screen too.
*** reposition-window                                           :display:nav:
    :PROPERTIES:
    :Command:  C-M-l
    :Description: Scroll heuristically to bring useful information on screen
    :Context:  navigating
    :END:
*** scroll-left                                                 :display:nav:
    :PROPERTIES:
    :Command:  C-x <
    :Description: Scroll text in current window to the left
    :Context:  navigating
    :Argument: numeric
    :END:
    scrolls text in the selected window to the left by the full width
    of the window, less two columns. (In other words, the text in the
    window moves left relative to the window.) with a numeric argument
    /n/, it scrolls by /n/ columns.

    If the text is scrolled to the left, and point moves off the left
    edge of the window, the cursor will freeze at the left edge of the
    window, the cursor will freeze at the left edge of the window,
    until point moves back to the displayed portion of the text. This
    is independent of the current setting of ~auto-hscroll-mode~,
    which for text scrolled to the left, only affects the behavior at
    the right edge of the window.
*** scroll-right                                                :display:nav:
    :PROPERTIES:
    :Command:  C-x >
    :Description: Scroll to the right
    :Context:  navigating
    :Argument: numeric
    :END:
    Scrolls similarly as ~scroll-left~ but to the right. The window
    cannot be scrolled any farther to the right once it is displayed
    normally, with each line starting at the window's left margin;
    attempting to do so has no effect. This means that you don't have
    to calculate the numeric argument precisely for this command; any
    sufficiently large argument will restore the normal display.
*** narrow-to-region                                  :buffer:display:region:
    :PROPERTIES:
    :Command:  C-x n n
    :Description: Narrow down to between point and mark
    :Context:  navigating
    :END:
    This sets the current buffer's restrictions so that the text in
    the current region remains accessible, but all the text before the
    region or after the region is inaccessible. Point and mark do not
    change.
*** widen                                                    :buffer:display:
    :PROPERTIES:
    :Command:  C-x n w
    :Description: Widen to make the entire buffer accessible again.
    :Context:  navigating
    :END:
*** narrow-to-page                                           :buffer:display:
    :PROPERTIES:
    :Command:  C-x n p
    :Description: Narrow down to the current page
    :Context:  navigating
    :END:
*** narrow-to-defun                                          :buffer:display:
    :PROPERTIES:
    :Command:  C-x n d
    :Description: Narrow down to the current defun
    :Context:  navigating
    :END:
*** View-quit                                               :nav:mode:buffer:
    :PROPERTIES:
    :Command:  q
    :Description: Disables View mode, restoring prev buffer and position
    :Context:  view
    :END:
*** View-exit                                               :nav:mode:buffer:
    :PROPERTIES:
    :Command:  e
    :Description: Disables View mode keeping buffer and position
    :Context:  view
    :END:
*** view-buffer                                     :display:buffer:nav:mode:
    :PROPERTIES:
    :Description: Enables View mode on provided buffer
    :Context:  anywhere
    :END:
*** view-file                                        :display:files:nav:mode:
    :PROPERTIES:
    :Description: Enables View mode on provided file
    :Context:  anywhere
    :END:
*** follow-mode                        :display:nav:window:frame:buffer:mode:
    :PROPERTIES:
    :Description: Enable/disable Follow mode
    :Context:  follow-ready
    :END:
*** list-faces-display                                 :window:helps:display:
    :PROPERTIES:
    :Description: See what faces are currently defined
    :Context:  navigating
    :Argument: plain
    :END:
    With a plain prefix argument, this prompts for a regular
    expression, and displays only faces with names matching that
    regular expression
*** list-colors-display                                :window:display:helps:
    :PROPERTIES:
    :Description: View list of color names
    :Context:  anywhere
    :END:
    If you run the command on a text terminal, it shows only a small
    subset of colors that can be safely displayed on such
    terminals.

    Also shows the equivalent RGB triplet for each named color. For
    instance, ~medium sea green~ is equivalent to ~#3CB371~.
*** set-face-foreground                                        :display:echo:
    :PROPERTIES:
    :Description: Change foreground color of a face
    :Context:  anywhere
    :END:
    Affects the face colors on all frames, but the effect does not
    persist for future Emacs sessions.
*** set-face-background                                        :display:echo:
    :PROPERTIES:
    :Description: Change background color of a face
    :Context:  anywhere
    :END:
    Affects the face colors on all frames, but the effect does not
    persist for future Emacs sessions.
*** text-scale-adjust                                               :display:
    :PROPERTIES:
    :Command:  C-x C-0 OR C-x C-= OR C-x C-- OR C-x C-+
    :Description: Adjust the height of the default face
    :Context:  anywhere
    :Argument: numeric
    :END:
    This command looks at the last key typed to determine which action
    to take.

    - ~+~, ~=~ :: Increase the default face height by one step
    - ~-~ :: Decrease the default face height by one step
    - ~0~ :: Reset the default face height to the global default

    The final key of these commands may be repeated without the
    leading ~C-x~. For instance, ~C-x C-= C-= C-=~ increases the face
    height by three steps. Each step scales the text height by a
    factor of 1.2.

    A numeric argument of 0 to this command restores the default
    height, the same as typing ~C-x C-0~.
*** text-scale-increase                                             :display:
    :PROPERTIES:
    :Description: Increase the height of the default face
    :Context:  anywhere
    :END:
    You may find it convenient to bind the key ~C-x C-+~ to this
    command, rather than ~text-scale-adjust~
*** text-scale-decrease                                             :display:
    :PROPERTIES:
    :Description: Decrease the height of the default face
    :Context:  anywhere
    :END:
    You may find it convenient to bind the key ~C-x C--~ to this
    command rather than ~text-scale-adjust~.
*** text-scale-set                                             :display:mode:
    :PROPERTIES:
    :Description: Scales height of default face to level of prefix argument
    :Context:  anywhere
    :Argument: numeric
    :END:
    This command automatically enables the minor mode
    ~text-scale-mode~ if the current font scaling is other than 1, and
    disable it otherwise.
*** font-lock-mode                                      :display:mode:buffer:
    :PROPERTIES:
    :Description: Toggle Font Lock mode in current buffer
    :Context:  anywhere
    :Argument: numeric
    :END:
    A positive numeric argument unconditionally enables Font Lock
    mode, and a negative or zero argument disables it.
*** global-font-lock-mode                               :display:mode:buffer:
    :PROPERTIES:
    :Description: Toggle Font Lock mode in all buffers
    :Context:  anywhere
    :END:
*** highlight-changes-mode                              :display:buffer:mode:
    :PROPERTIES:
    :Description: Toggle Highlight Changes mode
    :Context:  editing
    :END:
*** hi-lock-mode                                        :display:buffer:mode:
    :PROPERTIES:
    :Description: Toggle Hi Lock mode
    :Context:  navigating
    :END:
*** global-hi-lock-mode                                 :display:buffer:mode:
    :PROPERTIES:
    :Description: Toggle Hi Lock mode in all buffers
    :Context:  anywhere
    :END:
*** highlight-regexp                                  :display:buffer:search:
    :PROPERTIES:
    :Command:  M-s h r
    :Description: Highlight text that matches given regexp using given face
    :Context:  navigating
    :END:
    While being prompted for a face use ~M-n~ and ~M-p~ to cycle
    through them.

    You can use this command multiple times, specifying various
    regular expressions to highlight in different ways.
*** next-history-element                                  :echo:hist:display:
    :PROPERTIES:
    :Command:  M-n
    :Description: Select next available list option in minibuffer
    :Context:  mini-select-list
    :END:
*** previous-history-element                              :echo:hist:display:
    :PROPERTIES:
    :Command:  M-p
    :Description: Select previous available list option in minibuffer
    :Context:  mini-select-list
    :END:
*** unhighlight-regexp                                       :display:buffer:
    :PROPERTIES:
    :Command:  M-s h u
    :Description: Unhighlight given regexp
    :Context:  navigating
    :END:
    If you invoke this from the menu, you select the expression to
    unhighlight from a list. If you invoke this from the keyboard, you
    use the minibuffer. It will show the most recently added regular
    expression; use ~M-n~ to show the next older expression and ~M-p~
    to select the next newer expression. (You can also type the
    expression by hand, with completion.) When the expression you want
    to unhighlight appears in the minibuffer, press ~RET~ to exit the
    minibuffer and unhighlight it.
*** highlight-lines-matching-regexp              :display:buffer:line:search:
    :PROPERTIES:
    :Command:  M-s h l
    :Description: Hi-light lines with match for given regexp using given face
    :Context:  navigating
    :END:
*** highlight-phrase                                  :display:buffer:search:
    :PROPERTIES:
    :Command:  M-s h p
    :Description: Highlight matches of given phrase using given face
    :Context:  navigating
    :END:
    Given phrase can be any regexp, but spaces will be replaced by
    matches to whitespace and initial lower-case letters will become
    case insensitive.
*** highlight-symbol-at-point                           :display:buffer:word:
    :PROPERTIES:
    :Command:  M-s h .
    :Description: Highlight the symbol found near point, using next face
    :Context:  navigating
    :END:
*** hi-lock-write-interactive-patterns                  :display:buffer:edit:
    :PROPERTIES:
    :Command:  M-s h w
    :Description: Insert all highlight regexp/face pairs commented at point
    :Context:  editing
    :END:
*** hi-lock-find-patterns                             :display:buffer:search:
    :PROPERTIES:
    :Command:  M-s h f
    :Description: Extract regexp/face pairs from comments in buffer
    :Context:  navigating
    :END:
*** fringe-mode                                   :window:display:mode:frame:
    :PROPERTIES:
    :Description: Toggle Fringe mode in all frames
    :Context:  anywhere
    :END:
*** set-fringe-style                                   :window:display:frame:
    :PROPERTIES:
    :Description: Toggle Fringe mode in current frame
    :Context:  anywhere
    :END:
*** display-fill-column-indicator-mode                :display:window:buffer:
    :PROPERTIES:
    :Description: Toggle Display Fill Column Indicator mode in buffer
    :Context:  navigating
    :END:
    Can be used as a hook
*** global-display-fill-column-indicator-mode                :display:window:
    :PROPERTIES:
    :Description: Toggle Display Fill Column Indicator mode globally
    :Context:  anywhere
    :END:
*** delete-trailing-whitespace                                  :edit:buffer:
    :PROPERTIES:
    :Description: Delete all trailing whitespace
    :Context:  editing
    :END:
    This command deletes all extra spaces at the end of each line in
    the buffer, and all empty lines at the end of the buffer; If the
    region is active, the command instead deletes extra spaces at the
    end of each line in the region.
*** whitespace-mode                                          :display:buffer:
    :PROPERTIES:
    :Description: Toggle Whitespace mode for current buffer
    :Context:  navigating
    :END:
*** whitespace-toggle-options                                :display:buffer:
    :PROPERTIES:
    :Description: Toggle Individual whitespace (ws) elements for ws mode
    :Context:  navigating
    :END:
    Here is a partial list of possible elements (see the variable's
    documentation for the full list):
    - ~face~ :: Enable all visualizations which use special
      faces. This element has a special meaning: if it is absent from
      the list, none of the other visualizations take effect except
      ~space-mark~, ~tab-mark~, and ~newline-mark~.
    - ~trailing~ :: Highlight trailing whitespace.
    - ~tabs~ :: Highlight tab characters.
    - ~spaces~ :: Highlight space and non-breaking space characters.
    - ~lines~ :: Highlight lines longer than 80 columns. To change the
      column limit, customize the variable ~whitespace-line-column~.
    - ~newline~ :: Highlight newlines.
    - ~empty~ :: Highlight empty lines at the beginning and/or end of
      the buffer.
    - ~big-indent~ :: Highlight too-deep indentation. By default any
      sequence of at least 4 consecutive tab characters or 32
      consecutive space characters is highlighted. To change that,
      customize the regular expression
      ~whitespace-big-indent-regexp~.
    - ~space-mark~ :: Draw space and non-breaking characters with a
      special glyph.
    - ~tab-mark~ :: Draw tab characters with a special glyph.
    - ~newline-mark~ :: Draw newline characters with a special glyph.
*** global-whitespace-mode                                   :display:buffer:
    :PROPERTIES:
    :Description: Toggle Global Whitespace mode in all buffers
    :Context:  anywhere
    :END:
*** global-whitespace-toggle-options                         :display:buffer:
    :PROPERTIES:
    :Description: Toggle individual features of Global Whitespace mode
    :Context:  anywhere
    :END:
    See ~whitespace-toggle-options~ for some examples
*** set-selective-display                               :display:buffer:line:
    :PROPERTIES:
    :Command:  C-x $
    :Description: Hide lines with indent given by numeric argument
    :Context:  navigating
    :Argument: numeric
    :END:
    To hide lines in the current buffer, use this command with a
    numeric argument /n/. Then lines with at least /n/ columns of
    indentation disappear from the screen. The only indication of
    their presence is that three dots ('...') appear at the end of
    each visible line that is followed by one or more hidden ones.

    The hidden lines are still present in the buffer, and most editing
    commands see them as usual, so you may find point in the middle of
    the hidden text. When this happens, the cursor appears at the end
    of the previous line, after the three dots. If the point is at the
    end of the visible line, before the newline that ends it, the
    cursor appears before the three dots.

    To make all lines visible again, use the command with no
    argument.
*** size-indication-mode                                :display:mode:inform:
    :PROPERTIES:
    :Description: Toggle Size Indication mode
    :Context:  anywhere
    :END:
*** column-number-mode                                  :display:mode:inform:
    :PROPERTIES:
    :Description: Toggle Column Number mode
    :Context:  anywhere
    :END:
*** display-time                                        :display:mode:inform:
    :PROPERTIES:
    :Description: Enable Display Time mode
    :Context:  anywhere
    :END:
*** display-time-mode                                   :display:mode:inform:
    :PROPERTIES:
    :Description: Toggle Display Time mode
    :Context:  anywhere
    :END:
*** display-battery-mode                                :display:mode:inform:
    :PROPERTIES:
    :Description: Toggle Display Battery mode
    :Context:  anywhere
    :END:
*** blink-cursor-mode                                           :display:nav:
    :PROPERTIES:
    :Description: Toggle Blink Cursor mode
    :Context:  anywhere
    :END:
*** global-hl-line-mode                                         :display:nav:
    :PROPERTIES:
    :Description: Toggle HL Line mode globally
    :Context:  anywhere
    :END:
*** toggle-truncate-lines                                      :display:line:
    :PROPERTIES:
    :Description: Toggle Truncate Lines
    :Context:  navigating
    :END:
    This works by locally changing the variable ~truncate-lines~.
*** visual-line-mode                                         :display:buffer:
    :PROPERTIES:
    :Description: Toggle Visual Line mode
    :Context:  navigating
    :END:
*** global-visual-line-mode                                  :display:buffer:
    :PROPERTIES:
    :Description: Toggle Visual Line mode in all buffers
    :Context:  anywhere
    :END:
*** beginning-of-visual-line                                       :nav:line:
    :PROPERTIES:
    :Command:  C-a
    :Description: Moves to the beginning of the screen line
    :Context:  visual-line-mode
    :END:
*** end-of-visual-line                                             :nav:line:
    :PROPERTIES:
    :Command:  C-e
    :Description: Moves to the end of the screen line
    :Context:  visual-line-mode
    :END:
*** kill-visual-line                                       :edit:line:delete:
    :PROPERTIES:
    :Command:  C-k
    :Description: Kills test to the end of the screen line
    :Context:  visual-line-mode
    :END:
*** next-logical-line                                            :nav:buffer:
    :PROPERTIES:
    :Description: Move point to the next logical line
    :Context:  navigating
    :END:
    This works regardless of whether Visual Line mode is enabled.
*** previous-logical-line                                        :nav:buffer:
    :PROPERTIES:
    :Description: Move point to the previous logical line
    :Context:  navigating
    :END:
    This works regardless of whether Visual Line mode is enabled.
*** display-line-numbers-mode                         :display:buffer:window:
    :PROPERTIES:
    :Description: Toggle Display Line Numbers mode for buffer
    :Context:  navigating
    :END:
*** global-display-line-numbers-mode                  :display:buffer:window:
    :PROPERTIES:
    :Description: Toggle Display Line Numbers mode for all buffers
    :Context:  navigating
    :END:
** Searching and Replacement
*** isearch-forward                                           :search:buffer:
    :PROPERTIES:
    :Command:  C-s
    :Description: Incremental search forward
    :Context:  anywhere
    :Argument: plain
    :END:
    With a plain argument this invokes an incremental search for a
    regexp
*** isearch-backward                                          :search:buffer:
    :PROPERTIES:
    :Command:  C-r
    :Description: Incremental search backward
    :Context:  anywhere
    :Argument: plain
    :END:
    With a plain argument this invokes searching backward for a regexp
*** isearch-delete-char                                       :search:buffer:
    :PROPERTIES:
    :Command:  <DEL>
    :Description: cancel the last input item entered during isearch
    :Context:  isearch
    :END:
*** isearch-exit                                          :search:nav:buffer:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Stops searching, leaving the cursor at search result
    :Context:  isearch
    :END:
*** isearch-cancel                                              :search:undo:
    :PROPERTIES:
    :Command:  <ESC> <ESC> <ESC>
    :Description: Abandon the search and return to where you started
    :Context:  isearch
    :END:
*** isearch-abort                                               :search:undo:
    :PROPERTIES:
    :Command:  C-g C-g
    :Description: Abandon the search and return to where you started
    :Context:  isearch
    :END:
*** isearch-repeat-forward                                :search:nav:buffer:
    :PROPERTIES:
    :Command:  C-s
    :Description: Move to the next occurrence of the search string
    :Context:  isearch
    :Argument: numeric
    :END:
    You can supply a numeric prefix argument of /n/ to this command to
    find the /n/-th next occurrence.
*** isearch-repeat-backward                               :search:nav:buffer:
    :PROPERTIES:
    :Command:  C-r
    :Description: Move to the previous occurrence of the search string
    :Context:  isearch
    :Argument: numeric
    :END:
    You can supply a numeric prefix argument of /n/ to this command to
    find the /n/-th previous occurrence.
*** isearch-ring-retreat                                        :search:edit:
    :PROPERTIES:
    :Command:  M-p
    :Description: Iterate through the search ring backwards
    :Context:  isearch
    :END:
*** isearch-ring-advance                                        :search:edit:
    :PROPERTIES:
    :Command:  M-n
    :Description: Iterate through the search ring forwards
    :Context:  isearch
    :END:
*** isearch-edit-string                             :search:edit:echo:buffer:
    :PROPERTIES:
    :Command:  M-e
    :Description: Edit current search string in minibuffer
    :Context:  isearch
    :END:
*** isearch-forward-exit-minibuffer              :search:command:echo:buffer:
    :PROPERTIES:
    :Command:  C-s
    :Description: Finish editing search string and search forward
    :Context:  isearch-after-edit
    :END:
*** isearch-reverse-exit-minibuffer              :search:command:echo:buffer:
    :PROPERTIES:
    :Command:  C-r
    :Description: Finish editing search string and reverse search
    :Context:  isearch-after-edit
    :END:
*** isearch-yank-char-in-minibuffer                 :search:edit:echo:buffer:
    :PROPERTIES:
    :Command:  <right> OR C-f
    :Description: Add to search string chars following point in buffer
    :Context:  isearch-after-edit
    :END:
*** isearch-yank-word-or-char                                   :edit:search:
    :PROPERTIES:
    :Command:  C-w
    :Description: Appends next char or word at point to search string
    :Context:  isearch
    :Argument: numeric
    :END:
    With a prefix numeric argument of /n/, append the next /n/
    characters or words.
*** isearch-yank-symbol-or-char                                 :search:edit:
    :PROPERTIES:
    :Command:  C-M-w
    :Description: Appends next char or symbol at point to search string
    :Context:  isearch
    :Argument: numeric
    :END:
    With a prefix numeric argument of /n/, append the next /n/
    characters or symbols.
*** isearch-yank-line                                           :search:edit:
    :PROPERTIES:
    :Command:  M-s C-e
    :Description: Append rest of current line to search string
    :Context:  isearch
    :Argument: numeric
    :END:
    If point is already at the end of a line, it appends the next
    line. With a prefix argument /n/, it appends the next /n/ lines.
*** isearch-yank-until-char                                     :search:edit:
    :PROPERTIES:
    :Command:  C-M-z
    :Description: appends to search string from point to given char
    :Context:  isearch
    :Argument: numeric
    :END:
    With a prefix numeric argument of /n/, the command appends
    everything from point to the /n/-th occurrence of the specified
    character.
*** isearch-yank-kill                                           :search:edit:
    :PROPERTIES:
    :Command:  C-y
    :Description: Appends the current kill to the search string
    :Context:  isearch
    :END:
*** isearch-yank-pop                                            :search:edit:
    :PROPERTIES:
    :Command:  M-y
    :Description: Replaces most recent yank with an earlier kill
    :Context:  isearch-after-yank
    :END:
*** isearch-yank-x-selection                                    :search:edit:
    :PROPERTIES:
    :Command:  <mouse-2>
    :Description: Appends current X selection to search string
    :Context:  isearch
    :END:
    Must be clicked in the echo area during an isearch
*** isearch-del-char                                     :search:delete:edit:
    :PROPERTIES:
    :Command:  C-M-d
    :Description: Deletes the last character from the search string
    :Context:  isearch
    :END:
*** isearch-yank-char                                           :search:edit:
    :PROPERTIES:
    :Command:  C-M-y
    :Description: Appends character after point to search string
    :Context:  isearch
    :END:
*** isearch-toggle-lax-whitespace                               :search:menu:
    :PROPERTIES:
    :Command:  M-s <SPC>
    :Description: Toggle lax space matching
    :Context:  isearch
    :END:
*** isearch-toggle-case-fold                                    :search:menu:
    :PROPERTIES:
    :Command:  M-c OR M-s c
    :Description: Toggle isearch case sensitivity
    :Context:  isearch
    :END:
*** isearch-toggle-char-fold                                    :search:menu:
    :PROPERTIES:
    :Command:  M-s '
    :Description: Toggle considering character folding like diacritics
    :Context:  isearch
    :END:
*** isearch-toggle-invisible                                    :search:menu:
    :PROPERTIES:
    :Command:  M-s i
    :Description: Toggle searching for invisible text
    :Context:  isearch
    :END:
*** isearch-toggle-regexp                                       :search:menu:
    :PROPERTIES:
    :Command:  M-r OR M-s r
    :Description: Toggle between non-regexp and regexp inc search
    :Context:  isearch
    :END:
*** isearch-toggle-symbol                                       :search:menu:
    :PROPERTIES:
    :Command:  M-s _
    :Description: Toggle symbol search
    :Context:  isearch
    :END:
*** isearch-printing-char                                       :search:edit:
    :PROPERTIES:
    :Command:  C-j
    :Description: Search for a newline character
    :Context:  isearch
    :END:
*** isearch-quote-char                                          :search:edit:
    :PROPERTIES:
    :Command:  C-q
    :Description: Add character to search by octal character code
    :Context:  isearch
    :END:
*** isearch-char-by-name                                        :search:edit:
    :PROPERTIES:
    :Command:  C-x 8 <RET>
    :Description: Add char by Unicode name or hex code to search
    :Context:  isearch
    :END:
*** isearch-toggle-input-method                                 :search:menu:
    :PROPERTIES:
    :Command:  C-\
    :Description: Toggle the input method
    :Context:  isearch
    :END:
*** isearch-toggle-specified-input-method                       :search:menu:
    :PROPERTIES:
    :Command:  C-^
    :Description: Turn on a non-default input method
    :Context:  isearch
    :END:
*** isearch-occur                                               :search:edit:
    :PROPERTIES:
    :Command:  M-s o
    :Description: Runs ~occur~ with the current search string
    :Context:  isearch
    :END:
*** isearch-query-replace                                       :search:menu:
    :PROPERTIES:
    :Command:  M-%
    :Description: Invokes find replace with current search string
    :Context:  isearch
    :Argument: numeric
    :END:
    A negative prefix argument means to replace backward.
*** isearch-query-replace-regexp                                :search:menu:
    :PROPERTIES:
    :Command:  C-M-%
    :Description: Invokes find replace with current string as regexp
    :Context:  isearch
    :END:
*** isearch-complete                                            :search:edit:
    :PROPERTIES:
    :Command:  M-<TAB>
    :Description: Attempts to complete search string using search ring
    :Context:  isearch
    :END:
*** isearch-highlight-regexp                                 :search:display:
    :PROPERTIES:
    :Command:  M-s h r
    :Description: Exit search highlighting search string matches
    :Context:  isearch
    :END:
*** isearch-highlight-lines-matching-regexp              :search:display:line:
    :PROPERTIES:
    :Command:  M-s h l
    :Description: Exit search highlighting lines of matches
    :Context:  isearch
    :END:
*** isearch-help-map                                           :search:helps:
    :PROPERTIES:
    :Command:  C-h C-h
    :Description: Access interactive help options
    :Context:  isearch
    :END:
*** isearch-end-of-buffer                                        :search:nav:
    :PROPERTIES:
    :Command:  M-s M->
    :Description: Go to the last occurrence of search string
    :END:
*** isearch-beginning-of-buffer                                  :search:nav:
    :PROPERTIES:
    :Command:  M-s M-<
    :Description: Go to the first occurrence of search string
    :Context:  isearch
    :END:
*** search-forward                                                   :search:
    :PROPERTIES:
    :Description: Nonincremental forward search for literal strings
    :Context:  navigating
    :END:
*** search-backward                                                  :search:
    :PROPERTIES:
    :Description: Nonincremental backward search for literal strings
    :Context:  navigating
    :END:
*** isearch-forward-word                                             :search:
    :PROPERTIES:
    :Command:  M-s w
    :Description: Begin an incremental forward word search
    :Context:  navigating
    :END:
*** eww-search-words                                                 :search:
    :PROPERTIES:
    :Command:  M-s M-w
    :Description: Search the Web for the text in region
    :Context:  navigating
    :END:
*** word-search-forward                                              :search:
    :PROPERTIES:
    :Command:  M-s w <RET>
    :Description: Begin a nonincremental forward word search
    :Context:  navigating
    :END:
*** word-search-backward                                             :search:
    :PROPERTIES:
    :Command:  M-s w C-r <RET>
    :Description: To begin a nonincremental backward word search
    :Context:  navigating
    :END:
*** isearch-forward-symbol                                           :search:
    :PROPERTIES:
    :Command:  M-s _
    :Description: Begin an incremental forward symbol search
    :Context:  navigating
    :END:
*** isearch-forward-symbol-at-point                                  :search:
    :PROPERTIES:
    :Command:  M-s .
    :Description: Symbol incremental search forward using symbol at point
    :Context:  navigating
    :Argument: numeric
    :END:
    With a numeric prefix argument of /n/, this command will search
    for the /n/-th next occurrence of the symbol at point; negative
    values of /n/ search backwards.
*** isearch-forward-regexp                                          :search:
    :PROPERTIES:
    :Command:  C-M-s
    :Description: Begin incremental regexp search
    :Context:  anywhere
    :Argument: plain
    :END:
    If you use this command with a prefix argument, it performs
    ordinary string search, like ~isearch-forward~.
*** isearch-backward-regexp                                          :search:
    :PROPERTIES:
    :Command:  C-M-r
    :Description: Begin reverse incremental regexp search
    :Context:  anywhere
    :Argument: plain
    :END:
    If you use this command with a prefix argument, it performs
    ordinary search string, like ~isearch-backward~.
*** re-search-forward                                                :search:
    :PROPERTIES:
    :Command:  C-M-s <RET>
    :Description: Nonincremental regexp forward search
    :Context:  anywhere
    :END:
*** re-search-backward                                               :search:
    :PROPERTIES:
    :Command:  C-M-r <RET>
    :Description: Nonincremental backward regexp search
    :Context:  anywhere
    :END:
*** describe-categories                                          :helps:char:
    :PROPERTIES:
    :Description: Describe of the known character categories
    :Context:  anywhere
    :END:
*** replace-string                                              :search:edit:
    :PROPERTIES:
    :Description: Replace every occurrence of given string with newstring
    :Context:  editing
    :Argument: plain
    :END:
    Replacement happens only in the text after point, so if you want
    to cover the whole buffer you must go to the beginning first. All
    occurrences up to the end of the buffer are replaced; to limit
    replacement to part of the buffer, activate the region around that
    part. When the region is active, replacement is limited to the
    region.

    When a given string argument exists, it leaves point at the last
    occurrence replaced. It adds the prior position of point (where
    this command was issued) to the mark ring, without activating the
    mark.

    A prefix argument restricts replacement to matches that are
    surrounded by word boundaries.
*** replace-regexp                                              :search:edit:
    :PROPERTIES:
    :Description: Replace every match for given regexp with newstring
    :Context:  editing
    :END:
    In this command, the provided newstring need not be constant: it
    can refer to all or part of what is matched by the regexp. '~\&~'
    in newstring stands for the entire match being replaced. '~\d~' in
    newstring, where /d/ is a digit starting from 1, stands for
    whatever matched the /d/-th parenthesized grouping in
    regexp. (This is called a "back reference".) '~\#~' refers to the
    count of replacements already made in this command, as a decimal
    number. In the first replacement, '~\#~' stands for '~0~'; in the
    second, for '~1~'; and so on. To include a '~\~' in the text to
    replace with, you must enter '~\\~'.

    If you want to enter part of the replacement string by hand each
    time, use '~\?~' in the replacement string. Each replacement will
    ask you to edit the replacement string in the minibuffer, putting
    point where the '~\?~' was.
*** query-replace                                               :search:edit:
    :PROPERTIES:
    :Command:  M-%
    :Description: Replace some occurrences of given string with newstring
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument means to consider only occurrences that are
    bounded by word-delimiter characters. A negative prefix argument
    replaces backward.
*** query-replace-regexp                                        :search:edit:
    :PROPERTIES:
    :Command:  C-M-%
    :Description: Replace some matches for given regexp with newstring
    :Context:  editing
    :END:
*** QR Yes                                                      :search:edit:
    :PROPERTIES:
    :Command:  <SPC> OR y
    :Description: to replace the occurrence with newstring
    :Context:  query-replace
    :END:
*** QR Next                                                      :search:nav:
    :PROPERTIES:
    :Command:  <DEL> OR <Delete> OR <BACKSPACE> OR n
    :Description: to skip to the next occurrence without replacing this one
    :Context:  query-replace
    :END:
*** QR Replace and Stay                                         :search:edit:
    :PROPERTIES:
    :Command:  , <Comma>
    :Description: To replace this occurrence and display the result
    :Context:  query-replace
    :END:
*** QR Quit                                                          :search:
    :PROPERTIES:
    :Command:  <RET> OR q
    :Description: To exit without doing any more replacements
    :Context:  query-replace
    :END:
*** QR Replace and Quit                                         :search:edit:
    :PROPERTIES:
    :Command:  . <Period>
    :Description: To replace this occurrence and exit with no more replace
    :END:
*** QR Replace All                                              :search:edit:
    :PROPERTIES:
    :Command:  !
    :Description: To replace all remaining occurrences without asking again
    :Context:  query-replace
    :END:
*** QR Go Back                                                   :search:nav:
    :PROPERTIES:
    :Command:  ^
    :Description: To go back to the position of the previous occurrence
    :Context:  query-replace
    :END:
*** QR Undo Previous                                            :search:undo:
    :PROPERTIES:
    :Command:  u
    :Description: To undo the last replacement and go back there
    :Context:  query-replace
    :END:
*** QR Undo All                                                 :search:undo:
    :PROPERTIES:
    :Command:  U
    :Description: To undo all the replacements and go to first
    :Context:  query-replace
    :END:
*** QR Recursive Edit                                           :search:edit:
    :PROPERTIES:
    :Command:  C-r
    :Description: To enter a recursive editing level
    :Context:  query-replace
    :END:
*** exit-recursive-edit                                         :search:edit:
    :PROPERTIES:
    :Command:  C-M-c
    :Description: Exit recursive edit to previous command
    :Context:  recursive-edit
    :END:
*** QR Delete and Recursive Edit                         :search:edit:delete:
    :PROPERTIES:
    :Command:  C-w
    :Description: To delete the occurrence, then enter recursive edit
    :Context:  query-replace
    :END:
*** QR Edit Replace String                                      :search:edit:
    :PROPERTIES:
    :Command:  e OR E
    :Description: To edit replacement string in minibuffer
    :Context:  query-replace
    :END:
*** QR Redisplay                                             :search:display:
    :PROPERTIES:
    :Command:  C-l
    :Description: To redisplay the screen
    :Context:  query-replace
    :END:
*** QR Replace All Multi Buffer                                 :search:edit:
    :PROPERTIES:
    :Command:  Y
    :Description: replace all remaining matches in all buffers
    :Context:  query-replace
    :END:
*** QR Next All Multi Buffer                              :search:nav:buffer:
    :PROPERTIES:
    :Command:  N
    :Description: To skip to next buffer in multi-buffer replacements
    :Context:  query-replace
    :END:
*** QR Help                                                    :search:helps:
    :PROPERTIES:
    :Command:  C-h OR ? OR <F1>
    :Description: To display a message of all QR options
    :Context:  query-replace
    :END:
*** multi-isearch-buffers                                     :search:buffer:
    :PROPERTIES:
    :Description: Perform isearch in given buffers
    :Context:  anywhere
    :Argument: plain
    :END:
    With a prefix argument, prompt for a regexp and begin a
    multi-buffer incremental search in buffers matching that regexp.
*** multi-isearch-buffers-regexp                              :search:buffer:
    :PROPERTIES:
    :Description: Perform regexp isearch in given buffers
    :Context:  anywhere
    :Argument: plain
    :END:
    With a prefix argument, prompt for a regexp and begin a
    multi-buffer incremental search in buffers matching that regexp.
*** multi-isearch-files                                        :search:files:
    :PROPERTIES:
    :Description: Perform isearch in given files
    :Context:  anywhere
    :Argument: plain
    :END:
    With a prefix argument, prompt for a regexp and begin a multi-file
    incremental search in files matching that regexp.
*** multi-isearch-files-regexp                                 :search:files:
    :PROPERTIES:
    :Description: Perform regexp isearch in given files
    :Context:  anywhere
    :Argument: plain
    :END:
    With a prefix argument, prompt for a regexp and begin a multi-file
    incremental search in files matching that regexp.
*** occur                                                 :search:window:nav:
    :PROPERTIES:
    :Command:  M-s o
    :Description: Special occur mode window of regexp matches
    :Context:  navigating
    :Argument: numeric
    :END:
    A numeric argument /n/ specifies that /n/ lines of context are to
    be displayed before and after each matching line.
*** occur-mode-goto-occurrence                                   :search:nav:
    :PROPERTIES:
    :Command:  <RET>
    :Description: Visit corresponding position in buffer
    :Context:  occur
    :END:
*** occur-mode-goto-occurrence-other-window               :search:nav:window:
    :PROPERTIES:
    :Command:  o
    :Description: Display match in other window and make selected
    :Context:  occur
    :END:
*** occur-mode-display-occurrence                         :search:nav:window:
    :PROPERTIES:
    :Command:  C-o
    :Description: Display match in other window stay in occur
    :Context:  occur
    :END:
*** next-error                                            :search:nav:window:
    :PROPERTIES:
    :Command:  M-g M-n
    :Description: Visit occurrences one by one
    :Context:  occur
    :END:
*** occur-edit-mode                                      :search:window:edit:
    :PROPERTIES:
    :Command:  e
    :Description: Turn on Occur Edit mode
    :Context:  occur
    :END:
*** occur-cease-edit                                          :search:window:
    :PROPERTIES:
    :Command:  C-c C-c
    :Description: Return to Occur mode
    :Context:  occur-edit
    :END:
*** list-matching-lines                                       :search:window:
    :PROPERTIES:
    :Description: See ~occur~ command
    :Context:  navigating
    :END:
*** multi-occur                                        :search:window:buffer:
    :PROPERTIES:
    :Description: perform occur in given buffers
    :Context:  navigating
    :END:
*** multi-occur-in-matching-buffers              :search:window:buffer:files:
    :PROPERTIES:
    :Description: perform occur in buffers where files match given regexp
    :Context:  anywhere
    :Argument: plain
    :END:
    With a prefix argument, it uses the regular expression to match
    buffer names instead.
*** how-many                                                  :search:inform:
    :PROPERTIES:
    :Description: Display number of regexp matches that are after point
    :Context:  navigating
    :END:
*** flush-lines                                                 :search:edit:
    :PROPERTIES:
    :Description: Delete all lines that contain match after point
    :Context:  editing
    :END:
    Prompt for a regexp, and delete each line that contains a match
    for it, operating on the text after point. When the command
    finishes, it prints the number of deleted matching lines.

    The command deletes the current line if it contains a match
    starting after point. If the region is active, it operates on the
    region instead; if a line partially contained in the region
    contains a match entirely contained in the region, it is deleted.

    If a match is split across lines, the command deletes all those
    lines. It deletes the line before starting to look for the next
    match; hence, it ignores a match starting on the same line at
    which another match ended.
*** keep-lines                                                  :search:edit:
    :PROPERTIES:
    :Description: Delete each line that does not have match for given regexp
    :Context:  editing
    :END:
    Prompt for a regexp, and delete each line that does not contain a
    match for it, operating on the text after point. If point is not
    at the beginning of a line, this command always keeps the current
    line. If the region is active, the command operates on the region
    instead; it never deletes lines that are only partially contained
    in the region (a newline that ends a line counts as part of that
    line).

    If a match is split across lines, this command keeps all those
    lines.
** Commands for Fixing Typos
*** undo-only                                                          :undo:
    :PROPERTIES:
    :Description: Undo without redoing previous undo commands
    :Context:  editing
    :END:
*** revert-buffer                                               :undo:buffer:
    :PROPERTIES:
    :Description: Discard all changes since buffer was last visited/saved
    :END:
*** transpose-chars                                               :edit:char:
    :PROPERTIES:
    :Command:  C-t
    :Description: Transpose two characters
    :Context:  editing
    :Argument: numeric
    :END:
    Normally, this transposes the two characters on either side of
    point. When given at the end of a line, rather than transposing
    the last character of the line with the newline, which would be
    useless, this transposes the last two characters on the line.

    A numeric argument to this command serves as a repeat count: it
    tells the transpose command do move the character before point
    across several other characters.

    A numeric argument of zero is assigned a special meaning: to
    transpose the character ending after point with the one ending
    after the mark.
*** transpose-words                                               :edit:word:
    :PROPERTIES:
    :Command:  M-t
    :Description: Transpose two words
    :Context:  editing
    :Argument: numeric
    :END:
    This transposes the word before or containing point with the word
    after point. It moves point forward over a word, dragging the word
    preceding or containing point forward as well. The punctuation
    characters between the words do not move. When point is at the end
    of the line, it will transpose the word before point with the
    first word on the next line.

    A numeric argument to this command serves as a repeat count: it
    tells the transpose command to move the word before or containing
    point across several other words.

    A numeric argument of zero is assigned a special meaning: to
    transpose the word ending after point with the one ending after
    the mark.
*** transpose-sexps                                                    :edit:
    :PROPERTIES:
    :Command:  C-M-t
    :Description: Transpose two balanced expressions
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument to this command serves as a repeat count: it
    tells the transpose command to move the balanced expression before
    or containing point across several other balanced expressions.

    A numeric argument of zero is assigned a special meaning: to
    transpose the balanced expression ending after point with the one
    ending after the mark.
*** transpose-lines                                               :edit:line:
    :PROPERTIES:
    :Command:  C-x C-t
    :Description: Transpose two lines
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument to this command serves as a repeat count: it
    tells the transpose command to move the line before or containing
    point across several other lines.

    A numeric argument of zero is assigned a special meaning: to
    transpose the line ending after point with the one ending after
    the mark.
*** transpose-sentences                                                :edit:
    :PROPERTIES:
    :Description: Transpose two sentences
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument to this command serves as a repeat count: it
    tells the transpose command to move the sentence before or
    containing point across several other sentences.

    A numeric argument of zero is assigned a special meaning: to
    transpose the sentence ending after point with the one ending
    after the mark.
*** transpose-paragraphs                                               :edit:
    :PROPERTIES:
    :Description: Transpose two paragraphs
    :Context:  editing
    :Argument: numeric
    :END:
    A numeric argument to this command serves as a repeat count: it
    tells the transpose command to move the paragraph before or
    containing point across several other paragraphs.

    A numeric argument of zero is assigned a special meaning: to
    transpose the paragraphs ending after point with the one ending
    after the mark.
*** transpose-regions                                           :edit:region:
    :PROPERTIES:
    :Description: Transpose two regions
    :Context:  editing
    :Argument: numeric
    :END:
    This transposes the text between point and mark with the text
    between the last two marks pushed to the mark ring. With a numeric
    prefix argument, it transposes the text between point and mark
    with the text between two successive marks that many entries back
    in the mark ring. This command is best used for transposing
    multiple characters (or words or sentences or paragraphs) in one
    go.
*** downcase-word                                                 :edit:word:
    :PROPERTIES:
    :Command:  M-l
    :Description: Convert to lower case from point to end of word
    :Context:  editing
    :Argument: numeric
    :END:
    With negative argument, convert previous words but do not move.
*** upcase-word                                                   :edit:word:
    :PROPERTIES:
    :Command:  M-u
    :Description: Convert to upper case from point to end of word
    :Context:  editing
    :Argument: numeric
    :END:
    With negative argument, convert previous words but do not move.
*** capitalize-word                                               :edit:word:
    :PROPERTIES:
    :Command:  M-c
    :Description: Capitalize from point to end of word
    :Context:  editing
    :Argument: numeric
    :END:
    With numeric argument, capitalize the next /n/ words as well. With
    negative argument, capitalize previous words but do not move.
*** ispell-word                                                        :edit:
    :PROPERTIES:
    :Command:  M-$
    :Description: Check and correct spelling of word at point
    :Context:  editing
    :Argument: plain
    :END:
    If the region is active, check and correct the spelling for all
    words in the region instead.

    With a plain argument you can restart an interrupted interactive
    spell-checking.
*** ispell                                                             :edit:
    :PROPERTIES:
    :Command:  C-$
    :Description: Check and correct spelling of all words in buffer
    :END:
    If the region is active, check and correct spelling of all words
    in the region instead.
*** ispell-buffer                                                      :edit:
    :PROPERTIES:
    :Description: Check and correct spelling in the buffer
    :Context:  editing
    :END:
*** ispell-region                                                      :edit:
    :PROPERTIES:
    :Description: Check and correct spelling in the region
    :Context:  editing
    :END:
*** ispell-message                                                     :edit:
    :PROPERTIES:
    :Description: Check and correct spelling in a draft mail message
    :Context:  editing
    :END:
*** ispell-change-dictionary                                           :edit:
    :PROPERTIES:
    :Description:  Restart spell-checker process using given dict as dictionary
    :Context:  editing
    :END:
*** ispell-kill-ispell                                                 :undo:
    :PROPERTIES:
    :Description: Kill the spell-checker subprocess
    :Context:  ispell
    :END:
*** ispell-complete-word                                               :edit:
    :PROPERTIES:
    :Command:  M-TAB OR ESC TAB OR C-M-i
    :Description: Complete word before point based on spelling dictionary
    :Context:  editing
    :END:
*** flyspell-mode                                                   :display:
    :PROPERTIES:
    :Description: Enable Flyspell mode
    :Context:  navigating
    :END:
*** flyspell-prog-mode                                              :display:
    :PROPERTIES:
    :Description: Enable Flyspell mode for comments and strings only
    :Context:  navigating
    :END:
*** ISP Select Near-Miss                                               :edit:
    :PROPERTIES:
    :Command:  /digit/
    :Description: Replace word once with selected near-miss
    :Context:  ispell
    :END:
*** ISP Skip                                                            :nav:
    :PROPERTIES:
    :Command:  <SPC>
    :Description: Skip word, still incorrect
    :Context:  ispell
    :END:
*** ISP Replace Once                                                   :edit:
    :PROPERTIES:
    :Command:  r
    :Description: Replace word, once, with given string
    :END:
*** ISP Query Replace                                                  :edit:
    :PROPERTIES:
    :Command:  R
    :Description: Replace word with given replacement and do ~query-replace~
    :END:
*** ISP Accept Session                                               :inform:
    :PROPERTIES:
    :Command:  a
    :Description: Accept incorrect word only in this editing session
    :Context:  ispell
    :END:
*** ISP Accept Buffer                                         :inform:buffer:
    :PROPERTIES:
    :Command:  A
    :Description: Accept the incorrect word, but for session and buffer
    :Context:  ispell
    :END:
*** ISP Insert Dictionary                                            :inform:
    :PROPERTIES:
    :Command:  i
    :Description: Insert word in private dictionary file
    :Context:  ispell
    :END:
*** ISP Insert Completion                                            :inform:
    :PROPERTIES:
    :Command:  m
    :Description: like ~i~, but can specify dictionary completion
    :Context:  ispell
    :END:
*** ISP Insert Downcase                                              :inform:
    :PROPERTIES:
    :Command:  u
    :Description: Insert lower-case version of word in private dictionary
    :Context:  ispell
    :END:
*** ISP Look Dictionary                                              :inform:
    :PROPERTIES:
    :Command:  l
    :Description: Look in dictionary for word that matches given word
    :Context:  ispell
    :END:
    Words that match given word become the new list of near-misses;
    you can select one of them as the replacement by typing a
    digit. You can use '~*~' in given word as a wildcard.
*** ISP Exit Keep Point                                            :undo:nav:
    :PROPERTIES:
    :Command:  X
    :Description: Quit ispell, leaving point at last checked word
    :Context:  ispell
    :END:
*** ISP Exit Return Point                                          :undo:nav:
    :PROPERTIES:
    :Command:  x
    :Description: Quit ispell, move point back to before ispell
    :Context:  ispell
    :END:
*** ISP Quit Ispell                                                    :undo:
    :PROPERTIES:
    :Command:  q
    :Description: Quit ispell and kill subprocess
    :Context:  ispell
    :END:
*** ISP Help                                                          :helps:
    :PROPERTIES:
    :Command:  ?
    :Description: Show the list of options
    :Context:  ispell
    :END:
*** flyspell-region                                          :inform:display:
    :PROPERTIES:
    :Description: Apply Flyspell to region
    :Context:  navigating
    :END:
*** flyspell-buffer                                          :inform:display:
    :PROPERTIES:
    :Description: Apply Flyspell to buffer
    :Context:  navigating
    :END:
*** flyspell-correct-word                              :edit:inform:complete:
    :PROPERTIES:
    :Command:  <mouse-2>
    :Description: When clicked on Flyspell misspell, list corrections
    :Context:  editing
    :END:
*** flyspell-auto-correct-word                                         :edit:
    :PROPERTIES:
    :Command:  C-. OR ESC TAB
    :Description: Propose various successive corrections for word at point
    :Context:  editing
    :END:
*** flyspell-correct-word-before-point                                 :edit:
    :PROPERTIES:
    :Command:  C-c $
    :Description: Pop up a menu of possible flyspell corrections
    :Context:  editing
    :END:
** Keyboard Macros
*** kmacro-start-macro-or-insert-counter                              :macro:
    :PROPERTIES:
    :Command:  <F3>
    :Description: Start defining a keyboard macro
    :Context:  editing
    :Argument: plain, double
    :END:
    With plain argument re-execute last keyboard macro, then append
    keys to its definition.

    With double argument append keys to the last keyboard macro
    without re-executing it.
*** kmacro-end-or-call-macro                                          :macro:
    :PROPERTIES:
    :Command:  <F4>
    :Description: End macro definition or execute most recent macro
    :Context:  editing
    :Argument: numeric
    :END:
    You can also supply this command with a numeric prefix argument
    /n/, which means to invoke the macro /n/ times. An argument of
    zero repeats the macro indefinitely, until it gets an error or you
    type ~C-g~.
*** apply-macro-to-region-lines                                :macro:region:
    :PROPERTIES:
    :Command:  C-x C-k r
    :Description: Run last macro on each line that is in region
    :Context:  editing
    :END:
    This command repeats the last defined keyboard macro on each line
    that begins in the region. It does this line by line, by moving
    point to the beginning of the line and then executing the macro.
*** kmacro-start-macro                                                :macro:
    :PROPERTIES:
    :Command:  C-x (
    :Description: Start defining macro (old style)
    :Context:  editing
    :Argument: plain
    :END:
    With a prefix argument, append keys to the last macro
*** kmacro-end-macro                                                  :macro:
    :PROPERTIES:
    :Command:  C-x )
    :Description: End macro definition (old style)
    :Context:  editing
    :Argument: numeric
    :END:
    Prefix argument serves as the repeat count for executing the
    macro. The macro definition itself counts as the first repetition,
    since it is executed as you define it, so ~C-u 4 C-x )~ executes
    the macro immediately 3 additional times.
*** kmacro-end-and-call-macro                                         :macro:
    :PROPERTIES:
    :Command:  C-x e
    :Description: Execute most recent macro
    :Context:  editing
    :Argument: numeric
    :END:
    Prefix argument serves as repeat count.
* Variables
** The Organization of the Screen
*** tty-menu-open-use-ttm                                              :menu:
    when invoking ~menu-bar-open~ invoke ~tmm-menubar~ instead.
** Entering Emacs
*** inhibit-startup-screen                                   :startup:buffer:
    If one or more files were specified on the command line, Emacs
    simply displays those files; otherwise, it displays a buffer named
    ~*scratch*~, which can be used to evaluate Emacs Lisp expressions
    interactively.
*** initial-buffer-choice                                    :startup:buffer:
    Force Emacs to display a file or directory at startup, according
    to filename, directory, or zero (0) argument Lisp Function that
    returns a buffer.
** Exiting Emacs
*** confirm-kill-emacs                                           :kill:frame:
    function to run before killing Emacs. If result of function is
    non-nil, the session is killed, otherwise Emacs continues to run.
*** confirm-kill-processes                                             :kill:
    If nil, does not ask for confirmation before killing sub-processes
    started by Emacs. ~t~ by default.
** Basic Editing Commands
*** read-quoted-char-radix                                        :edit:char:
    To use decimal or hexadecimal when running ~quoted-insert~
    command.
*** line-move-visual                                             :nav:window:
    You can force navigating up and down by line to move according to
    logical lines (i.e., according to the text lines in the buffer) by
    setting this variable to ~nil~.
*** track-eol                                                    :nav:buffer:
    When ~line-move-visual~ is nil, you can set this variable to a
    non-nil value. Then ~C-n~ and ~C-p~, when starting at the end of
    the logical line, move to the end of the next logical
    line. Default is ~nil~.
*** next-line-add-newlines                                  :nav:edit:buffer:
    If you set this variable to a non-nil value, C-n on the last line
    of a buffer creates an additional line at the end and moves down
    into it.
** The Minibuffer
*** minibuffer-eldef-shorten-default                    :buffer:display:echo:
    with a non-nil value, the default argument is displayed as
    ~[default-arg]~ instead of ~(default /default-arg/)~, saving some
    screen space.
*** insert-default-directory                            :buffer:display:echo:
    To prevent Emacs from inserting the default directory when reading
    file names, change this variable to ~nil~. Relative file name
    arguments are still interpreted based on the same default
    directory.
*** resize-mini-windows                                 :buffer:display:echo:
    There are three possible values
    - nil :: Do not resize minibuffer in Echo Area.
    - grow-only :: Grow minibuffer when there is enough text to be
      displayed on a new line. Do not ever shrink minibuffer
    - t :: Grow minibuffer when there is enough text to be displayed
      on a new line. Shrink when text can be displayed on fewer lines
*** max-mini-window-height                              :buffer:display:echo:
    This variable controls the maximum height for resizing the
    minibuffer window. A floating-point number specifies a fraction of
    the frame's height; an integer specifies the maximum number of
    lines; ~nil~ means do not resize the minibuffer window
    automatically. The default value is ~0.25~.
*** enable-recursive-minibuffers                        :buffer:command:echo:
    Emacs normally disallows most commands that use the minibuffer
    while the minibuffer is active. To allow such commands in the
    minibuffer, set this variable to ~t~.
*** confirm-nonexistent-file-or-buffer                  :buffer:command:echo:
    Changes behavior of "Permissive Completion with Confirmation"
    described in [[Completion Exit]]. Three possible values.
    - ~after-completion~ :: Default value. Behaves exactly as
      described in linked section.
    - ~nil~ :: No longer asks for confirmation. Same behavior as
      "Permissive Completion"
    - [other] :: Always asks for confirmation.
*** completion-styles                                         :list:complete:
    See current list and list options defined in:
    [[How Completion Alternatives Are Chosen]]
*** read-file-name-completion-ignore-case        :files:complete:buffer:echo:
    When completing file names, case differences are ignored if this
    variable is non-nil. The default value is nil on systems that have
    case-sensitive file-names, such as GNU/Linux; it is non-nil on
    systems that have case-insensitive file-names, such as Microsoft
    Windows.
*** read-buffer-completion-ignore-case                 :buffer:complete:echo:
    When completing buffer names, case differences are ignored if this
    variable is non-nil; the default is nil.
*** completion-ignored-extensions           :files:complete:list:buffer:echo:
    When completing file names, Emacs usually omits certain
    alternatives that are considered unlikely to be chosen, as
    determined by the values on this list variable. If /all/ possible
    completions end in otherwise-ignored strings, they are not
    ignored. Emacs disregards this variable when showing completion
    alternatives in the completion list.
*** completion-auto-help                  :complete:inform:helps:buffer:echo:
    If this variable is set to ~nil~, the completion commands never
    display the completion list buffer; you must type ~?~ to display
    the list. If the value is ~lazy~, Emacs only shows the completion
    list buffer on the second attempt to complete. In other words, if
    there is nothing to complete, the first <TAB> echos 'Next char not
    unique'; the second <TAB> shows the completion list buffer.
*** completion-cycle-threshold            :complete:inform:helps:buffer:echo:
    If this variable is non-nil, completion commands can cycle through
    completion alternatives. Normally when the variable is ~nil~, if
    there is more than one completion alternative for the text in the
    minibuffer, a completion command completes up to the longest
    common sub-string. If you change this variable to ~t~, the
    completion command instead completes to the first of those
    completion alternatives; each subsequent invocation of the
    completion command replaces that with the next completion
    alternative, in a cyclic manner. If you give this variable a
    number value /n/, completion commands switch to this cycling
    behavior only when there are /n/ or fewer alternatives.
*** history-length                                         :buffer:hist:echo:
    This variable specifies the maximum length of a minibuffer history
    list; adding a new element deletes the oldest element if the list
    gets too long. If the value is ~t~, there is no maximum length.
*** history-delete-duplicates                                          :hist:
    This variable specifies whether to delete duplicates in
    history. If it is non-nil, adding a new element deletes from the
    list all other elements that are equal to it. The default is
    ~nil~.
*** isearch-resume-in-command-history                          :command:hist:
    You can make incremental search commands appear in the history by
    setting this variable to a non-nil value.
*** command-history                                       :command:hist:list:
    The list of previous minibuffer-using commands is stored as a Lisp
    list in this variable.
** Running Commands by Name
*** suggest-key-bindings                                :inform:command:keys:
    When the command you run with ~M-x~ has a key binding, Emacs
    mentions this in the echo area after running the command. You can
    turn off these messages by setting this variable to ~nil~. The
    value can also be a number, in which case Emacs will show the
    binding for that many seconds before removing it from display. The
    default value is ~2~.
*** extended-command-suggest-shorter                         :inform:command:
    Commands that don't have key bindings can still be invoked after
    typing less than their full name at the ~M-x~ prompt. Emacs
    mentions such shorthands in the echo area if they are
    significantly shorter than the full command name, and this
    variable is non-nil. These suggestions won't get shown at all if
    [[suggest-key-bindings]] is ~nil~.
** Help
*** apropos-do-all                                           :search:command:
    If this variable is non-nil, most apropos commands behave as if
    they had been given a prefix argument. There is one exception:
    ~apropos-variable~ without a prefix argument will always search
    for all variables, no matter what the value of this variable is.
*** apropos-sort-by-scores                                   :search:display:
    If this variable is non-nil, apropos commands try to guess the
    relevance of each result, and display the most relevant ones
    first. This variable does not affect how ~apropos-documentation~
    is sorted.
*** apropos-documentation-sort-by-scores                     :search:display:
    To list the results of ~apropos-documentation~ in alphabetical
    order, change this variable to nil.
*** help-at-pt-display-when-idle                   :word:inform:display:echo:
    To display help text automatically whenever it is available at
    point, set this variable to t.
** The Mark and the Region
*** highlight-nonselected-windows                     :display:region:window:
    Ordinarily, only the selected window highlights its region;
    however, if this variable is non-nil, each window highlights its
    own region.
*** use-empty-active-region                                  :region:command:
    If you want region specific commands to operate on the empty
    region, change this variable to ~t~.
*** delete-active-region                            :region:edit:delete:kill:
    If you change this variable to ~nil~, then ~<DEL>~ and ~<Delete>~
    don't act differently when the mark is active. If you change the
    value to ~kill~, these commands kill the region instead of
    deleting it.
*** mark-even-if-inactive                                    :region:command:
    By default, if the mark is inactive, region only commands operate
    on the inactive region - that is, on the text between point and
    the position at which the mark was last set. To disable this
    behavior, change this variable to ~nil~. Then these commands will
    instead signal an error if the mark is inactive.
*** set-mark-command-repeat-pop                        :nav:region:keys:hist:
    If you set this variable to non-nil, then immediately after you
    type ~C-u C-<SPC>~, you can type ~C-<SPC>~ instead of
    ~C-u C-<SPC>~ to cycle through the mark ring. By default,
    ~set-mark-command-repeat-pop~ is ~nil~.
*** mark-ring-max                                               :region:hist:
    This variable specifies the maximum number of entries to keep in
    the mark ring. This defaults to 16 entries. If that many entries
    exist and another one is pushed, the earliest one in the list is
    discarded. Repeating ~C-u C-<SPC>~ cycles through the positions
    currently in the ring.
*** global-mark-ring-max                                        :region:hist:
    The length of the global mark ring is controlled by this variable,
    and is 16 by default.
*** shift-select-mode                                       :nav:region:mode:
    Variable determining whether or not Shift Select mode is active/on
    or not. To turn off set this variable to ~nil~.
** Killing and Moving Text
*** kill-whole-line                                        :kill:delete:line:
    If this variable is non-nil, ~C-k~ at the very beginning of a line
    kills the entire line including the following newline. The
    variable is normally ~nil~.
*** kill-read-only-ok                                                  :kill:
    Normally, using a kill command in a read only buffer causes Emacs
    to beep and display an error message, but if you set this variable
    to a non-nil value, they just print a message in the echo area to
    explain why the text has not been erased.
*** kill-do-not-save-duplicates                                   :kill:hist:
    If you change this variable to a non-nil value, identical
    subsequent kills yield a single kill-ring entry, without
    duplication.
*** kill-ring-max                                                 :kill:hist:
    The maximum number of entries in the kill ring is controlled by
    this variable. The default is 60.
*** kill-ring                                                     :kill:hist:
    The actual contents of the kill ring are stored in this variable.
*** x-select-request-type                                       :kill:coding:
    You can request a different data type to copy to clipboard by
    customizing this variable
*** save-interprogram-paste-before-kill                           :kill:hist:
    Optionally, you can change this variable to ~t~. Then Emacs will
    first save the clipboard to its kill ring before using a kill
    command, preventing you from losing the old clipboard data - at
    the risk of high memory consumption if that data turns out to be
    large.
*** yank-pop-change-selection                                     :kill:hist:
    Normally rotating the kill ring with ~M-y~ (~yank-pop~) does not
    alter the clipboard. However, if you change this variable to ~t~,
    then ~M-y~ saves the new yank to the clipboard.
*** select-enable-clipboard                                            :kill:
    To prevent kill and yank commands from accessing the clipboard,
    change this variable to ~nil~.
*** x-select-enable-clipboard-manager                                  :kill:
    If you exit Emacs while it is the current "owner" of the clipboard
    data, and there is a clipboard manager running, Emacs transfers
    the clipboard data to the clipboard manager so that it is not
    lost. In some circumstances, this may cause a delay when exiting
    Emacs; if you wish to prevent Emacs from transferring data to the
    clipboard manager, change this variable to ~nil~.
*** select-enable-clipboard                                            :kill:
    Non-nil means cutting and pasting uses the clipboard. This can be
    in addition to, but in preference to, the primary selection, if
    applicable.
*** select-enable-primary                                              :kill:
    Non-nil means cutting and pasting uses the primary selection. The
    existence of a primary selection depends on the underlying GUI you
    use. E.g. it doesn't exist under MS-Windows.
*** mouse-drag-copy-region                                      :kill:region:
    If non-nil, copy to kill-ring upon mouse adjustments of the
    region.
*** select-active-regions                                            :region:
    If you change this variable to ~only~, Emacs saves only temporarily
    active regions to the primary selection, i.e., those made with the
    mouse or with shift selection. If you change this variable to
    ~nil~, Emacs avoids saving active regions to the primary selection
    entirely.
*** mouse-yank-at-point                                                :edit:
    If this variable is non-nil, ~M-mouse-2~ yanks at point. Then it
    does not matter precisely where you click, or even which of the
    frame's windows you click on.
*** cua-enable-cua-keys                          :region:display:edit:delete:
    To disable the overriding of standard Emacs binding by CUA mode,
    while retaining the other features of CUA mode described in the
    mode, set this variable to ~nil~.
*** cua-delete-selection                                      :delete:region:
    To use CUA mode without activating Delete-Selection mode set this
    variable to ~nil~.
** Registers
*** register-preview-delay                     :register:command:echo:window:
    All commands that prompt for a register will display a preview
    window that lists the existing registers (if there are any) after
    a short delay. To change the length of the delay, customize this
    variable. To prevent this display, set this variable to ~nil~.
*** register-separator                                             :register:
    This variable stores which register should be considered the
    ~register-separator~ register and then will use the contents of
    this register to put in between text inserted into any other
    register using the commands either ~append-to-register~ or
    ~prepend-to-register~. By default the register ~+~ is used.

    When this variable is set to ~nil~ no extra text will be put in
    between text when using the previously mentioned commands.
*** bookmark-save-flag                                     :files:nav:buffer:
    If you set this variable to ~1~, each command that sets a bookmark
    will also save your bookmarks; this way, you don't lose any
    bookmark values even if Emacs crashes. The value, if a number,
    says how many bookmark modifications should go by between
    saving. If you set this variable to ~nil~, Emacs only saves
    bookmarks if you explicitly use ~bookmark-save~. Default value is
    ~t~ which means bookmarks save when Emacs is killed.
*** bookmark-default-file                                  :files:nav:buffer:
    The value of this variable specifies the file in which to save
    bookmarks by default.
*** bookmark-search-size                                    :buffer:hist:nav:
    This variable says how many characters of context to record on
    each side of the bookmark's position.
** Controlling the Display
*** next-screen-context-lines                                   :display:nav:
    The number of lines of overlap left by the commands
    ~scroll-up-command~ and ~scroll-down-command~ is controlled by
    this variable, whose default value is 2.
*** scroll-error-top-bottom                                     :display:nav:
    By default, the commands ~scroll-up-command~ and
    ~scroll-down-command~ signal an error (by beeping or flashing the
    screen) if no more scrolling is possible, because the window has
    reached the beginning or end of the buffer. If you change this
    variable to ~t~, these commands move point to the farthest
    possible position. If point is already there, the commands signal
    an error.
*** scroll-preserve-screen-position                             :display:nav:
    If the value is ~t~, Emacs adjusts point to keep the cursor at the
    same screen position whenever a scroll command moves it
    off-window, rather than moving it to the topmost or bottom-most
    line. With any other non-nil value, emacs adjusts point this way
    even if the scroll command leaves point in the window. This
    variable affects all scroll commands in the section named
    [[Controlling the Display]], as well as scrolling with the mouse
    wheel; in general, it affects any command that has a non-nil
    ~scroll-command~ property.
*** recenter-positions                      :list:window:display:nav:command:
    You can change the cycling order of the command
    ~recenter-top-bottom~ by customizing this list variable. Each list
    element should be the symbol ~top~, ~middle~, or ~bottom~, or a
    number; an integer means to move the line to the specified screen
    line, while a floating point number between 0.0 and 1.0 specifies
    a percentage of the screen space from the top of the window. The
    default, ~(middle top bottom)~, is the cycling order described in
    the documentation of ~recenter-top-bottom~.
*** scroll-margin                                        :window:display:nav:
    If you change this variable to a non-zero value /n/, then
    ~recenter-top-bottom~ always leaves at least /n/ screen lines
    between point and the top or bottom of the window.
*** recenter-redisplay                                       :display:window:
    If this variable has a non-nil value, each invocation of
    ~recenter-top-bottom~ also clears and redisplays the screen; The
    special value ~tty~ (the default) says to do this on text-terminal
    frames only.
*** scroll-conservatively                                    :display:window:
    If you set this variable to a small number /n/, then moving point
    just a little off screen (no more than /n/ lines) causes Emacs to
    scroll just enough to bring point back on screen; If doing so
    fails to make point visible, Emacs scrolls just far enough to
    center point in the window. If you set this variable to a large
    number (larger than 100), automatic scrolling never centers point,
    no matter how far point moves; Emacs always scrolls text just
    enough to bring point into view, either at the top or bottom of
    the window depending on the scroll direction. By default, the
    variable is 0, which means to always center point in the window.
*** scroll-step                                              :display:window:
    The value of this valuable determines the number of lines by which
    to automatically scroll, when point moves off the screen. If
    scrolling by that number of lines fails to bring point back into
    view, point is centered instead. The default value is zero, which
    (by default) causes point to always be centered after scrolling.
*** scroll-up-aggressively                                   :display:window:
    This variable directly specifies the vertical position of point
    after scrolling. The value of this variable should be either ~nil~
    (the default), or a floating point number /f/ between 0 and 1. The
    latter means that when point goes below the bottom window edge
    (i.e., scrolling forward), Emacs scrolls the window so that point
    is /f/ parts of the window height from the bottom window
    edge. Thus, larger /f/ means more aggressive scrolling: more new
    text is brought into view. The default value, ~nil~, is equivalent
    to 0.5.
*** scroll-down-aggressively                                 :display:window:
    This variable directly specifies the vertical position of point
    after scrolling. The value of this variable should be either ~nil~
    (the default), or a floating point number /f/ between 0 and 1. The
    latter means that when point goes above the top window edge (i.e.,
    scrolling backward), Emacs scrolls the window so that point is /f/
    parts of the window height from the top window edge. This, larger
    /f/ means more aggressive scrolling: more new text is brought into
    view. The default value, ~nil~, is equivalent to 0.5.
*** scroll-margin                                            :display:window:
    This variable restricts how close point can come to the top of
    bottom of a window (even if aggressive scrolling specifies a
    fraction /f/ that is larger than the window portion between the
    top and bottom margins). It's value is a number of screen lines;
    If point comes within that many lines of the top or bottom of the
    window, Emacs performs automatic scrolling. By default, this
    variable is 0. The effective margin size is limited to a quarter
    of the window height by default.
*** maximum-scroll-margin                                    :display:window:
    The effective margin size is limited to a quarter of the window
    height by default, but this limit can be increased up to half (or
    decreased down to zero) by customizing this variable.
*** auto-hscroll-mode                                        :display:window:
    By default, all the lines in the window are scrolled horizontally
    together, but if you set this variable to the special value of
    ~current-line~, only the line showing the cursor will be
    scrolled. To disable automatic horizontal scrolling entirely, set
    this variable to ~nil~. Note that when the automatic horizontal
    scrolling is turned off, if point moves off the edge of the
    screen, the cursor disappears to indicate that. (On text
    terminals, the cursor is left at the edge instead.)
*** hscroll-margin                                           :display:window:
    This variable controlls how close point can get to the window's
    left and right edges before automatic scrolling occurs. It is
    measured in columns. For example, if the value is 5, then moving
    point within 5 columns of an edge causes horizontal scrolling away
    from that edge.
*** hscroll-step                                             :display:window:
    This variable determines how many columns to scroll the window
    when point gets too close to the edge. Zero, the default value,
    means to center point horizontally within the window. A positive
    integer value specifies the number of columns to scroll by. A
    floating-point number (whose value should be between 0 and 1)
    specifies the fraction of the window's width to scroll by.
*** frame-background-mode                                      :display:char:
    By default, Emacs automatically chooses which set of face
    attributes to display on each frame, based on the frame's current
    background color. However you can override this by giving this
    variable a non-nil value. A value of ~dark~ makes Emacs treat all
    frames as if they have a dark background, whereas a value of
    ~light~ makes it treat all frames as if they have a light
    background.
*** list-colors-sort                                   :display:helps:window:
    To control the order in which colors are shown with the command
    ~list-colors-display~, customize this variable.
*** text-scale-mode-step                                            :display:
    Each call to ~text-scale-adjust~ scales the text height by a
    factor of 1.2; to change this factor, customize this variable.
*** global-font-lock-mode                       :buffer:display:mode:startup:
    To impose the setting where Font Lock mode is either enabled or
    disabled in all buffers for future Emacs sessions, customize this
    variable.
*** font-lock-maximum-decoration                               :display:mode:
    You can customize this variable to alter the amount of
    fontification applied by Font Lock mode, for major modes that
    support this feature, the value should be a number (with 1
    representing a minimal amount of fontification; some modes support
    levels as high as 3); or ~t~, meaning "as high as possible" (the
    default). To be effective for a given file buffer, the
    customization of the variable ~font-lock-maximum-decoration~
    should be done /before/ the file is visited; if you already have a
    file visited in a buffer when you customize this variable, kill
    the buffer and visit the file again after the customization.

    You can also specify different numbers for particular major modes;
    for example, to use level 1 for C/C++ modes, and the default level
    otherwise, use the value ~'((c-mode . 1) (c++-mode . 1))~
*** hi-lock-auto-select-face                           :echo:command:display:
    Setting this variable to a non-nil value causes the command
    ~highlight-regexp~ (and other Hi Lock commands that read faces) to
    automatically choose the next face from the default list without
    prompting.
*** fringe-mode                                   :window:frame:mode:display:
    You can make your changes to the fringes permanent by customizing
    this variable. Such as setting the width of the fringes.
*** overflow-newline-into-fringe                             :display:window:
    By default set to a non nil value. This means if the current line
    is exactly as wide as the window and point is at the end of the
    line then the fringe will draw the cursor. To disable this, change
    this variable to ~nil~; this causes Emacs to continue or truncate
    lines that are exactly as wide as the window.
*** display-fill-column-indicator                     :display:window:buffer:
    This is a buffer-local variable used to activate the fill column
    indicator.
*** display-fill-column-indicator-character      :display:window:buffer:char:
    This is a buffer-local variable used to control how the fill
    column indicator looks.
*** display-fill-column-indicator-column              :display:window:buffer:
    Specifies the column number where the indicator should be set. It
    can take positive numerical values for the column or the special
    value ~t~ which means that the variable ~fill-column~ will be
    used.

    Any other value disables the indicator. The default value is ~t~.
*** indicate-buffer-boundaries                                :display:frame:
    This is a buffer-local variable that controls how the buffer
    boundaries and window scrolling is indicated in the fringes. If
    the value is ~left~ or ~right~, both angle and arrow bitmaps are
    displayed in the left or right fringe, respectively.

    If value is an alist, each element ~(/indicator/ . /position/)~
    specifies the position of one of the indicators. The /indicator/
    must be one of ~top~, ~bottom~, ~up~, ~down~, or ~t~ which
    specifies the default position for the indicators not present in
    the alist. The /position/ is one of ~left~, ~right~, or ~nil~
    which specifies not to show this indicator.

    For example, ~((top . left) (t . right))~ places the top angle
    bitmap in left fringe, the bottom angle bitmap in right fringe,
    and both arrow bitmaps in right fringe. To show just the angle
    bitmaps in the left fringe, but no arrow bitmaps, use ~((top
    . left) (bottom . left))~.
*** show-trailing-whitespace                                        :display:
    You can make trailing whitespace at the end of a line visible by
    setting this buffer-local variable to ~t~.

    This feature does not apply when point is at the end of the line
    containing the whitespace. Strictly speaking, that is trailing
    whitespace nonetheless, but displaying it specially in that case
    looks ugly while you are typing in new text. In this special case,
    the location of point is enough to show you that the spaces are
    present.
*** delete-trailing-lines                               :edit:command:buffer:
    Normally when using the command ~delete-trailing-whitespace~ the
    command deletes all extra space at the end of each line in the
    buffer, and all empty lines at the end of the buffer; to ignore
    the latter, change this variable to ~nil~.
*** indicate-empty-lines                              :display:window:buffer:
    On graphical displays, Emacs can indicate unused lines at the end
    of the window with a small image in the left fringe. The image
    appears for screen lines that do not correspond to any buffer
    text, so blank lines at the end of the buffer stand out because
    they lack this image. To enable this feature, set this
    buffer-local variable to a non-nil value.
*** whitespace-style                                    :display:buffer:list:
    When Whitespace mode is enabled, the kinds of whitespace
    visualized are determined by this list variable.
*** whitespace-line-column                                   :display:buffer:
    When highlighting ~lines~ in Whitespace mode, customize this
    variable to change the column limit that determines which lines to
    highlight.
*** whitespace-big-indent-regexp                             :display:buffer:
    When highlighting ~big-indent~ customize this regular expression
    to change when to highlight a big indent at the start of a line.
*** selective-display-ellipses                          :display:buffer:line:
    If you set this variable to ~nil~, when you have hidden lines
    using the command ~set-selective-display~, then the three dots do
    not appear at the end of a line that precedes hidden lines. There
    is no visible indication of the hidden lines. This variable
    becomes local automatically when set.
*** column-number-indicator-zero-based                       :display:inform:
    When Column Number mode is enabled, if you would prefer for the
    displayed column number to count from one, you may set this
    variable to ~nil~.
*** line-number-display-limit                           :line:display:inform:
    When the number of characters in a file is larger than the integer
    in this variable the mode line stops trying to compute the line
    number in a file. To remove this limit, set this variable to
    ~nil~.
*** line-number-display-limit-width                     :line:display:inform:
    Line-number computation can also be slow if the lines in the
    buffer are too long. For this reason, Emacs doesn't display line
    numbers if the average width, in characters, of lines near point
    is larger than the value of this variable. The default value is
    200 characters.
*** display-time-24hr-format                                 :display:inform:
    If you have Display Time mode enabled and what the time to appear
    in 24 hour mode, set this variable to ~t~.
*** display-time-use-mail-icon                               :display:inform:
    If you have Display Time mode enabled, and you want the mail
    indicator to be an icon instead of the word '~Mail~', then you can
    customize this variable
*** display-time-mail-file                             :display:inform:files:
    Use this variable to specify the mail file to check when Display
    Time mode is enabled.
*** display-time-mail-directory                        :display:inform:files:
    Use this variable to specify the directory to check for incoming
    mail (any nonempty regular file in the directory is considered to
    be newly arrived mail).
*** display-battery-mode                                :display:inform:mode:
    Set whether Display Battery mode is enabled or not using this
    mode.
*** battery-mode-line-format                                 :display:inform:
    This variable determines the way the battery charge is displayed;
    the exact mode-line message depends on the operating system, and
    it usually shows the current battery charge as a percentage of the
    total charge.
*** mode-line-in-non-selected-windows                               :display:
    You can disable use of the ~mode-line-inactive~ face by setting
    this variable to ~nil~; then all mode lines are displayed in the
    ~mode-line~ face.
*** eol-mnemonic-unix                                          :display:char:
    This variable determines what character is used to indicate in the
    mode line whether the current file uses a unix style end of line
    encoding.
*** eol-mnemonic-mac                                           :display:char:
    This variable determines what character is used to indicate in the
    mode line whether the current file uses a mac style end of line
    encoding.
*** eol-mnemonic-undecided                                     :display:char:
    This variable determines what character is used to indicate in the
    mode line whether the current file uses a undecided style end of
    line encoding.
*** tab-width                                                  :display:char:
    The number of spaces per tab is controlled by this buffer-local
    variable, which must have an integer value between 1 and 1000,
    inclusive.
*** ctl-arrow                                           :display:char:coding:
    If you change this buffer-local variable to ~nil~, the ASCII
    control characters are also displayed as octal escape sequences
    instead of caret escape sequences.
*** nobreak-char-display                                :display:char:coding:
    By default Emacs will make it so that any character that looks
    like an ordinary ASCII space or hyphen, but is not coded as such
    is assigned a special face (~nobreak-space~ and ~nobreak-hyphen~
    respectively). To disable this, change this variable to ~nil~. If
    you give this variable a non-nil, and non-t value, Emacs instead
    displays such characters as a highlighted backslash followed by a
    space or hyphen.
*** glyphless-char-display-control                      :display:char:coding:
    Glyphless characters are normally displayed as boxes containing
    the hexadecimal character code or, on text terminals as question
    signs. You can control the display method by customizing this
    variable.
*** text-quoting-style                                         :display:char:
    Normally, if Emacs can display the curved quotes '~‘~' and '~’~'
    then it will translate the ASCII quotes ('~`~' and '~'~'), when
    they appear in messages and help texts, to these curved
    quotes. You can influence or inhibit this translation by
    customizing this variable.
*** visible-cursor                                              :display:nav:
    By default, Emacs uses the very visible cursor when it Emacs is
    being run via a text terminal. If this variable is ~nil~ when
    Emacs starts or resumes, then it uses the normal cursor.
*** cursor-type                                                 :display:nav:
    To change the shape of the cursor in graphical displays, customize
    this buffer-local variable; possible values are:
    - ~box~ :: (the default)
    - ~hollow~ :: a hollow box
    - ~bar~ :: a vertical bar
    - ~(bar . n)~ :: a vertical bar /n/ pixels wide
    - ~hbar~ :: a horizontal bar
    - ~(hbar . n)~ :: a horizontal bar /n/ pixels tall
    - ~nil~ :: no cursor at all
*** blink-cursor-blinks                                         :display:nav:
    By default, the cursor stops blinking after 10 blinks. You can
    customize this variable to control that: its value says how many
    times to blink without input before stopping. Setting that
    variable to a zero or negative value will make the cursor blink
    forever.
*** blink-cursor-mode                                           :display:nav:
    To disable cursor blinking altogether, change this variable to
    ~nil~.
*** blink-cursor-alist                                     :display:nav:list:
    You can change how the cursor looks when it blinks off by
    customizing this list variable. Each element in the list should
    have the form ~(on-type . off-type)~; this means that if the
    cursor is displayed as /on-type/ when it blinks on (where
    /on-type/ is one of the cursor types described in ~cursor-type~),
    then it is displayed as /off-type/ when it blinks off.
*** x-stretch-cursor                                            :display:nav:
    Some characters, such as tab characters, are extra wide. When the
    cursor is positioned over such a character, it is normally drawn
    with the default character width. You can make the cursor stretch
    to cover wide characters, by changing this variable to a non-nil
    value.
*** cursor-in-non-selected-windows                            :display:frame:
    To turn off cursors in non-selected windows, change this variable
    to ~nil~.
*** truncate-lines                                             :display:line:
    If this variable is non-nil, long lines are truncated; if it is
    ~nil~, they are continued onto multiple screen lines. Setting this
    variable in any way makes it local to the current buffer; until
    that time, the default value, which is normally ~nil~, is in
    effect.
*** visual-line-fringe-indicators                       :display:mode:window:
    When Visual Line mode is enabled, by default, word-wrapped lines
    do not display fringe indicators. You can change this by
    customizing this variable
*** display-line-numbers                         :display:buffer:window:line:
    If you want to have Emacs display line numbers for every line in
    the buffer, customize this buffer-local variable; it is ~nil~ by
    default. This variable can have several different values to
    support various modes of line-number display:
    - ~t~ :: Display (an absolute) line number before each
      non-continuation screen line that displays buffer text. If the
      line is a continuation line, or if the entire screen line
      displays a display or an overlay string, that line will not be
      numbered.
    - ~relative~ :: Display relative line numbers before
      non-continuation lines which show buffer text. The line numbers
      are relative to the line showing point, so the numbers grow both
      up and down as lines become farther from the current line
    - ~visual~ :: This value causes Emacs to count lines visually: only
      lines actually shown on the display will be counted
      (disregarding any lines in invisible parts of text), and lines
      which wrap to consume more than one screen line will be numbered
      that many times. The displayed numbers are relative, as with
      ~relative~ value above. This is handy in modes that fold text,
      such as outline mode, and when you need to move by exact number
      of screen lines.
    - anything else :: Any other non-nil value is treated as ~t~.
*** display-line-numbers-type               :display:buffer:window:mode:line:
    This variable controls which sub-mode of line-number display will
    be active when you turn on Display Line Numbers mode. See that
    section of the document for details
*** display-line-numbers-current-absolute        :display:buffer:window:line:
    Either when ~display-line-numbers~ is set to ~relative~ or when
    ~display-line-numbers-type~ is set to ~relative~ and Display Line
    Numbers mode is turned on for the buffer in question. This
    variable controls what line number is displayed for the current
    line, the line showing point. By default, Emacs displays the
    absolute number of the current line there, even though all the
    other line numbers are relative. If you set this variable to a
    ~nil~ value, the number displayed for the current line will be
    zero.
*** display-line-numbers-widen                   :display:buffer:window:line:
    In a narrowed buffer, if line numbers are being displayed
    absolutely, lines are normally numbered starting at the beginning
    of the narrowing. However, if you customize this variable to a
    non-nil value, line numbers will disregard any narrowing and will
    start at the first character of the buffer.
*** display-line-numbers-offset                  :display:buffer:window:line:
    If the value of this variable is non-zero, it is added to each
    absolute line number, and lines are counted from the beginning of
    the buffer, as if ~display-line-numbers-widen~ were non-nil. It
    has no effect when set to zero, or when line numbers are not
    absolute.
*** display-line-numbers-width-start             :display:window:buffer:line:
    If non-nil, count number of lines to use for line number width.

    If ~nil~ when ~display-line-numbers-mode~ is turned on,
    ‘display-line-numbers-width’ is set to the minimum width necessary
    to display all line numbers in the buffer.
*** display-line-numbers-grow-only               :display:window:buffer:line:
    If non-nil, do not shrink line number width.
*** display-line-numbers-width                   :display:window:buffer:line:
    Minimum width of space reserved for line number display. A
    positive number means reserve that many columns for line numbers,
    even if the actual number needs less space. The default value of
    nil means compute the space dynamically. Any other value is
    treated as nil.
*** display-line-numbers-major-tick              :display:window:buffer:line:
    If an integer N > 0, highlight line number of every Nth line. The
    line number is shown with the ~line-number-major-tick~
    face. Otherwise, no special highlighting is done every Nth
    line. Note that major ticks take precedence over minor ticks.
*** display-line-numbers-minor-tick              :display:window:buffer:line:
    If an integer N > 0, highlight line number of every Nth line. The
    line number is shown with the ~line-number-minor-tick~
    face. Otherwise, no special highlighting is done every Nth
    line. Note that major ticks take precedence over minor ticks.
*** visible-bell                                             :display:window:
    If this variable is non-nil, Emacs attempts to make the whole
    screen blink when it would normally make an audible bell
    sound. This variable has no effect if your terminal does not have
    a way to make the screen blink.
*** echo-keystrokes                                       :keys:echo:display:
    This variable controls the echoing of multi-character keys; its
    value is the number of seconds of pause required to cause echoing
    to start, or zero, meaning don't echo at all. The value takes
    effect when there is something to echo.
*** display-hourglass                                         :display:frame:
    On graphical displays, Emacs displays the mouse pointer as an
    hourglass if Emacs is busy. To disable this feature, set this
    variable to ~nil~.
*** hourglass-delay                                           :display:frame:
    This variable determines the number of seconds of busy time before
    the hourglass is shown; the default is 1.
*** make-pointer-invisible                                    :display:frame:
    If the mouse pointer lies inside an Emacs frame, Emacs makes it
    invisible each time you type a character to insert text, to
    prevent it from obscuring the text. (To be precise, the hiding
    occurs when you type a self-inserting character.) Moving the mouse
    pointer makes it visible again. To disable this feature, set this
    variable to ~nil~.
*** underline-minimum-offset                              :char:display:edit:
    On graphical displays, this variable determines the minimum
    distance between the baseline and underline, in pixels, for
    underlined text. By default, the value is 1; increasing it may
    improve the legibility of underlined text for certain
    fonts. (However, Emacs will never draw the underline below the
    current line area.)
*** x-underline-at-descent-line                           :char:display:edit:
    This variable determines how to draw underlined text. The default
    is ~nil~, which means to draw it at the baseline level of the
    font; if you change it to ~t~, Emacs draws the underline at the
    same height as the font's descent line. (If non-default line
    spacing was specified for the underlined text, Emacs draws the
    underline below the additional spacing.)
*** overline-margin                                       :char:display:edit:
    This variable specifies the vertical position of an overline above
    the text, including the height of the overline itself, in pixels;
    the default is 2.
*** display-raw-bytes-as-hex                            :char:coding:display:
    Raw bytes are displayed in octal format by default, for example a
    byte with a decimal value of 128 is displayed as ~\200~. To change
    display to the hexadecimal format of \x80, set this variable to
    ~t~.
** Searching and Replacement
*** isearch-lazy-highlight                            :search:display:buffer:
    If you pause for a little while during incremental search, Emacs
    highlights all the other possible matches for the search string
    that are present on the screen. The other matches are highlighted
    differently from the current match, using the customizable face
    ~lazy-highlight~. If you don't like this feature, you can disable
    it by setting this variable to ~nil~.
*** search-ring-max                                                  :search:
    The number of most recently used search strings saved in the
    search ring is specified by this variable, 16 by default.
*** search-upper-case                                                :search:
    Normally, when the search is case-insensitive, text yanked into
    the search string is converted to lower case, so that the search
    remains case-insensitive. However, if the value of this variable
    is other than ~not-yanks~, that disables this down-casing.

    An upper-case letter anywhere in the search string makes the
    search case-sensitive. This applies to regular expression search
    as well as to literal string search. The effect ceases if you
    delete the upper-case letter from the search string. This variable
    controls this: if it is non-nil, an upper-case character in the
    search string makes the search case-sensitive; setting it to ~nil~
    disables this effect of upper-case characters. The default value
    of this variable is ~not-yanks~, which makes search case-sensitive
    if there are upper-case letters in the search string, and also
    causes text yanked into the search string to be down-cased, so
    that such searches are case-insensitive by default.
*** search-exit-option                                  :search:edit:command:
    Normally, typing a command that is not bound by the incremental
    search exits the search before executing the command. Thus, the
    command operates on the buffer from which you invoked the
    search. However, if you customize this variable to ~append~, the
    characters which you type that are not interpreted by the
    incremental search are simply appended to the search string.
*** isearch-allow-prefix                                     :search:command:
    In previous versions of Emacs, entering a prefix argument always
    terminated the search. You can revert to this behavior by setting
    this variable to ~nil~.

    When ~isearch-allow-scroll~ is non-nil, prefix arguments always
    have the default behavior described in "Not Exiting Incremental
    Search", i.e., they don't terminate the search, even if this
    variable is ~nil~.
*** isearch-allow-scroll                                     :search:command:
    Normally, scrolling commands exit incremental search. If you
    change this variable to a non-nil value, that enables the use of
    the scroll-bar, as well as keyboard scrolling commands like ~C-v~,
    ~M-v~, and ~C-l~. This applies only to calling these commands via
    their bound key sequences - typing ~M-x~ will still exit the
    search. You can give prefix arguments to these commands in the
    usual way. This feature normally won't let you scroll the current
    match out of visibility; but if you customize this variable to the
    special value ~unlimited~, that restriction is lifted.

    The ~isearch-allow-scroll~ feature also affects some other
    commands, such as ~C-x 2~ (~split-window-below~) and ~C-x ^~
    (~enlarge-window~), which don't exactly scroll but do affect where
    the text appears on the screen. It applies to any command whose
    name has a non-nil ~isearch-scroll~ property. So you can control
    which commands are affected by changing these properties.

    This feature can be applied to any command that doesn't
    permanently change point, the buffer contents, the match data, the
    current buffer, or the selected window and frame. The command must
    not itself attempt an incremental search. This feature is disabled
    if this variable is ~nil~ (which it is by default).
*** isearch-yank-on-move                                 :search:region:edit:
    When this variable is customized to ~shift~, you can extend the
    search string by holding down the shift key while typing cursor
    motion commands. It will yank text that ends at the new position
    after moving point in the current buffer.

    When this variable is ~t~, you can extend the search string
    without using the shift key for cursor motion commands, but it
    applies only for certain motion command that have the
    ~isearch-move~ property on their symbols.
*** regexp-search-ring-max                                           :search:
    The maximum number of search regexps saved in the search ring is
    determined by the value of this variable, 16 by default.
*** search-whitespace-regexp                                    :search:char:
    This variable specifies the regexp for the lax space matching.

    For example, to make spaces match sequences of newlines as well as
    spaces, set it to '~"[[:space:]\n]+"~'. The default value of this
    variable depends on the buffer's major mode; most major modes
    classify spaces, tabs, and formfeed characters as whitespace.

    To disable lax whitespace matching for all searches, change this
    variable to ~nil~; then each space in the search string matches
    exactly one space.
*** case-fold-search                                     :search:buffer:char:
    If you set this variable to ~nil~, then all letters must match
    exactly, including case. This is a per-buffer variable; altering
    the variable normally affects only the current buffer, unless you
    change its default value. This variable applies to nonincremental
    searches also, including those performed by the replace commands
    and the minibuffer history matching commands.
*** search-default-mode                                         :search:char:
    Generally, search commands in Emacs do not by default perform
    character folding in order to match equivalent character
    sequences. You can enable this behavior by customizing this
    variable to ~char-fold-to-regexp~.
*** char-fold-symmetric                                         :search:char:
    By default, typing an explicit variant of a character, such as
    ~ä~, as part of the search string doesn't match its base
    character, such as ~a~. But if you customize this variable to ~t~,
    then search commands treat equivalent characters the same and use
    of any of a set of equivalent characters in a search string finds
    any of them in the text being searched, so typing an accented
    character ~ä~ matches the letter ~a~ as well as all the other
    variants like ~á~.
*** char-fold-include                                           :search:char:
    You can add new character foldings using this variable.
*** char-fold-exclude                                           :search:char:
    You can remove existing character foldings using this variable.
*** replace-lax-whitespace                                      :search:char:
    Unlike incremental search, the replacement commands do not use lax
    space matching by default. To enable lax space matching for
    replacement, change this variable to non-nil. (This only affects
    how Emacs finds the text to replace, not the replacement text.)
*** replace-regexp-lax-whitespace                               :search:char:
    Unlike incremental search, the replacement commands do not use lax
    space matching by default. This is a companion variable to
    ~replace-lax-whitespace~ which controls whether the command
    ~query-replace-regexp~ uses lax whitespace matching when searching
    for patterns.
*** case-replace                                                :search:char:
    If upper-case letters are used in the replacement string, they
    remain upper case every time that text is inserted. If upper-case
    letters are used in the first argument, the second argument is
    always substituted exactly as given, with no case conversion. If
    this variable is set to ~nil~, replacement is done without case
    conversion.
*** replace-char-fold                                           :search:char:
    The replacement commands by default do not use character folding
    when looking for the text to replace. To enable character folding
    for matching in ~query-replace~ and ~replace-string~, set this
    variable to a non-nil value. (This setting does not affect the
    replacement text, only how Emacs finds the text to replace. It
    also doesn't affect ~replace-regexp~.)
*** query-replace-from-to-separator                          :search:display:
    You can reuse earlier replacements with the commands
    ~query-replace~ or ~query-replace-regexp~. When either these
    commands prompts for the search string, use ~M-p~ and ~M-n~ to
    show previous replacements in the form '~from -> to~', where
    /from/ is the search pattern, /to/ is its replacement, and the
    separator between them is determined by the value of this
    variable. If the value of this variable is ~nil~, replacements are
    not added to the command history, and cannot be reused.
*** query-replace-highlight                                  :search:display:
    The commands ~query-replace~ and ~query-replace-regexp~ highlight
    the current match using the face ~query-replace~. You can disable
    this highlight by setting this variable to ~nil~.
*** query-replace-lazy-highlight                             :search:display:
    The commands ~query-replace~ and ~query-replace-regexp~ highlight
    any match that is not the current match using the ~lazy-highlight~
    face just link incremental search; this can be disabled by setting
    this variable to ~nil~.
*** query-replace-show-replacement                           :search:display:
    By default, ~query-replace-regexp~ will show the substituted
    replacement string for the current match in the minibuffer. If you
    want to keep special sequences '~\&~' and '~\n~' unexpanded,
    customize this variable
*** query-replace-skip-read-only                                 :search:nav:
    This variable, if set non-nil, will cause replacement commands to
    ignore matches in read-only text. The default is not to ignore
    them.
*** search-invisible                                                 :search:
    This variable determines how ~query-replace~ treats invisible
    text.
*** list-matching-lines-default-context-lines  :search:display:inform:window:
    In occur mode, the default number of context lines is specified by
    this variable.
*** list-matching-lines-jump-to-current-line   :search:inform:window:display:
    When this variable is non-nil the current line is shown
    highlighted with face ~list-matching-lines-current-line-face~ and
    the point is set at the first match after such line.
*** search-default-mode                                              :search:
    The default search mode for the incremental search is specified by
    this variable. It can be ~nil~, ~t~, or a function. If it is
    ~nil~, the default mode is to do literal searches without
    character folding, but with case folding and lax-whitespace
    matches as determined by ~case-fold-search~ and
    ~search-whitespace-regexp~, respectively. If the value is ~t~,
    incremental search defaults to regexp searches. The default value
    specifies a function that only performs case folding and
    lax-whitespace matching.
*** search-highlight                                         :search:display:
    The current match of an on-going incremental search is highlighted
    using the ~isearch~ face. This highlighting can be disabled by
    setting this variable to ~nil~.
*** lazy-highlight-initial-delay                              :search:display:
    Time in seconds to wait before highlighting visible matches.
*** lazy-highlight-interval                                  :search:display:
    Time in seconds between highlighting successive matches.
*** lazy-highlight-max-at-a-time                             :search:display:
    The maximum number of matches to highlight before checking for
    input. A large number can take some time to highlight, so if you
    want to continue searching and type ~C-s~ or ~C-r~ during that
    time, Emacs will not respond until it finishes highlighting all
    those matches. Thus smaller values make Emacs more responsive.
*** isearch-lazy-count                                :search:display:inform:
    Show the current match number and the total number of matches in
    the search prompt
*** lazy-count-prefix-format                          :search:display:inform:
    This variable determines the format of showing the current match
    number for ~isearch-lazy-count~.
*** lazy-count-suffix-format                          :search:display:inform:
    This variable determines the format of showing the total number of
    matches for ~isearch-lazy-count~.
*** search-nonincremental-instead                                    :search:
    Normally, entering ~RET~ within incremental search when the search
    string is empty launches a nonincremental search. However if you
    customize this variable to ~nil~, typing ~RET~ will always exit
    the incremental search, even if the search string is empty.
*** isearch-hide-immediately                                 :search:display:
    By default, incremental search and query-replace commands match
    invisible text, but hide any such matches as soon as the current
    match moves off the invisible text. If you customize this variable
    to ~nil~, any invisible text where matches were found stays on
    display until the search or the replace command exits.
*** search-slow-speed                                                :search:
    Emacs provides a special display mode for slow terminals, whereby
    search pops up a separate small window and displays the text
    surrounding the match in that window. This variable determines the
    baud rate threshold below which Emacs will use this display mode.
*** search-slow-window-lines                                 :search:display:
    Emacs provides a special display mode for slow terminals, whereby
    search pops up a separate small window and displays the text
    surrounding the match in that window. This variable controls the
    number of lines in the window Emacs pops up for displaying the
    search results; the default is 1 line. Normally this window will
    pop up at the bottom of the window that displays the buffer where
    you start searching, but if the value of this variable is
    negative, that means to put the window at the top and give it the
    number of lines that is the absolute value of the variable.
** Commands for Fixing Typos
*** undo-limit                                                         :undo:
    You can specify how much undo information to keep by setting this
    variable. This variable sets a soft limit: Emacs keeps undo data
    for enough commands to reach this size, and perhaps exceed it, but
    does not keep data for any earlier commands beyond that. It's
    default value is 160,000.
*** undo-strong-limit                                                  :undo:
    You can specify how much undo information to keep by setting this
    variable. This variable sets a stricter limit: any previous
    command (though not the most recent one) that pushes the size past
    this amount is forgotten. The default value is 240,000.
*** undo-outer-limit                                                   :undo:
    You can specify how much undo information to keep by setting this
    variable. The most recent change is never discarded unless it gets
    bigger than this variable (normally 24,000,000).
*** ispell-local-dictionary                                          :inform:
    The standard dictionary is specified by this variable, or if this
    is ~nil~ by the variable ~ispell-dictionary~. If both are ~nil~,
    the spelling program's default dictionary is used.
*** ispell-dictionary                                                :inform:
    The standard dictionary is specified by the variable
    ~ispell-local-dictionary~ or, if that is ~nil~, by this
    variable. If both are ~nil~, the spelling program's default
    dictionary is used.
*** ispell-personal-dictionary                                       :inform:
    Your personal dictionary is specified by this variable. If it is
    ~nil~, the spelling program looks for a personal dictionary in a
    default location, which is specific to each spell-checker.
*** ispell-complete-word-dict
    This variable specifies the file name for the word completion
    dictionary.
** Keyboard Macros
*** kmacro-execute-before-append
    After terminating the definition of a keyboard macro, you can
    append more keystrokes to its definition by typing ~C-u
    <F3>~. This is equivalent to plain ~<F3>~ followed by retyping the
    whole definition so far. If you change this variable to ~nil~, the
    existing macro will not be re-executed before appending to it (the
    default is ~t~).
* Faces
** The Minibuffer
*** minibuffer-prompt
    When the minibuffer is in use, it appears in the echo area, with a
    cursor. The minibuffer starts with a /prompt/, usually ending with
    a colon. The prompt states what kind of input is expected, and how
    it will be used. The prompt is highlighting using this face.
** The Mark and the Region
*** region
    Setting the mark at a position in the text /activates/ it. When
    the mark is active, we say that the region is active; Emacs
    indicates its extent by highlighting the text within it, using
    this face.
** Killing and Moving Text
*** secondary-selection
    When using ~mouse-set-secondary~ the selected text is highlighted,
    using this face as you drag.
** Controlling the Display
*** standard faces
**** default
     This face is used for ordinary text that doesn't specify any
     face. Its background color is used as the frame's background
     color.
**** bold
     This face uses bold variant of the default font.
**** italic
     This face uses an italic variant of the default font.
**** bold-italic
     This face uses a bold italic variant of the default font.
**** underline
     This face underlines text.
**** fixed-pitch
     This face forces use of a fixed-width font. It's reasonable to
     customize this face to use a different fixed-width font, if you
     like, but you should not make it a variable-width font.
**** fixed-pitch-serif
     This face is like ~fixed-pitch~, except the font has serifs and
     looks more like traditional typewriting.
**** variable-pitch
     This face forces use of a variable-width font.
**** shadow
     This face is used for making the text less noticeable than the
     surrounding ordinary text. Usually this can be achieved by using
     shades of grey in contrast with either black or white default
     foreground color.
*** highlight faces
**** highlight
     This face is used for text highlighting in various contexts, such
     as when the mouse cursor is moved over a hyperlink.
**** isearch
     The face is used to highlight the current Isearch match
**** query-replace
     This face is used to highlight the current Query Replace match
**** lazy-highlight
     This face is used to highlight lazy matches for Isearch and Query
     Replace (matches other than the current one).
**** region
     This face is used for displaying an active region. When Emacs is
     built with GTK+ support, its colors are taken from the current
     GTK+ theme.
**** secondary-selection
     This face is used for displaying a secondary X selection.
**** trailing-whitespace
     The face for highlighting excess spaces and tabs at the end of a
     line when ~show-trailing-whitespace~ is non-nil.
**** escape-glyph
     The face for displaying control characters and escape sequences.
**** homoglyph
     The face for displaying lookalike characters, i.e., characters
     that look like but are not the characters being represented.
**** nobreak-space
     The face for displaying no-break space characters.
**** nobreak-hyphen
     The face for displaying no-break hyphen characters
*** frame faces
**** mode-line
     This faces is used for the mode line of the currently selected
     window, and for menu bars when toolkit menus are not used. By
     default, it's drawn with shadows for a raised effect on graphical
     displays, and drawn as the inverse of the default face on
     non-windowed terminals.

     On graphical displays, the mode line is drawn as a 3D box. If you
     don't like this effect, you can disable it by customizing this
     face and setting the ~box~ attribute to ~nil~.
**** mode-line-inactive
     Like ~mode-line~, but used for mode lines of the windows other
     than the selected one (if ~mode-line-in-non-selected-windows~ is
     non-nil). This face inherits from ~mode-line~, so changes in that
     face affect mode lines in all windows.
**** mode-line-highlight
     Like ~highlight~, but used for mouse-sensitive portions of text
     on mode lines. Such portions of text typically pop up tooltips
     when the mouse pointer hovers above them.
**** mode-line-buffer-id
     This face is used for buffer identification parts in the mode
     line.
**** header-line
     Similar to ~mode-line~ for a window's header line, which appears
     at the top of a window just as the mode line appears at the
     bottom. Most windows do not have a header line - only some
     special modes, such as Info mode, create one.
**** header-line-highlight
     Similar to ~highlight~ and ~mode-line-highlight~, but used for
     mouse sensitive portions of text on header lines. This is a
     separate face because the ~header-line~ face might be customized
     in a way that does not interact well with ~highlight~.
**** vertical-border
     This face is used for the vertical divider between windows on
     text terminals.
**** minibuffer-prompt
     This face is used for the prompt strings displayed in the
     minibuffer. By default, Emacs automatically adds this face to the
     value of ~minibuffer-prompt-properties~, which is a list of text
     properties used to display the prompt text. (This variable takes
     effect when you enter the minibuffer.)
**** fringe
     The face for the fringes to the left and right of windows on
     graphic displays. (The fringes are the narrow portions of the
     Emacs frame between the text area and the window's right and left
     borders.)
**** cursor
     The ~:background~ attribute of this face specifies the color of
     the text cursor.

     The other attributes of this face have no effect; the text shown
     under the cursor is drawn using the frame's background color.
**** tooltip
     This face is used for tooltip text. By default, if Emacs is built
     with GTK+ support, tooltips are drawn via GTK+ and this face has
     no effect.
**** mouse
     This face determines the color of the mouse pointer.
**** line-number
     The line numbers that are displayed when
     ~display-line-numbers-mode~ is turned on, are displayed in this
     special face.
**** line-number-current-line
     The current line number is displayed in a different face, namely
     this face, so you can make the current line's number have a
     distinct appearance, which will help locating the line showing
     point.
**** line-number-major-tick
     This is an additional face that can be used to highlight the line
     numbers of lines which are multiple of certain numbers.
**** line-number-minor-tick
     This is yet an additional face that can be used to highlight the
     line numbers of lines which are multiple of certain numbers.
*** text frame faces
**** scroll-bar
     This face determines the visual appearance of the scroll bar.
**** tool-bar
     This face determines the color of tool bar icons.
**** menu
     This face determines the colors and font of Emacs's menus.
**** tty-menu-enabled-face
     This face is used to display enabled menu item on text-mode
     terminals.
**** tty-menu-disabled-face
     This face is used to display disabled menu items on text-mode
     terminals.
**** tty-menu-selected-face
     This face is used to display on text-mode terminals the menu item
     that would be selected if you click a mouse or press ~<RET>~.
*** other faces
**** font-lock-string-face
     Face for how to display strings in font lock mode.
**** font-lock-comment-face
     Face for how to display comments in font lock mode.
**** fill-column-indicator
     Specifies the face used to display the indicator. It inherits its
     default values from the face ~shadow~ but without background
     color. To change the indicator color you need only set the
     foreground color of this face.
**** display-time-mail-face
     Face used to customize how prominent the mail indicator is when
     Display Time mode is enabled.
**** glyphless-char
     The face applied to all characters that cannot find a glyph in
     any available font.
** Searching and Replacement
*** isearch-fail
    If your string is not found at all, the echo area says '~Failing
    I-Search~', and the part of the search string that failed to match
    is highlighted using this face
*** list-matching-lines-current-line-face
    When ~list-matching-lines-jump-to-current-line~ is non-nil the
    current line is shown highlighted with this face.
* .emacs additions
** Registers
*** Saving Text in Registers
    If you always want to use a register separator in all buffers you
    can use the following setting.

    #+BEGIN_SRC emacs-lisp
    (setq register-separator ?+)
    (set-register register-separator "\n\n")
    #+END_SRC

*** Keeping File Names in Registers
    Generic lisp code for storing a file name in a particular
    register.

    #+BEGIN_SRC emacs-lisp
    (set-register c '(file . name))
    #+END_SRC

    Example code
    #+BEGIN_SRC emacs-lisp
    (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))
    #+END_SRC
    puts the file name shown into register 'z'.
** Controlling the Display
*** Font Lock mode
    To impose the setting to disable Font Lock mode in all buffers for
    future Emacs sessions, add the following line to your init file:

    #+BEGIN_SRC emacs-lisp
    (global-font-lock-mode 0)
    #+END_SRC

    If you have disabled Global Font Lock mode, you can still enable
    Font Lock for specific major modes by adding the function
    ~font-lock-mode~ to the mode hooks. For example, to enable Font
    Lock mode for editing C files, you can do this:

    #+BEGIN_SRC emacs-lisp
    (add-hook 'c-mode-hook 'font-lock-mode)
    #+END_SRC

    Font Lock highlighting patterns already exist for most modes, but
    you may want to fontify additional patterns. You can use the
    function ~font-lock-add-keywords~, to add your own highlighting
    patterns for a particular mode. For example, to highlight
    '~FIXME:~' words in C comments, use this:

    #+BEGIN_SRC emacs-lisp
    (add-hook 'c-mode-hook
              (lambda ()
	       (font-lock-add-keywords nil
	        '(("\\<\\(FIXME\\):" 1
		   font-lock-warning-face t)))))
    #+END_SRC

    To remove keywords from the font-lock highlighting patterns, use
    the function ~font-lock-remove-keywords~.
*** Interactive Highlighting
    To enable Hi Lock mode for all buffers, place

    #+BEGIN_SRC emacs-lisp
    (global-hi-lock-mode 1)
    #+END_SRC

*** Displaying Boundaries
    Emacs can add an indicator to display a fell column position. It
    is possible to use the following addition to activate the
    indicator in a hook:

    #+BEGIN_SRC emacs-lisp
    (add-hook 'org-mode-hook 'display-fill-column-indicator-mode)
    #+END_SRC

    And the following addition to enable it globally.
    #+BEGIN_SRC emacs-lisp
    (global-display-fill-column-indicator-mode 1)
    #+END_SRC

*** Useless Whitespace
    On graphical displays, Emacs can indicate unused lines at the end
    of the window with a small image in the left fringe. The image
    appears for screen lines that do not correspond to any buffer
    text, so blank lines at the end of the buffer stand out because
    they lack this image. You can enable or disable this feature for
    all new buffers by setting the default value for this variable:

    #+BEGIN_SRC emacs-lisp
    (setq-default indicate-empty-lines t)
    #+END_SRC

*** Displaying the Cursor
    To disable cursor blinking altogether add this line:
    #+BEGIN_SRC emacs-lisp
    (blink-cursor-mode 0)
    #+END_SRC

*** Customization of Display
    On some text terminals, bold face and inverse video together
    result in text that is hard to read. Put the following code in
    your .emacs file to suppress the effect of bold-face in this
    case.
    #+BEGIN_SRC emacs-lisp
    (tty-suppress-bold-inverse-default-colors t)
    #+END_SRC

** Searching and Replacement
*** Not Exiting Incremental Search
    The ~isearch-allow-scroll~ feature also affects some other
    commands, such as ~C-x 2~ (~split-window-below~) and ~C-x ^~
    (~enlarge-window~), which don't exactly scroll but do affect
    where the text appears on the screen. It applies to any command
    whose name has a non-nil ~isearch-scroll~ property. So you can
    control which commands are affected by changing these properties.

    For example, to make ~C-h l~ usable within an incremental search
    in all future Emacs sessions, use ~C-h c~ to find what command it
    runs, which is ~view-lossage~. Then you can put the following
    line in your init file:

    #+BEGIN_SRC emacs-lisp
    (put 'view-lossage 'isearch-scroll t)
    #+END_SRC

    This feature can be applied to any command that doesn't
    permanently change point, the buffer contents, the match data,
    the current buffer, or the selected window and frame. The command
    must not itself attempt an incremental search.
** Commands for Fixing Typos
*** Flyspell Hook
    To enable Flyspell mode in all text mode buffers, add
    ~flyspell-mode~ to ~text-mode-hook~.

    #+BEGIN_SRC emacs-lisp
      (add-hook 'text-mode-hook 'flyspell-mode)
    #+END_SRC

    To enable Flyspell Prog mode in all programming mode buffers add
    ~flyspell-prog-mode~ to ~prog-mode-hook~

    #+BEGIN_SRC emacs-lisp
      (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    #+END_SRC

* Command Properties
** Searching and Replacement
*** isearch-scroll
    See variable ~isearch-allow-scroll~ for details
*** isearch-move
    See variable ~isearch-yank-on-move~ for details
* Niche Modes
** Bookmark Menu
*** Description
    Use this buffer to edit bookmark definitions or annotate the
    bookmarks.
*** Enter Mode
    ~C-x r l~
*** Find Commands
    ~C-h m~
* Notes
** Undo
   There are a few ways someone can break a sweat in Emacs and wonder
   what has gone wrong. My experience has told me that Emacs does not
   immediately make it obvious how to undo each of these scenarios. It
   is important to understand each one.
*** My screen looks entirely different than what I had been working on
    In this case it is likely that the user "switched buffers". You
    can think of buffers as like different tabs in a browser. Emacs
    has different tabs too that can hold different content that you
    are working on. Likely you accidentally switched tabs (buffers)
    without realizing it. Switching back to what you were working on
    is simple. You can hit the keys ~C-x b <RET>~ and it should bring
    you back to the tab (buffer) you were working in. If you are
    nervous about keyboard shortcuts, likely you are using a version
    of Emacs that should have a menu at the top. One of the menu items
    should say /Buffers/. Click on this menu item and you can see all
    the open tabs. There are some tabs that are always available by
    default like the /GNU Emacs/ welcome screen, or a space that
    serves as essentially /scratch/ paper. Emacs requires that you
    name each file that you work on, so you should find the name of
    that file in this list of tabs (buffers). Try to think of this
    separation of work as buffers though as it makes memorizing the
    shortcut keys easier. In this case ~C-x~ is the command for what I
    think of as e-*x*-tra commands, and then when I hit the key ~b~
    I'm indicating I want to switch buffers. You can type the buffer
    name explicitly, but normally when you switch away from a buffer,
    just hitting enter will return you to the buffer you just left.
*** My cursor isn't returning to the spot I was working on
    Likely your cursor is at the bottom of the screen in what is
    called the /Echo Area/. Your cursor gets moved here when you are
    in the middle of an instruction to Emacs. If you did not intend to
    tell Emacs anything, there are two methods to escaping this
    area. One is ~C-g~. This is often a universal way to escape a
    command. It is very helpful. I have found every once in a while
    this method does not work in which case the command ~<ESC> <ESC>
    <ESC>~ normally does the trick for me. Please note that it is best
    practice after hitting ~<ESC> <ESC> <ESC>~ to then type
    ~C-g~. This avoids unintended effects due to quirks in Emacs
    commands.

    The ~<ESC>~ key can sometimes double as the ~<META>~ key if your
    computer is missing an ~<ALT>~ key or a keybinding in Emacs is
    overridden by your computer. Sometimes when you are nervous it's
    easy to just keep hitting ~<ESC>~ until the problem in Emacs is
    finished. If you hit ~<ESC>~ four (4) times, there's a possibility
    the next key you hit will be interpreted as being tied to a meta
    command. For example, ~<ESC> q~ will wrap text according to your
    preferences (or preset preferences). For this reason, if you hit
    ~C-g~ after hitting ~<ESC> <ESC> <ESC>~ you are less likely to
    have unintended consequences.
*** My Emacs screen appears to be split in half
    Each part of the screen is called a /window/. This can be
    confusing for new users since we are used to a window being
    whatever we can minimize in our operating system. The thing to
    keep in mind is that Emacs has been around for a long time, back
    when computers were only text. It used to be that what you see in
    the Emacs frame was the entire screen of old computers. This is
    why the word /window/ was used, and for consistency has not been
    changed. There are two commands I use most to make it so there is
    only one window, and it is the window I care about. The first is
    ~C-x o~. This moves my cursor from window to window. I use this
    until I see my cursor blinking in the window I care about. Once
    the cursor is in the window I care about, I use the command ~C-x
    1~. This is essentially saying "I want one (1) window, and I want
    it to be the active window."
*** I made a sudden huge edit I did not mean to make
    This is the normal way we think of undo! This command is fairly
    straight forward, but I have found the Emacs documentation doesn't
    make it easy to find. The command is ~C-/~.
*** My screen looks like a long list, I can't type, what's happening?
    Sometimes Emacs switches into a special mode without making it
    clear. If your screen looks like a long list do not type. So far
    there have been two keys in these scenarios that appear to be
    fairly universal regardless of the specific mode you have found
    yourself in. ~h~ will bring up a small help window, and ~q~ will
    quit the mode. Emacs and Emacs manuals do a terrible job
    telegraphing this information to the user.
** Language
   There are times when first reading an Emacs manual, you will run
   into language that you don't understand because Emacs hasn't
   defined it yet. In an attempt to make this easier on people here is
   some of the language Emacs forgets is new for lots of people
*** customize the variable
    Emacs has so much customizability. Basically anything in Emacs you
    can imagine is possible to customize. This means that Emacs makes
    a lot of assumptions for you when you start up Emacs. Each
    assumption is held in a value called a /Variable/. If you want to
    change one of the assumptions that Emacs has made for you, then
    you need to change the value of the associated variable. This is
    what Emacs means when they say "customize the variable". They are
    saying "You can change the set of assumptions we made".

    TODO: How do you actually make those changes.
** Emacs manual
   On my Ubuntu computer, when I installed Emacs, the official Emacs
   manual was not included for some strange reason. I needed to
   install the package ~emacs-common-non-dfsg~ for Emacs 26 and up
   onto my computer from the command line (it's a Linux package, not
   an Emacs package).
* Extra

#  LocalWords:  SRC buf pos emacsclient nn SPC RET ESC Esc Ctrl txt
#  LocalWords:  substring PageDown PageUp sexp defun rect dir goto HL
#  LocalWords:  eval UTF NUL CUA hscroll overlining RGB pre rgb JIT
#  LocalWords:  RRGGBB fontification Fontifying fontifies fontified
#  LocalWords:  jit prog Whitespace eol unix whitespace nobreak alist
#  LocalWords:  homoglyph glyphless submenu isearch wrappedness cua
#  LocalWords:  nonincremental Overwrapped mistyped nonincrementally
#  LocalWords:  postfix matcher keymaps iconifies Semipermanent tmm
#  LocalWords:  semipermanent fontify menubar nav hl lossage upcase
#  LocalWords:  downcase ispell prepend frameset kmacro prev del eww
#  LocalWords:  sexps tty ttm radix eldef arg ok interprogram ctl GTK
#  LocalWords:  hbar overline foldings unexpanded setq init
#  LocalWords:  customizability
